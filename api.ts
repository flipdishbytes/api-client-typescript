/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Accept
*/
export class Accept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Accept.attributeTypeMap;
    }
}

/**
* Account details
*/
export class AccountDetail {
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Signup steps
    */
    'SignupSteps'?: Array<SignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified'?: boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser'?: boolean;
    /**
    * Accounts Id
    */
    'AccountId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SignupSteps",
            "baseName": "SignupSteps",
            "type": "Array<SignupStep>"
        },
        {
            "name": "IsVerified",
            "baseName": "IsVerified",
            "type": "boolean"
        },
        {
            "name": "IsSelfServeUser",
            "baseName": "IsSelfServeUser",
            "type": "boolean"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetail.attributeTypeMap;
    }
}

/**
* Account Details Base
*/
export class AccountDetailBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetailBase.attributeTypeMap;
    }
}

/**
* Represents the format of a bank account field
*/
export class AccountFieldDefinition {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldDefinition.KeyEnum;
    /**
    * Display name of the field
    */
    'DisplayName'?: string;
    /**
    * There are some fields that are of type known to the frontend (IBAN, Swift) -- for those frontend should use its own validation library, e.g. ibantools
    */
    'Type'?: AccountFieldDefinition.TypeEnum;
    /**
    * Minimum length of the field
    */
    'MinLength'?: number;
    /**
    * Maximum length of the field
    */
    'MaxLength'?: number;
    /**
    * Is the field digits (numeric) only
    */
    'DigitsOnly'?: boolean;
    /**
    * Regex for validating the field (if specified)
    */
    'Regex'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldDefinition.KeyEnum"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "AccountFieldDefinition.TypeEnum"
        },
        {
            "name": "MinLength",
            "baseName": "MinLength",
            "type": "number"
        },
        {
            "name": "MaxLength",
            "baseName": "MaxLength",
            "type": "number"
        },
        {
            "name": "DigitsOnly",
            "baseName": "DigitsOnly",
            "type": "boolean"
        },
        {
            "name": "Regex",
            "baseName": "Regex",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldDefinition.attributeTypeMap;
    }
}

export namespace AccountFieldDefinition {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
    export enum TypeEnum {
        None = <any> 'None',
        Iban = <any> 'Iban'
    }
}
/**
* Represents one populated account field (its key and value)
*/
export class AccountFieldKeyValuePair {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldKeyValuePair.KeyEnum;
    /**
    * The value of the field
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldKeyValuePair.KeyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldKeyValuePair.attributeTypeMap;
    }
}

export namespace AccountFieldKeyValuePair {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
}
/**
* List of field definitions per country
*/
export class AccountFieldsDefinitions {
    /**
    * List of field definitions per country
    */
    'DefinitionsPerCountry'?: { [key: string]: Array<AccountFieldDefinition>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DefinitionsPerCountry",
            "baseName": "DefinitionsPerCountry",
            "type": "{ [key: string]: Array<AccountFieldDefinition>; }"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Add item details
*/
export class AddItemDetails {
    /**
    * Promotional Item Id
    */
    'PromotionalItemId'?: number;
    /**
    * Promotional Item Name
    */
    'PromotionalItemName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionalItemId",
            "baseName": "PromotionalItemId",
            "type": "number"
        },
        {
            "name": "PromotionalItemName",
            "baseName": "PromotionalItemName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddItemDetails.attributeTypeMap;
    }
}

export class AddressFormDisplayFormat {
    'OneLine'?: string;
    'TwoLines'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OneLine",
            "baseName": "OneLine",
            "type": "string"
        },
        {
            "name": "TwoLines",
            "baseName": "TwoLines",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AddressFormDisplayFormat.attributeTypeMap;
    }
}

/**
* A response of a dyanmic form definition.
*/
export class AddressFormResponse {
    /**
    * List of field definitions.
    */
    'FormData'?: Array<DynamicFormField>;
    /**
    * ISO two letter code.
    */
    'CountryCode'?: string;
    /**
    * ISO culture code.
    */
    'Language'?: string;
    /**
    * Templates used to format form fields when displaying items in a list.
    */
    'DisplayFormat'?: AddressFormDisplayFormat;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FormData",
            "baseName": "FormData",
            "type": "Array<DynamicFormField>"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "DisplayFormat",
            "baseName": "DisplayFormat",
            "type": "AddressFormDisplayFormat"
        }    ];

    static getAttributeTypeMap() {
        return AddressFormResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class AllMetadataResult {
    /**
    * Menu item metadata
    */
    'MenuItemMetadata'?: Array<Metadata>;
    /**
    * Menu item optionset item metadata
    */
    'MenuItemOptionSetItemMetadata'?: Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemMetadata",
            "baseName": "MenuItemMetadata",
            "type": "Array<Metadata>"
        },
        {
            "name": "MenuItemOptionSetItemMetadata",
            "baseName": "MenuItemOptionSetItemMetadata",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return AllMetadataResult.attributeTypeMap;
    }
}

/**
* Client Analytics event
*/
export class AnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Type of the event
    */
    'EventType'?: string;
    /**
    * Type of the app the event is coming from
    */
    'AppType'?: string;
    /**
    * JSON Metadata
    */
    'Metadata'?: string;
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * Latitude of the event
    */
    'Latitude'?: number;
    /**
    * Longitude of the event
    */
    'Longitude'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalyticsClientEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The values of this data point
    */
    'CurrencyData'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return ApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmDataPoint.attributeTypeMap;
    }
}

/**
* Provides an average value for a single hour of day of the week
*/
export class ApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day'?: ApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour'?: number;
    /**
    * Total Value
    */
    'TotalValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "ApmHourlyDataPoint.DayEnum"
        },
        {
            "name": "Hour",
            "baseName": "Hour",
            "type": "number"
        },
        {
            "name": "TotalValue",
            "baseName": "TotalValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmHourlyDataPoint.attributeTypeMap;
    }
}

export namespace ApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class ApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved'?: number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved'?: number;
    /**
    * Currency based data
    */
    'CurrencyData'?: Array<StatisticsCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesSaved",
            "baseName": "EstimatedMinutesSaved",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesCouldSaved",
            "baseName": "EstimatedMinutesCouldSaved",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<StatisticsCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatistics.attributeTypeMap;
    }
}

/**
* APM status
*/
export class ApmStatus {
    /**
    * Indicates if APM is active or otherwise
    */
    'IsApmEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsApmEnabled",
            "baseName": "IsApmEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatus.attributeTypeMap;
    }
}

/**
* App
*/
export class App {
    /**
    * App Identifier
    */
    'AppId'?: string;
    /**
    * Has iOS app in Apple App Store. This is readonly.
    */
    'HasIosApp'?: boolean;
    /**
    * Has Android app in Google Play Store. This is readonly.
    */
    'HasAndroidApp'?: boolean;
    /**
    * Country identifier in ISO 3166-1 alpha-2 format.   This code is set automatically based on the locations of the Stores in the App.     The App Country is used    - to determine how to parse mobile phone numbers that are entered in their local numbering format   - to determine if country specific payment methods should be offered   - in various fraud checks
    */
    'CountryId'?: string;
    /**
    * Application Logo.
    */
    'LogoImageUrl'?: string;
    /**
    * Languages that have been selected to be available to customers.
    */
    'Languages'?: Array<Language>;
    /**
    * Lists all languages that are supported by Flipdish.
    */
    'AvailableAppLanguages'?: Array<Language>;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel'?: App.AppAccessLevelEnum;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet'?: Array<App.AppResourceSetEnum>;
    /**
    * Feature flags. These cannot be set by 3rd parties.
    */
    'Features'?: Array<string>;
    /**
    * Center of the map coordinates. This is used to center the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapCenter'?: Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapNorthEast'?: Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapSouthWest'?: Coordinates;
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: App.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "HasIosApp",
            "baseName": "HasIosApp",
            "type": "boolean"
        },
        {
            "name": "HasAndroidApp",
            "baseName": "HasAndroidApp",
            "type": "boolean"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "LogoImageUrl",
            "baseName": "LogoImageUrl",
            "type": "string"
        },
        {
            "name": "Languages",
            "baseName": "Languages",
            "type": "Array<Language>"
        },
        {
            "name": "AvailableAppLanguages",
            "baseName": "AvailableAppLanguages",
            "type": "Array<Language>"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "App.AppAccessLevelEnum"
        },
        {
            "name": "AppResourceSet",
            "baseName": "AppResourceSet",
            "type": "Array<App.AppResourceSetEnum>"
        },
        {
            "name": "Features",
            "baseName": "Features",
            "type": "Array<string>"
        },
        {
            "name": "MapCenter",
            "baseName": "MapCenter",
            "type": "Coordinates"
        },
        {
            "name": "MapNorthEast",
            "baseName": "MapNorthEast",
            "type": "Coordinates"
        },
        {
            "name": "MapSouthWest",
            "baseName": "MapSouthWest",
            "type": "Coordinates"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "App.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return App.attributeTypeMap;
    }
}

export namespace App {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Support = <any> 'Support'
    }
    export enum AppResourceSetEnum {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        EditAppAssets = <any> 'EditAppAssets',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        CreateTeammateIntegrator = <any> 'CreateTeammateIntegrator',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        DeleteCampaignsConfigurations = <any> 'DeleteCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        EditStoreKioskSettings = <any> 'EditStoreKioskSettings',
        EditStoreOrderCapacity = <any> 'EditStoreOrderCapacity',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        UpdateVouchersExtendDisable = <any> 'UpdateVouchersExtendDisable',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewWebsiteDnsVerified = <any> 'ViewWebsiteDnsVerified',
        ViewWebsiteCertificateCreated = <any> 'ViewWebsiteCertificateCreated',
        ViewWebsiteCertificateRenewed = <any> 'ViewWebsiteCertificateRenewed',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        VerifyBankAccounts = <any> 'VerifyBankAccounts',
        ViewServiceChargeConfigurations = <any> 'ViewServiceChargeConfigurations',
        EditServiceChargeConfigurations = <any> 'EditServiceChargeConfigurations',
        ViewHydraConfig = <any> 'ViewHydraConfig',
        UpdateHydraConfigManage = <any> 'UpdateHydraConfigManage',
        InitiateBluetoothPairingMode = <any> 'InitiateBluetoothPairingMode',
        DeleteTerminal = <any> 'DeleteTerminal',
        ViewKioskTelemetry = <any> 'ViewKioskTelemetry',
        ViewCustomers = <any> 'ViewCustomers',
        EditCustomers = <any> 'EditCustomers',
        CreateCatalogElements = <any> 'CreateCatalogElements',
        UpdateCatalogElements = <any> 'UpdateCatalogElements',
        ViewCatalogElements = <any> 'ViewCatalogElements',
        DeleteCatalogElements = <any> 'DeleteCatalogElements',
        ViewMetafieldDefinitions = <any> 'ViewMetafieldDefinitions',
        CreateMetafieldDefinitions = <any> 'CreateMetafieldDefinitions',
        UpdateMetafieldDefinitions = <any> 'UpdateMetafieldDefinitions',
        DeleteMetafieldDefinitions = <any> 'DeleteMetafieldDefinitions',
        UpdateMetafields = <any> 'UpdateMetafields',
        ViewCatalogMenuChanges = <any> 'ViewCatalogMenuChanges',
        PublishCatalogMenuChanges = <any> 'PublishCatalogMenuChanges',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        DownloadCustomerCsvExport = <any> 'DownloadCustomerCsvExport',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        ViewHydraAuditLogs = <any> 'ViewHydraAuditLogs',
        ViewPushNotificationAuditLogs = <any> 'ViewPushNotificationAuditLogs',
        ViewStripeCustomConnectedAccountAuditLogs = <any> 'ViewStripeCustomConnectedAccountAuditLogs',
        ViewKioskBluetoothDeviceAuditLogs = <any> 'ViewKioskBluetoothDeviceAuditLogs',
        ViewExternalAuditLogs = <any> 'ViewExternalAuditLogs',
        CreateExternalAuditLogEvents = <any> 'CreateExternalAuditLogEvents',
        ViewCatalogAuditLogs = <any> 'ViewCatalogAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer',
        InviteDriverToApp = <any> 'InviteDriverToApp',
        GetDriverForApp = <any> 'GetDriverForApp',
        RemoveDriverFromApp = <any> 'RemoveDriverFromApp',
        AssignDriverToOrder = <any> 'AssignDriverToOrder',
        UnassignDriverFromOrder = <any> 'UnassignDriverFromOrder',
        UpdateOrdersDeliveryTrackingStatus = <any> 'UpdateOrdersDeliveryTrackingStatus',
        ViewPayouts = <any> 'ViewPayouts',
        ViewChannels = <any> 'ViewChannels',
        ViewOnboarding = <any> 'ViewOnboarding',
        UpdateOnboarding = <any> 'UpdateOnboarding',
        CreateAppStoreAppConfiguration = <any> 'CreateAppStoreAppConfiguration',
        ViewAppStoreAppConfiguration = <any> 'ViewAppStoreAppConfiguration',
        UpdateAppStoreAppConfiguration = <any> 'UpdateAppStoreAppConfiguration',
        DeleteAppStoreAppConfiguration = <any> 'DeleteAppStoreAppConfiguration'
    }
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Describes a ChannelAssignment which is   when a AppId is assigned to a Sales Channel
*/
export class AppChannelAssignment {
    /**
    * Id of the channel on the assignment
    */
    'ChannelId'?: number;
    /**
    * AppId of the assignment
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppChannelAssignment.attributeTypeMap;
    }
}

/**
* Application compliance model
*/
export class AppCompliance {
    /**
    * App ID
    */
    'AppId'?: string;
    /**
    * Type of compliance.  This controls if the Flipdish websites and apps display cookie consent banners and adjust cookies to be inline with various regulations.   You should set this correctly based on your region.
    */
    'ComplianceType'?: AppCompliance.ComplianceTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "ComplianceType",
            "baseName": "ComplianceType",
            "type": "AppCompliance.ComplianceTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return AppCompliance.attributeTypeMap;
    }
}

export namespace AppCompliance {
    export enum ComplianceTypeEnum {
        Default = <any> 'Default',
        GdprCompliance = <any> 'GdprCompliance'
    }
}
/**
* Application configuration
*/
export class AppConfigUpdateModel {
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: AppConfigUpdateModel.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "AppConfigUpdateModel.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AppConfigUpdateModel.attributeTypeMap;
    }
}

export namespace AppConfigUpdateModel {
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application created event
*/
export class AppCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppCreatedEvent.attributeTypeMap;
    }
}

/**
* App store app
*/
export class AppStoreApp {
    /**
    * Unique App store app id
    */
    'Id': string;
    /**
    * Application verification status
    */
    'VerificationStatus': AppStoreApp.VerificationStatusEnum;
    /**
    * Logo
    */
    'Logo'?: string;
    /**
    * OAuth App identifier
    */
    'OAuthAppId': string;
    /**
    * Details
    */
    'Details': string;
    /**
    * Configuration type  <example>External link</example><example>Flipdish hosted</example>
    */
    'ConfigurationType': AppStoreApp.ConfigurationTypeEnum;
    /**
    * Store selector type
    */
    'StoreSelectorType': AppStoreApp.StoreSelectorTypeEnum;
    /**
    * Field groups
    */
    'FieldGroups'?: Array<FieldGroup>;
    /**
    * Setup instructions
    */
    'SetupInstructions'?: string;
    /**
    * External setup link
    */
    'ExternalSetupLink'?: string;
    /**
    * Teammate app access level
    */
    'TeammateAppAccessLevel'?: AppStoreApp.TeammateAppAccessLevelEnum;
    /**
    * Permissions type
    */
    'PermissionsType': AppStoreApp.PermissionsTypeEnum;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Is application enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Categories
    */
    'Categories': Array<AppStoreApp.CategoriesEnum>;
    /**
    * Countries
    */
    'Countries': Array<AppStoreApp.CountriesEnum>;
    /**
    * Developer Name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreApp.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "OAuthAppId",
            "baseName": "OAuthAppId",
            "type": "string"
        },
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "AppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "AppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreApp.attributeTypeMap;
    }
}

export namespace AppStoreApp {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* App store app configurations
*/
export class AppStoreAppConfiguration {
    /**
    * Unique App store app configuration id
    */
    'Id': string;
    /**
    * App id
    */
    'AppId': string;
    /**
    * App store app id
    */
    'AppStoreAppId': string;
    /**
    * Is enabled
    */
    'IsEnabled': boolean;
    /**
    * Stores id's
    */
    'StoreIds'?: Array<number>;
    /**
    * Settings
    */
    'Settings'?: Array<Setting>;
    /**
    * Application verification status
    */
    'VerificationStatus': AppStoreAppConfiguration.VerificationStatusEnum;
    /**
    * Logo
    */
    'Logo'?: string;
    /**
    * OAuth App identifier
    */
    'OAuthAppId': string;
    /**
    * Details
    */
    'Details': string;
    /**
    * Configuration type  <example>External link</example><example>Flipdish hosted</example>
    */
    'ConfigurationType': AppStoreAppConfiguration.ConfigurationTypeEnum;
    /**
    * Store selector type
    */
    'StoreSelectorType': AppStoreAppConfiguration.StoreSelectorTypeEnum;
    /**
    * Field groups
    */
    'FieldGroups'?: Array<FieldGroup>;
    /**
    * Setup instructions
    */
    'SetupInstructions'?: string;
    /**
    * External setup link
    */
    'ExternalSetupLink'?: string;
    /**
    * Teammate app access level
    */
    'TeammateAppAccessLevel'?: AppStoreAppConfiguration.TeammateAppAccessLevelEnum;
    /**
    * Permissions type
    */
    'PermissionsType': AppStoreAppConfiguration.PermissionsTypeEnum;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Categories
    */
    'Categories': Array<AppStoreAppConfiguration.CategoriesEnum>;
    /**
    * Countries
    */
    'Countries': Array<AppStoreAppConfiguration.CountriesEnum>;
    /**
    * Developer Name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreAppConfiguration.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "OAuthAppId",
            "baseName": "OAuthAppId",
            "type": "string"
        },
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreAppConfiguration.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreAppConfiguration.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "AppStoreAppConfiguration.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "AppStoreAppConfiguration.PermissionsTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreAppConfiguration.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreAppConfiguration.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfiguration.attributeTypeMap;
    }
}

export namespace AppStoreAppConfiguration {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* App store app configuration header information
*/
export class AppStoreAppConfigurationHeader {
    /**
    * Unique App store app id
    */
    'AppStoreAppId': string;
    /**
    * Name of Appstore app
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Logo
    */
    'Logo'?: string;
    /**
    * Developer name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfigurationHeader.attributeTypeMap;
    }
}

/**
* App store app configuration summary information
*/
export class AppStoreAppConfigurationSummary {
    /**
    * Unique App store app configuration id
    */
    'Id': string;
    /**
    * App Id
    */
    'AppId': string;
    /**
    * Is enabled
    */
    'IsEnabled': boolean;
    /**
    * List of stores
    */
    'Stores': Array<ConfiguredStore>;
    /**
    * Configuration type
    */
    'ConfigurationType'?: AppStoreAppConfigurationSummary.ConfigurationTypeEnum;
    /**
    * Store selector type
    */
    'StoreSelectorType'?: AppStoreAppConfigurationSummary.StoreSelectorTypeEnum;
    /**
    * Unique App store app id
    */
    'AppStoreAppId': string;
    /**
    * Name of Appstore app
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Logo
    */
    'Logo'?: string;
    /**
    * Developer name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<ConfiguredStore>"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreAppConfigurationSummary.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreAppConfigurationSummary.StoreSelectorTypeEnum"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfigurationSummary.attributeTypeMap;
    }
}

export namespace AppStoreAppConfigurationSummary {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
/**
* App store app summary information
*/
export class AppStoreAppSummary {
    /**
    * Unique App store app id
    */
    'Id'?: string;
    /**
    * Application verification status
    */
    'VerificationStatus': AppStoreAppSummary.VerificationStatusEnum;
    /**
    * Logo
    */
    'Logo'?: string;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Is application enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Categories
    */
    'Categories': Array<AppStoreAppSummary.CategoriesEnum>;
    /**
    * Countries
    */
    'Countries': Array<AppStoreAppSummary.CountriesEnum>;
    /**
    * Developer Name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreAppSummary.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreAppSummary.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreAppSummary.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppSummary.attributeTypeMap;
    }
}

export namespace AppStoreAppSummary {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* AppStore Config Created event
*/
export class AppStoreConfigCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store App Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Store Configuration Id
    */
    'AppStoreAppConfigurationId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfigurationId",
            "baseName": "AppStoreAppConfigurationId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigCreatedEvent.attributeTypeMap;
    }
}

/**
* AppStore Config Deleted event
*/
export class AppStoreConfigDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Store Configuration Id
    */
    'AppStoreAppConfigurationId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfigurationId",
            "baseName": "AppStoreAppConfigurationId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigDeletedEvent.attributeTypeMap;
    }
}

/**
* AppStore Config Updated event
*/
export class AppStoreConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Configuration
    */
    'AppStoreAppConfiguration'?: UpdateAppStoreAppConfigurationWebhookDTO;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfiguration",
            "baseName": "AppStoreAppConfiguration",
            "type": "UpdateAppStoreAppConfigurationWebhookDTO"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Application updated event
*/
export class AppUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * A summary of changes made
    */
    'Changes'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Changes",
            "baseName": "Changes",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppUpdatedEvent.attributeTypeMap;
    }
}

/**
* Assigned to Store Bank Account
*/
export class AssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id'?: number;
    /**
    * Name of Bank Account
    */
    'BankAccountName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "BankAccountName",
            "baseName": "BankAccountName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssignedBankAccount.attributeTypeMap;
    }
}

/**
* Period opening and closing balance
*/
export class BalanceDetails {
    'OpeningBalance'?: number;
    'ClosingBalance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BalanceDetails.attributeTypeMap;
    }
}

/**
* BANK ACCOUNT
*/
export class BankAccount {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields should be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccount.AccountStateEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccount.attributeTypeMap;
    }
}

export namespace BankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountCreate.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountCreate.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountCreate.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountCreate.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreate.attributeTypeMap;
    }
}

export namespace BankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDetail {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountDetail.AccountStateEnum;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountDetail.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetail.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountDetail.AccountStateEnum"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountDetail.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetail.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetail.attributeTypeMap;
    }
}

export namespace BankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* Represents a request to update bank account information details
*/
export class BankAccountDetailsUpdateRequest {
    /**
    * Address of the bank account
    */
    'BankAddress'?: string;
    /**
    * Address of the payee
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetailsUpdateRequest.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetailsUpdateRequest.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetailsUpdateRequest.attributeTypeMap;
    }
}

export namespace BankAccountDetailsUpdateRequest {
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountSummary {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: string;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountSummary.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountSummary.AccountStateEnum"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountSummary.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountSummary.attributeTypeMap;
    }
}

export namespace BankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountUpdatedEvent.attributeTypeMap;
    }
}

/**
* Status of the bluetooth terminal
*/
export class BluetoothTerminalStatus {
    /**
    * Serial Number
    */
    'SerialNumber'?: string;
    /**
    * Software Version
    */
    'SoftwareVersion'?: string;
    /**
    * Device Type
    */
    'DeviceType'?: BluetoothTerminalStatus.DeviceTypeEnum;
    /**
    * Device Status
    */
    'Status'?: BluetoothTerminalStatus.StatusEnum;
    /**
    * Indication of the battery level from 0 to 1
    */
    'BatteryLevel'?: number;
    /**
    * Last time the status was updated
    */
    'UpdateTime'?: Date;
    /**
    * ReaderId for Stripe Terminal
    */
    'ReaderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "SoftwareVersion",
            "baseName": "SoftwareVersion",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "BluetoothTerminalStatus.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "BluetoothTerminalStatus.StatusEnum"
        },
        {
            "name": "BatteryLevel",
            "baseName": "BatteryLevel",
            "type": "number"
        },
        {
            "name": "UpdateTime",
            "baseName": "UpdateTime",
            "type": "Date"
        },
        {
            "name": "ReaderId",
            "baseName": "ReaderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BluetoothTerminalStatus.attributeTypeMap;
    }
}

export namespace BluetoothTerminalStatus {
    export enum DeviceTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
    export enum StatusEnum {
        NotConnected = <any> 'Not_Connected',
        Connecting = <any> 'Connecting',
        Connected = <any> 'Connected',
        Online = <any> 'Online',
        Offline = <any> 'Offline'
    }
}
/**
* 
*/
export class BusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId'?: number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverride.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BusinessHoursOverrideId",
            "baseName": "BusinessHoursOverrideId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverride.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverride.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverride.attributeTypeMap;
    }
}

export namespace BusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class BusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverrideBase.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverrideBase.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverrideBase.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverrideBase.attributeTypeMap;
    }
}

export namespace BusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriod {
    /**
    * Early
    */
    'Early'?: Range;
    /**
    * Late
    */
    'Late'?: Range;
    /**
    * Ranges
    */
    'Ranges'?: Array<Range>;
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Early",
            "baseName": "Early",
            "type": "Range"
        },
        {
            "name": "Late",
            "baseName": "Late",
            "type": "Range"
        },
        {
            "name": "Ranges",
            "baseName": "Ranges",
            "type": "Array<Range>"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriodBase.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriodBase.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Campaign statistics
*/
export class CampaignStatistics {
    /**
    * Number of issued vouchers
    */
    'VouchersIssued'?: number;
    /**
    * Number of redeemed vouchers
    */
    'VouchersRedeemed'?: number;
    /**
    * Conversion percentage of campaign (VouchersIssued / VouchersRedeemed)
    */
    'Conversion'?: number;
    /**
    * Sales generated by campaign (TotalAmount - FeeChargedToCustomer ie. the discounted sale value)
    */
    'SalesGenerated'?: number;
    /**
    * Return of investment percentage of campaign (TotalAmount / DiscountAmount)
    */
    'ReturnOfInvestment'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VouchersIssued",
            "baseName": "VouchersIssued",
            "type": "number"
        },
        {
            "name": "VouchersRedeemed",
            "baseName": "VouchersRedeemed",
            "type": "number"
        },
        {
            "name": "Conversion",
            "baseName": "Conversion",
            "type": "number"
        },
        {
            "name": "SalesGenerated",
            "baseName": "SalesGenerated",
            "type": "number"
        },
        {
            "name": "ReturnOfInvestment",
            "baseName": "ReturnOfInvestment",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignStatistics.attributeTypeMap;
    }
}

/**
* Card reader
*/
export class CardReader {
    /**
    * Stripe reader id
    */
    'Id'?: string;
    /**
    * Software version
    */
    'DeviceSoftwareVersion'?: string;
    /**
    * Device serial number
    */
    'SerialNumber'?: string;
    /**
    * Device status online or offline
    */
    'Status'?: string;
    /**
    * Registration code
    */
    'RegistrationCode'?: string;
    /**
    * Device type
    */
    'DeviceType'?: string;
    /**
    * Indicates that the reader is deleted or not
    */
    'Deleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "DeviceSoftwareVersion",
            "baseName": "DeviceSoftwareVersion",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "RegistrationCode",
            "baseName": "RegistrationCode",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "string"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CardReader.attributeTypeMap;
    }
}

/**
* Card reader registration request
*/
export class CardReaderRegistrationRequest {
    /**
    * The reader registration code
    */
    'RegistrationCode': string;
    /**
    * The kiosk device id
    */
    'KioskDeviceId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RegistrationCode",
            "baseName": "RegistrationCode",
            "type": "string"
        },
        {
            "name": "KioskDeviceId",
            "baseName": "KioskDeviceId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardReaderRegistrationRequest.attributeTypeMap;
    }
}

/**
* Defines the cart
*/
export class Cart {
    /**
    * Line items from the cart
    */
    'LineItems'?: Array<LineItem>;
    /**
    * Total cart price
    */
    'CartAmount'?: Price;
    /**
    * Total tip amount
    */
    'Tip'?: Price;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LineItems",
            "baseName": "LineItems",
            "type": "Array<LineItem>"
        },
        {
            "name": "CartAmount",
            "baseName": "CartAmount",
            "type": "Price"
        },
        {
            "name": "Tip",
            "baseName": "Tip",
            "type": "Price"
        }    ];

    static getAttributeTypeMap() {
        return Cart.attributeTypeMap;
    }
}

/**
* CatalogGroup
*/
export class CatalogGroup {
    /**
    * Unique catalog group id
    */
    'CatalogGroupId'?: string;
    /**
    * Unique catalog item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the group is archived
    */
    'IsArchived'?: boolean;
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this product
    */
    'Items'?: Array<CatalogItemReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of group (ModifierGroup, etc)
    */
    'GroupType': CatalogGroup.GroupTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Group name
    */
    'Name': string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<CatalogItemReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CatalogGroup.GroupTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroup.attributeTypeMap;
    }
}

export namespace CatalogGroup {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* 
*/
export class CatalogGroupArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'CatalogGroup'?: CatalogGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogGroup",
            "baseName": "CatalogGroup",
            "type": "CatalogGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupArchivedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'CatalogGroup'?: CatalogGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogGroup",
            "baseName": "CatalogGroup",
            "type": "CatalogGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Reference to an existing {Flipdish.PublicModels.V1.Catalog.Groups.CatalogGroup}
*/
export class CatalogGroupReference {
    /**
    * Details of the referenced {Flipdish.PublicModels.V1.Catalog.Items.CatalogItem}
    */
    'Group'?: CatalogGroup;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Group",
            "baseName": "Group",
            "type": "CatalogGroup"
        },
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupReference.attributeTypeMap;
    }
}

export namespace CatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* 
*/
export class CatalogGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'CatalogGroup'?: CatalogGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogGroup",
            "baseName": "CatalogGroup",
            "type": "CatalogGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Catalog Image
*/
export class CatalogImage {
    /**
    * Unique catalog Item id
    */
    'ImageUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUri",
            "baseName": "ImageUri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogImage.attributeTypeMap;
    }
}

/**
* CatalogItem
*/
export class CatalogItem {
    /**
    * Unique catalog Item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the item is archived
    */
    'IsArchived'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ItemType': CatalogItem.ItemTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Item name
    */
    'Name': string;
    /**
    * Item description
    */
    'Description'?: string;
    /**
    * Item price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * item contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CatalogItem.ItemTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItem.attributeTypeMap;
    }
}

export namespace CatalogItem {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* 
*/
export class CatalogItemArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemArchivedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogItemCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemCreatedEvent.attributeTypeMap;
    }
}

/**
* Catalog Item associated
*/
export class CatalogItemReference {
    /**
    * Details of the referenced {Flipdish.PublicModels.V1.Catalog.Items.CatalogItem}
    */
    'Item'?: CatalogItem;
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ItemType': CatalogItemReference.ItemTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Item",
            "baseName": "Item",
            "type": "CatalogItem"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CatalogItemReference.ItemTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemReference.attributeTypeMap;
    }
}

export namespace CatalogItemReference {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* 
*/
export class CatalogItemUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateCreatedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateCreatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateRenewedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateRenewedEvent.attributeTypeMap;
    }
}

/**
* Change password model
*/
export class ChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordModel.attributeTypeMap;
    }
}

export class Channel {
    /**
    * Channel Id
    */
    'ChannelId'?: number;
    /**
    * Channel TranslationKey
    */
    'TranslationKey'?: string;
    /**
    * Channel Source
    */
    'Source'?: Channel.SourceEnum;
    /**
    * Channel Logo URl
    */
    'LogoUri'?: string;
    /**
    * Channel is Available or not
    */
    'Available'?: boolean;
    /**
    * Channel is Maintained Externally or not
    */
    'MaintainedExternally'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "TranslationKey",
            "baseName": "TranslationKey",
            "type": "string"
        },
        {
            "name": "Source",
            "baseName": "Source",
            "type": "Channel.SourceEnum"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Available",
            "baseName": "Available",
            "type": "boolean"
        },
        {
            "name": "MaintainedExternally",
            "baseName": "MaintainedExternally",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Channel.attributeTypeMap;
    }
}

export namespace Channel {
    export enum SourceEnum {
        Internal = <any> 'Internal',
        External = <any> 'External'
    }
}
/**
* Describes a channel store mapping
*/
export class ChannelStoreMapping {
    'StoreId'?: number;
    'ChannelStoreId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChannelStoreId",
            "baseName": "ChannelStoreId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Chargebacks breakdown
*/
export class ChargebackDetails {
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Chargeback refunded feeds
    */
    'ChargebackRefundedFees'?: number;
    /**
    * Number of chargebacks
    */
    'ChargebacksCount'?: number;
    /**
    * Total amount
    */
    'TotalChargebackCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "ChargebackRefundedFees",
            "baseName": "ChargebackRefundedFees",
            "type": "number"
        },
        {
            "name": "ChargebacksCount",
            "baseName": "ChargebacksCount",
            "type": "number"
        },
        {
            "name": "TotalChargebackCost",
            "baseName": "TotalChargebackCost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDetails.attributeTypeMap;
    }
}

/**
* Configured stores
*/
export class ConfiguredStore {
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Name of store
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfiguredStore.attributeTypeMap;
    }
}

/**
* Contact information for the user
*/
export class Contact {
    /**
    * Email Address
    */
    'Email'?: string;
    /**
    * International format Phone Number
    */
    'PhoneNumber'?: string;
    /**
    * First Name
    */
    'FirstName'?: string;
    /**
    * Last Name
    */
    'LastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "FirstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "LastName",
            "baseName": "LastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Contact.attributeTypeMap;
    }
}

/**
* Coordinates
*/
export class Coordinates {
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

/**
* List of field definitions per country
*/
export class CountryWithAccountFieldsDefinitions {
    /**
    * Country 2-letter ISO code
    */
    'CountryCode'?: string;
    /**
    * Display name of the country
    */
    'DisplayName'?: string;
    /**
    * Country support type (supported-by-stripe-cc, supported-by-flipdish,not-supported)
    */
    'SupportType'?: string;
    /**
    * Bank Account field definitions
    */
    'FieldDefinitions'?: Array<AccountFieldDefinition>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "SupportType",
            "baseName": "SupportType",
            "type": "string"
        },
        {
            "name": "FieldDefinitions",
            "baseName": "FieldDefinitions",
            "type": "Array<AccountFieldDefinition>"
        }    ];

    static getAttributeTypeMap() {
        return CountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Create account model
*/
export class CreateAccountModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;
    /**
    * Referral ID
    */
    'Rid'?: number;
    /**
    * Campaign ID
    */
    'Cid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "Rid",
            "baseName": "Rid",
            "type": "number"
        },
        {
            "name": "Cid",
            "baseName": "Cid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAccountModel.attributeTypeMap;
    }
}

/**
* Create App store app
*/
export class CreateAppStoreApp {
    /**
    * Details
    */
    'Details': string;
    /**
    * Configuration type  <example>External link</example><example>Flipdish hosted</example>
    */
    'ConfigurationType': CreateAppStoreApp.ConfigurationTypeEnum;
    /**
    * Store selector type
    */
    'StoreSelectorType': CreateAppStoreApp.StoreSelectorTypeEnum;
    /**
    * Field groups
    */
    'FieldGroups'?: Array<FieldGroup>;
    /**
    * Setup instructions
    */
    'SetupInstructions'?: string;
    /**
    * External setup link
    */
    'ExternalSetupLink'?: string;
    /**
    * Teammate app access level
    */
    'TeammateAppAccessLevel'?: CreateAppStoreApp.TeammateAppAccessLevelEnum;
    /**
    * Permissions type
    */
    'PermissionsType': CreateAppStoreApp.PermissionsTypeEnum;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Is application enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Categories
    */
    'Categories': Array<CreateAppStoreApp.CategoriesEnum>;
    /**
    * Countries
    */
    'Countries': Array<CreateAppStoreApp.CountriesEnum>;
    /**
    * Developer Name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "CreateAppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "CreateAppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "CreateAppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "CreateAppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<CreateAppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<CreateAppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAppStoreApp.attributeTypeMap;
    }
}

export namespace CreateAppStoreApp {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* Create a Catalog Group
*/
export class CreateCatalogGroup {
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this group
    */
    'Items'?: Array<CreateCatalogItemReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of group (ModifierGroup, etc)
    */
    'GroupType': CreateCatalogGroup.GroupTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Group name
    */
    'Name': string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<CreateCatalogItemReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateCatalogGroup.GroupTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogGroup.attributeTypeMap;
    }
}

export namespace CreateCatalogGroup {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Information to create a reference to a {Flipdish.PublicModels.V1.Catalog.Groups.CatalogGroup}
*/
export class CreateCatalogGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CreateCatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateCatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogGroupReference.attributeTypeMap;
    }
}

export namespace CreateCatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Create a Catalog Item
*/
export class CreateCatalogItem {
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CreateCatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ItemType': CreateCatalogItem.ItemTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Item name
    */
    'Name': string;
    /**
    * Item description
    */
    'Description'?: string;
    /**
    * Item price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * item contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CreateCatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CreateCatalogItem.ItemTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogItem.attributeTypeMap;
    }
}

export namespace CreateCatalogItem {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Information to create a reference to a {Flipdish.PublicModels.V1.Catalog.Items.CatalogItem}
*/
export class CreateCatalogItemReference {
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ItemType': CreateCatalogItemReference.ItemTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CreateCatalogItemReference.ItemTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogItemReference.attributeTypeMap;
    }
}

export namespace CreateCatalogItemReference {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Create menu object
*/
export class CreateFullMenu {
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<CreateFullMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<CreateMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: CreateFullMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: CreateFullMenu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<CreateFullMenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<CreateMenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "CreateFullMenu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "CreateFullMenu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenu.attributeTypeMap;
    }
}

export namespace CreateFullMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Create menu item option set
*/
export class CreateFullMenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<CreateFullMenuItemOptionSetItem>;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<CreateFullMenuItemOptionSetItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSet.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu item option set item
*/
export class CreateFullMenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * if null, next option set is next. if -1, this is the final option set
    */
    'NextMenuItemOptionSetId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "NextMenuItemOptionSetId",
            "baseName": "NextMenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu section
*/
export class CreateFullMenuSection {
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Menu items
    */
    'MenuItems'?: Array<CreateFullMenuSectionItem>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Section Id
    */
    'MenuSectionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<CreateFullMenuSectionItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSection.attributeTypeMap;
    }
}

/**
* Create menu section item
*/
export class CreateFullMenuSectionItem {
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<CreateFullMenuItemOptionSet>;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: CreateFullMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Item Id
    */
    'MenuItemId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<CreateFullMenuItemOptionSet>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "CreateFullMenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSectionItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Information to create a reference to a {System.Text.RegularExpressions.Group}
*/
export class CreateGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CreateGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateGroupReference.attributeTypeMap;
    }
}

export namespace CreateGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Input model for creating a Location
*/
export class CreateLocation {
    /**
    * Location Id
    */
    'LocationId'?: number;
    /**
    * Descriptive LocationArea name
    */
    'LocationName'?: string;
    /**
    * The order that the Location should be displayed on the screen
    */
    'DisplayOrder'?: number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocation.attributeTypeMap;
    }
}

/**
* Input model for creating a LocationArea
*/
export class CreateLocationArea {
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocationArea.attributeTypeMap;
    }
}

/**
* Add CatalogItems to a Menu
*/
export class CreateMenuSectionItemFromCatalogItems {
    /**
    * List of CatalogItems to add to the section
    */
    'MenuCatalogItems': Array<MenuCatalogItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCatalogItems",
            "baseName": "MenuCatalogItems",
            "type": "Array<MenuCatalogItem>"
        }    ];

    static getAttributeTypeMap() {
        return CreateMenuSectionItemFromCatalogItems.attributeTypeMap;
    }
}

/**
* Tax Rates Associated with a Menu
*/
export class CreateMenuTaxRate {
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateMenuTaxRate.attributeTypeMap;
    }
}

/**
* Create metadata
*/
export class CreateMetadata {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateMetadata.attributeTypeMap;
    }
}

/**
* Information to create a {Flipdish.PublicModels.V1.Metafields.MetafieldDefinition}
*/
export class CreateMetafieldDefinition {
    /**
    * Indicates if a definition can be edited or not
    */
    'IsReadOnly'?: boolean;
    /**
    * The Metafield will extend the specified {Flipdish.PublicModels.V1.Metafields.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: CreateMetafieldDefinition.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: CreateMetafieldDefinition.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<CreateMetafieldDefinition.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsReadOnly",
            "baseName": "IsReadOnly",
            "type": "boolean"
        },
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "CreateMetafieldDefinition.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "CreateMetafieldDefinition.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<CreateMetafieldDefinition.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateMetafieldDefinition.attributeTypeMap;
    }
}

export namespace CreateMetafieldDefinition {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Create a Catalog Item
*/
export class CreateProduct {
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CreateGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ProductType': CreateProduct.ProductTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Product name
    */
    'Name': string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CreateGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "CreateProduct.ProductTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateProduct.attributeTypeMap;
    }
}

export namespace CreateProduct {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* 
*/
export class CreateTeammate {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: CreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "CreateTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeammate.attributeTypeMap;
    }
}

export namespace CreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Support = <any> 'Support'
    }
}
/**
* Voucher
*/
export class CreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType'?: CreateVoucher.VoucherTypeEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "CreateVoucher.VoucherTypeEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CreateVoucher.attributeTypeMap;
    }
}

export namespace CreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
}
/**
* Response for the creation of multiple Menu Section Items
*/
export class CreatedMenuSectionItems {
    /**
    * Created Menu Section Items
    */
    'MenuSectionItems'?: Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionItems",
            "baseName": "MenuSectionItems",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return CreatedMenuSectionItems.attributeTypeMap;
    }
}

/**
* Credit note details
*/
export class CreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RemainingCredit",
            "baseName": "RemainingCredit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreditNoteDetails.attributeTypeMap;
    }
}

export class CspReport {
    'Document_uri'?: string;
    'Referrer'?: string;
    'Violated_directive'?: string;
    'Effective_directive'?: string;
    'Original_policy'?: string;
    'Blocked_uri'?: string;
    'Status_code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Document_uri",
            "baseName": "Document-uri",
            "type": "string"
        },
        {
            "name": "Referrer",
            "baseName": "Referrer",
            "type": "string"
        },
        {
            "name": "Violated_directive",
            "baseName": "Violated-directive",
            "type": "string"
        },
        {
            "name": "Effective_directive",
            "baseName": "Effective-directive",
            "type": "string"
        },
        {
            "name": "Original_policy",
            "baseName": "Original-policy",
            "type": "string"
        },
        {
            "name": "Blocked_uri",
            "baseName": "Blocked-uri",
            "type": "string"
        },
        {
            "name": "Status_code",
            "baseName": "Status-code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CspReport.attributeTypeMap;
    }
}

export class CspReportRequest {
    'Csp_report'?: CspReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Csp_report",
            "baseName": "Csp-report",
            "type": "CspReport"
        }    ];

    static getAttributeTypeMap() {
        return CspReportRequest.attributeTypeMap;
    }
}

/**
* A single currency data piece, with no date
*/
export class CurrencyData {
    /**
    * Currency
    */
    'Currency'?: CurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CurrencyData.CurrencyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CurrencyData.attributeTypeMap;
    }
}

export namespace CurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines a customer
*/
export class Customer {
    /**
    * Id of the customer
    */
    'CustomerId'?: number;
    /**
    * Customer registration date
    */
    'RegistrationDate'?: Date;
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "RegistrationDate",
            "baseName": "RegistrationDate",
            "type": "Date"
        },
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

/**
* Customer consent updated
*/
export class CustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

/**
* Customer created event
*/
export class CustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreatedEvent.attributeTypeMap;
    }
}

/**
* Defines the order data required for customer driver tracking
*/
export class CustomerDeliveryTrackingOrder {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Pretified address string in country format
    */
    'Address'?: string;
    /**
    * Delivery Notes
    */
    'DeliveryNotes'?: string;
    /**
    * Phone number of the store
    */
    'StorePhoneNumber'?: string;
    /**
    * App Icon of the store
    */
    'AppIconUrl'?: string;
    /**
    * Order Tracking Code
    */
    'OrderTrackingCode'?: string;
    /**
    * Payment method description i.e Cash/Card/iDeal/Paypal
    */
    'PaymentMethodDescription'?: string;
    /**
    * Last 4 digits of the card if applicable otherwise null
    */
    'LastFourDigits'?: string;
    /**
    * Order lines of the order
    */
    'OrderLines'?: Array<CustomerDeliveryTrackingOrderLine>;
    /**
    * Total amount for the order including tax
    */
    'TotalAmount'?: number;
    /**
    * Currency
    */
    'Currency'?: CustomerDeliveryTrackingOrder.CurrencyEnum;
    /**
    * Customer Location Latitude
    */
    'Latitude'?: number;
    /**
    * Customer Location Longitude
    */
    'Longitude'?: number;
    /**
    * Order placed time
    */
    'Placed'?: Date;
    /**
    * Order requested for
    */
    'RequestedFor'?: Date;
    /**
    * Driver Id
    */
    'DriverId'?: number;
    /**
    * Driver Name
    */
    'DriverName'?: string;
    /**
    * Driver Image
    */
    'DriverImage'?: string;
    /**
    * 
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "DeliveryNotes",
            "baseName": "DeliveryNotes",
            "type": "string"
        },
        {
            "name": "StorePhoneNumber",
            "baseName": "StorePhoneNumber",
            "type": "string"
        },
        {
            "name": "AppIconUrl",
            "baseName": "AppIconUrl",
            "type": "string"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        },
        {
            "name": "PaymentMethodDescription",
            "baseName": "PaymentMethodDescription",
            "type": "string"
        },
        {
            "name": "LastFourDigits",
            "baseName": "LastFourDigits",
            "type": "string"
        },
        {
            "name": "OrderLines",
            "baseName": "OrderLines",
            "type": "Array<CustomerDeliveryTrackingOrderLine>"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CustomerDeliveryTrackingOrder.CurrencyEnum"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Placed",
            "baseName": "Placed",
            "type": "Date"
        },
        {
            "name": "RequestedFor",
            "baseName": "RequestedFor",
            "type": "Date"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "DriverName",
            "baseName": "DriverName",
            "type": "string"
        },
        {
            "name": "DriverImage",
            "baseName": "DriverImage",
            "type": "string"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrder.attributeTypeMap;
    }
}

export namespace CustomerDeliveryTrackingOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines an order line for driver tracking
*/
export class CustomerDeliveryTrackingOrderLine {
    /**
    * Item name from the order
    */
    'ItemName'?: string;
    /**
    * Selected option names
    */
    'SelectedOptions'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "SelectedOptions",
            "baseName": "SelectedOptions",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrderLine.attributeTypeMap;
    }
}

/**
* Customer summary
*/
export class CustomerSummary {
    /**
    * Customer identifier
    */
    'Id'?: number;
    /**
    * Customer name
    */
    'Name'?: string;
    /**
    * Customer email address
    */
    'EmailAddress'?: string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat'?: string;
    /**
    * Customer phone number
    */
    'PhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "PhoneNumberLocalFormat",
            "baseName": "PhoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSummary.attributeTypeMap;
    }
}

/**
* Defines a customer update model
*/
export class CustomerUpdateModel {
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdateModel.attributeTypeMap;
    }
}

/**
* Customer updated event
*/
export class CustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdatedEvent.attributeTypeMap;
    }
}

/**
* SSO Embed URL Information
*/
export class DashboardEmbed {
    /**
    * SSO URL generated by Flipdish to embed Looker dashboard
    */
    'EmbedUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmbedUrl",
            "baseName": "EmbedUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DashboardEmbed.attributeTypeMap;
    }
}

/**
* Delivery location
*/
export class DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Building
    */
    'Building'?: string;
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Town
    */
    'Town'?: string;
    /**
    * Post code
    */
    'PostCode'?: string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions'?: string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Building",
            "baseName": "Building",
            "type": "string"
        },
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Town",
            "baseName": "Town",
            "type": "string"
        },
        {
            "name": "PostCode",
            "baseName": "PostCode",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "PrettyAddressString",
            "baseName": "PrettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryLocation.attributeTypeMap;
    }
}

/**
* Delivery Zone
*/
export class DeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id'?: number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZone.attributeTypeMap;
    }
}

/**
* Delivery Zone Base
*/
export class DeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneBase.attributeTypeMap;
    }
}

/**
* Delivery Zone Created Event
*/
export class DeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneCreatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Deleted Event
*/
export class DeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneDeletedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Updated Event
*/
export class DeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

/**
* Device settings for Hydra
*/
export class DeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Volume",
            "baseName": "Volume",
            "type": "number"
        },
        {
            "name": "FontSize",
            "baseName": "FontSize",
            "type": "number"
        },
        {
            "name": "Brightness",
            "baseName": "Brightness",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceSettings.attributeTypeMap;
    }
}

/**
* Holds the information for the A and CNAME Records of a domain.
*/
export class DnsRecordInformation {
    /**
    * indicates whether the CNAME record is ready or not.
    */
    'IsCNameReady'?: boolean;
    /**
    * indicates whether the A record is ready or not.
    */
    'IsAReady'?: boolean;
    /**
    * indicates whether the API CNAME record is ready or not.
    */
    'IsApiCNameReady'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCNameReady",
            "baseName": "IsCNameReady",
            "type": "boolean"
        },
        {
            "name": "IsAReady",
            "baseName": "IsAReady",
            "type": "boolean"
        },
        {
            "name": "IsApiCNameReady",
            "baseName": "IsApiCNameReady",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DnsRecordInformation.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class DnsVerifiedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DnsVerifiedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class Driver {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * 
    */
    'Stores'?: Array<DriverStore>;
    /**
    * Profile image url
    */
    'ProfileImageUrl'?: string;
    /**
    * Driver Key
    */
    'DriverKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<DriverStore>"
        },
        {
            "name": "ProfileImageUrl",
            "baseName": "ProfileImageUrl",
            "type": "string"
        },
        {
            "name": "DriverKey",
            "baseName": "DriverKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Driver.attributeTypeMap;
    }
}

/**
* 
*/
export class DriverInvitation {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * Driver's name
    */
    'Name'?: string;
    /**
    * Assigned store IDs
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return DriverInvitation.attributeTypeMap;
    }
}

/**
* Driver Login model
*/
export class DriverLoginModel {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Code
    */
    'Code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverLoginModel.attributeTypeMap;
    }
}

/**
* Driver Request Login Pin model
*/
export class DriverRequestLoginPinModel {
    /**
    * Email address
    */
    'PhoneNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverRequestLoginPinModel.attributeTypeMap;
    }
}

/**
* 
*/
export class DriverStore {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Presence
    */
    'Presence'?: DriverStore.PresenceEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Presence",
            "baseName": "Presence",
            "type": "DriverStore.PresenceEnum"
        }    ];

    static getAttributeTypeMap() {
        return DriverStore.attributeTypeMap;
    }
}

export namespace DriverStore {
    export enum PresenceEnum {
        Offline = <any> 'Offline',
        Online = <any> 'Online'
    }
}
export class DynamicFormField {
    'Identifier'?: string;
    'Label'?: string;
    'Placeholder'?: string;
    'Rules'?: DynamicFormRules;
    'Mapping'?: { [key: string]: string; };
    'Modifiers'?: Array<string>;
    'Value'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Identifier",
            "baseName": "Identifier",
            "type": "string"
        },
        {
            "name": "Label",
            "baseName": "Label",
            "type": "string"
        },
        {
            "name": "Placeholder",
            "baseName": "Placeholder",
            "type": "string"
        },
        {
            "name": "Rules",
            "baseName": "Rules",
            "type": "DynamicFormRules"
        },
        {
            "name": "Mapping",
            "baseName": "Mapping",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Modifiers",
            "baseName": "Modifiers",
            "type": "Array<string>"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormField.attributeTypeMap;
    }
}

export class DynamicFormFieldOption {
    'Display'?: string;
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Display",
            "baseName": "Display",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormFieldOption.attributeTypeMap;
    }
}

export class DynamicFormRule {
    'Value'?: any;
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Value",
            "baseName": "Value",
            "type": "any"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormRule.attributeTypeMap;
    }
}

export class DynamicFormRules {
    'MaxLength'?: DynamicFormRule;
    'MinLength'?: DynamicFormRule;
    'Required'?: DynamicFormRule;
    'Pattern'?: DynamicFormRule;
    'Predefined'?: Array<DynamicFormFieldOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxLength",
            "baseName": "MaxLength",
            "type": "DynamicFormRule"
        },
        {
            "name": "MinLength",
            "baseName": "MinLength",
            "type": "DynamicFormRule"
        },
        {
            "name": "Required",
            "baseName": "Required",
            "type": "DynamicFormRule"
        },
        {
            "name": "Pattern",
            "baseName": "Pattern",
            "type": "DynamicFormRule"
        },
        {
            "name": "Predefined",
            "baseName": "Predefined",
            "type": "Array<DynamicFormFieldOption>"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormRules.attributeTypeMap;
    }
}

/**
* Order Terminal Notification
*/
export class EmvNotificationEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Notification Sent
    */
    'Notification'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * TerminalId
    */
    'TerminalId'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Expirey Date
    */
    'ExpDate'?: string;
    /**
    * Card Type
    */
    'CardType'?: string;
    /**
    * Payment Method
    */
    'PaymentMethod'?: string;
    /**
    * Masked Account Number
    */
    'AccountNumber'?: string;
    /**
    * Auth Code
    */
    'AuthCode'?: string;
    /**
    * Payment Provider Message
    */
    'ProviderMessage'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Notification",
            "baseName": "Notification",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ExpDate",
            "baseName": "ExpDate",
            "type": "string"
        },
        {
            "name": "CardType",
            "baseName": "CardType",
            "type": "string"
        },
        {
            "name": "PaymentMethod",
            "baseName": "PaymentMethod",
            "type": "string"
        },
        {
            "name": "AccountNumber",
            "baseName": "AccountNumber",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "ProviderMessage",
            "baseName": "ProviderMessage",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvNotificationEvent.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminal {
    /**
    * Flipdish Identifier of Terminal
    */
    'EmvTerminalId'?: number;
    /**
    * External Identifier of Terminal
    */
    'TerminalId'?: string;
    /**
    * URL at which terminal can be accessed
    */
    'Url'?: string;
    /**
    * TOKEN required to access terminal
    */
    'Token'?: string;
    /**
    * Identifies us to Provider
    */
    'SoftwareHouseId'?: string;
    /**
    * Identifies installer of terminal
    */
    'InstallerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "number"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "SoftwareHouseId",
            "baseName": "SoftwareHouseId",
            "type": "string"
        },
        {
            "name": "InstallerId",
            "baseName": "InstallerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminal.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminalWithAssignments {
    /**
    * Flipdish Internal identifier of the Terminal
    */
    'EmvTerminalId'?: string;
    /**
    * External Identifier of the Terminal
    */
    'TerminalId'?: string;
    /**
    * true if the terminal is assigned to a hydra device (e.g. a kiosk)
    */
    'IsAssignedToHydraDevice'?: boolean;
    /**
    * hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraConfigId'?: number;
    /**
    * external hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraDeviceId'?: string;
    /**
    * hydra device name (null if the terminal is not assigned to any hydra device)
    */
    'HydraName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "string"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "IsAssignedToHydraDevice",
            "baseName": "IsAssignedToHydraDevice",
            "type": "boolean"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "HydraDeviceId",
            "baseName": "HydraDeviceId",
            "type": "string"
        },
        {
            "name": "HydraName",
            "baseName": "HydraName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* 
*/
export class EventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent'?: Array<AppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent'?: Array<AppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent'?: Array<AnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent'?: Array<OrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent'?: Array<OrderDispatchedEvent>;
    /**
    * Order delivery tracking created events
    */
    'OrderCustomerTrackingCreatedEvent'?: Array<OrderCustomerTrackingCreatedEvent>;
    /**
    * Order delivery tracking updated events
    */
    'OrderDeliveryTrackingStatusUpdatedEvent'?: Array<OrderDeliveryTrackingStatusUpdatedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent'?: Array<OrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent'?: Array<OrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent'?: Array<OrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent'?: Array<OrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent'?: Array<OrderTipUpdatedEvent>;
    /**
    * Order Terminal Notification events
    */
    'OrderTerminalNotifications'?: Array<EmvNotificationEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent'?: Array<StoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent'?: Array<StoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent'?: Array<StoreAddressUpdatedEvent>;
    /**
    * Store kiosk setting updated events
    */
    'StoreKioskSettingUpdatedEvent'?: Array<StoreKioskSettingUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent'?: Array<DeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent'?: Array<DeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent'?: Array<DeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent'?: Array<StoreOpeningHoursUpdatedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreMenuAssignedEvent'?: Array<StoreMenuAssignedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent'?: Array<StoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent'?: Array<StoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store archived events
    */
    'StoreArchivedEvent'?: Array<StoreArchivedEvent>;
    /**
    * Store unarchived events
    */
    'StoreUnarchivedEvent'?: Array<StoreUnarchivedEvent>;
    /**
    * Store published events
    */
    'StorePublishedEvent'?: Array<StorePublishedEvent>;
    /**
    * Store unpublished events
    */
    'StoreUnpublishedEvent'?: Array<StoreUnpublishedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent'?: Array<StoreUpdatedEvent>;
    /**
    * Store updated events
    */
    'StorePreOrderConfigUpdatedEvent'?: Array<StorePreOrderConfigUpdatedEvent>;
    /**
    * Store logo created events
    */
    'StoreLogoCreatedEvent'?: Array<StoreLogoCreatedEvent>;
    /**
    * Store logo updated events
    */
    'StoreLogoUpdatedEvent'?: Array<StoreLogoUpdatedEvent>;
    /**
    * Store logo deleted events
    */
    'StoreLogoDeletedEvent'?: Array<StoreLogoDeletedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent'?: Array<MenuCreatedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent'?: Array<MenuUpdatedEvent>;
    /**
    * Menu uploaded events
    */
    'MenuUploadedEvent'?: Array<MenuUploadedEvent>;
    /**
    * Menu bulk events
    */
    'MenuBulkEditEvent'?: Array<MenuBulkEditEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent'?: Array<MenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent'?: Array<MenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent'?: Array<MenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent'?: Array<MenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent'?: Array<MenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent'?: Array<MenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent'?: Array<MenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent'?: Array<MenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent'?: Array<MenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent'?: Array<MenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent'?: Array<MenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent'?: Array<MenuItemOptionSetItemDeletedEvent>;
    /**
    * Menu checkpoint created event
    */
    'MenuCheckpointCreatedEvent'?: Array<MenuCheckpointCreatedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent'?: Array<StoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent'?: Array<StoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent'?: Array<StoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent'?: Array<CustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent'?: Array<CustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent'?: Array<CustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent'?: Array<WebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent'?: Array<WebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent'?: Array<WebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent'?: Array<PrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent'?: Array<PrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent'?: Array<PrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent'?: Array<PrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent'?: Array<PhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent'?: Array<PhoneCallEndedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent'?: Array<LoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent'?: Array<LoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent'?: Array<LoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent'?: Array<RetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent'?: Array<RetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent'?: Array<RetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent'?: Array<SmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent'?: Array<UserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent'?: Array<UserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent'?: Array<UserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent'?: Array<UserDeletedEvent>;
    /**
    * User password created event
    */
    'UserCreatedPasswordEvent'?: Array<UserPasswordCreatedEvent>;
    /**
    * User answered signup questions event
    */
    'UserAnsweredSignupQuestionsEvent'?: Array<UserAnsweredSignupQuestionsEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent'?: Array<VoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent'?: Array<VoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent'?: Array<VoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent'?: Array<TeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent'?: Array<TeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent'?: Array<TeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent'?: Array<TeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent'?: Array<BankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent'?: Array<BankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent'?: Array<BankAccountDeletedEvent>;
    /**
    * Bank account assigned event
    */
    'BankAccountAssignedEvent'?: Array<BankAccountDeletedEvent>;
    /**
    * Hydra assigned event
    */
    'HydraAssignedEvent'?: Array<HydraAssignedEvent>;
    /**
    * Hydra reset requested event
    */
    'HydraRequestResetEvent'?: Array<HydraRequestResetEvent>;
    /**
    * Hydra store assigned event
    */
    'HydraStoreAssignedEvent'?: Array<HydraStoreAssignedEvent>;
    /**
    * Hydra store unassigned
    */
    'HydraStoreUnassignedEvent'?: Array<HydraStoreUnassignedEvent>;
    /**
    * Hydra settings changed event
    */
    'HydraSettingChangedEvent'?: Array<HydraSettingChangedEvent>;
    /**
    * Hydra un-assigned event
    */
    'HydraUnAssignedEvent'?: Array<HydraUnAssignedEvent>;
    /**
    * Hydra connection state change
    */
    'HydraConnectionStatusChangedEvent'?: Array<HydraConnectionStatusChangedEvent>;
    /**
    * Bluetooth Pairing Mode initiated
    */
    'KioskBluetoothPairingModeEvent'?: Array<KioskBluetoothPairingModeEvent>;
    /**
    * Bluetooth Unpairing Mode initiated
    */
    'KioskBluetoothUnpairingModeEvent'?: Array<KioskBluetoothUnpairingModeEvent>;
    /**
    * Bluetooth Terminal Unpaired with Kiosk
    */
    'KioskBluetoothTerminalUnpairedEvent'?: Array<KioskBluetoothTerminalUnpairedEvent>;
    /**
    * Bluetooth Terminal Updated
    */
    'KioskBluetoothTerminalUpdatedEvent'?: Array<KioskBluetoothTerminalUpdatedEvent>;
    /**
    * Trigger bluetooth payment terminal update checker
    */
    'KioskBluetoothTerminalInitiateUpdateCheckEvent'?: Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>;
    /**
    * Bluetooth Terminal Initiate Update
    */
    'KioskBluetoothInstallUpdateInitiateEvent'?: Array<KioskBluetoothInstallUpdateInitiateEvent>;
    /**
    * Bluetooth Terminal Cancel Update Install
    */
    'KioskBluetoothTerminalCancelUpdateEvent'?: Array<KioskBluetoothTerminalCancelUpdateEvent>;
    /**
    * Bluetooth Payment Terminal Firmware Version Status Info
    */
    'KioskBluetoothTerminalFirmwareVersionStatusEvent'?: Array<KioskBluetoothTerminalFirmwareVersionStatusEvent>;
    /**
    * Bluetooth Terminal Update Installation Status
    */
    'KioskBluetoothTerminalInstallationStatusEvent'?: Array<KioskBluetoothTerminalInstallationStatusEvent>;
    /**
    * Push notification scheduled event
    */
    'PushNotificationScheduledEvent'?: Array<PushNotificationScheduledEvent>;
    /**
    * Push notification sent event
    */
    'PushNotificationSentEvent'?: Array<PushNotificationSentEvent>;
    /**
    * Push notification deleted event
    */
    'PushNotificationDeletedEvent'?: Array<PushNotificationDeletedEvent>;
    /**
    * DNS Verified
    */
    'DnsVerifiedEvent'?: Array<DnsVerifiedEvent>;
    /**
    * Certificate created
    */
    'CertificateCreatedEvent'?: Array<CertificateCreatedEvent>;
    /**
    * Certificate renewed
    */
    'CertificateRenewedEvent'?: Array<CertificateRenewedEvent>;
    /**
    * Panacea vanity url updated
    */
    'WebsiteVanityUrlUpdatedEvent'?: Array<WebsiteVanityUrlUpdatedEvent>;
    /**
    * Website updated
    */
    'WebsiteUpdatedEvent'?: Array<WebsiteUpdatedEvent>;
    /**
    * Order capacity config updated
    */
    'OrderCapacityUpdatedEvent'?: Array<OrderCapacityConfigUpdatedEvent>;
    /**
    * External event
    */
    'ExternalStoreEvent'?: Array<ExternalStoreEvent>;
    /**
    * App Store Config Created
    */
    'AppStoreConfigCreatedEvent'?: Array<AppStoreConfigCreatedEvent>;
    /**
    * App Store Config Updated
    */
    'AppStoreConfigUpdatedEvent'?: Array<AppStoreConfigUpdatedEvent>;
    /**
    * App Store Config Deleted
    */
    'AppStoreConfigDeletedEvent'?: Array<AppStoreConfigDeletedEvent>;
    /**
    * Catalog Item Created
    */
    'CatalogItemCreatedEvent'?: Array<CatalogItemCreatedEvent>;
    /**
    * Catalog Item Updated
    */
    'CatalogItemUpdatedEvent'?: Array<CatalogItemUpdatedEvent>;
    /**
    * Catalog Item Archived
    */
    'CatalogItemArchivedEvent'?: Array<CatalogItemArchivedEvent>;
    /**
    * Catalog Group Created
    */
    'CatalogGroupCreatedEvent'?: Array<CatalogGroupCreatedEvent>;
    /**
    * Catalog Group Updated
    */
    'CatalogGroupUpdatedEvent'?: Array<CatalogGroupUpdatedEvent>;
    /**
    * Catalog Group Archived
    */
    'CatalogGroupArchivedEvent'?: Array<CatalogGroupArchivedEvent>;
    /**
    * Store Tip Updated Event
    */
    'StoreTipUpdatedEvent'?: Array<StoreTipUpdatedEvent>;
    /**
    * LocationArea created event
    */
    'LocationAreaCreatedEvent'?: Array<LocationAreaCreatedEvent>;
    /**
    * LocationArea updated event
    */
    'LocationAreaUpdatedEvent'?: Array<LocationAreaUpdatedEvent>;
    /**
    * Location created event
    */
    'LocationCreatedEvent'?: Array<LocationCreatedEvent>;
    /**
    * Location deleted event
    */
    'LocationDeletedEvent'?: Array<LocationDeletedEvent>;
    /**
    * Service Charge Updated Event
    */
    'StoreServiceChargeUpdatedEvent'?: Array<StoreServiceChargeUpdatedEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppCreatedEvent",
            "baseName": "AppCreatedEvent",
            "type": "Array<AppCreatedEvent>"
        },
        {
            "name": "AppUpdatedEvent",
            "baseName": "AppUpdatedEvent",
            "type": "Array<AppUpdatedEvent>"
        },
        {
            "name": "AnalyticsClientEvent",
            "baseName": "AnalyticsClientEvent",
            "type": "Array<AnalyticsClientEvent>"
        },
        {
            "name": "OrderAcceptedEvent",
            "baseName": "OrderAcceptedEvent",
            "type": "Array<OrderAcceptedEvent>"
        },
        {
            "name": "OrderDispatchedEvent",
            "baseName": "OrderDispatchedEvent",
            "type": "Array<OrderDispatchedEvent>"
        },
        {
            "name": "OrderCustomerTrackingCreatedEvent",
            "baseName": "OrderCustomerTrackingCreatedEvent",
            "type": "Array<OrderCustomerTrackingCreatedEvent>"
        },
        {
            "name": "OrderDeliveryTrackingStatusUpdatedEvent",
            "baseName": "OrderDeliveryTrackingStatusUpdatedEvent",
            "type": "Array<OrderDeliveryTrackingStatusUpdatedEvent>"
        },
        {
            "name": "OrderCreatedEvent",
            "baseName": "OrderCreatedEvent",
            "type": "Array<OrderCreatedEvent>"
        },
        {
            "name": "OrderRatingUpdatedEvent",
            "baseName": "OrderRatingUpdatedEvent",
            "type": "Array<OrderRatingUpdatedEvent>"
        },
        {
            "name": "OrderRefundedEvent",
            "baseName": "OrderRefundedEvent",
            "type": "Array<OrderRefundedEvent>"
        },
        {
            "name": "OrderRejectedEvent",
            "baseName": "OrderRejectedEvent",
            "type": "Array<OrderRejectedEvent>"
        },
        {
            "name": "OrderTipUpdatedEvent",
            "baseName": "OrderTipUpdatedEvent",
            "type": "Array<OrderTipUpdatedEvent>"
        },
        {
            "name": "OrderTerminalNotifications",
            "baseName": "OrderTerminalNotifications",
            "type": "Array<EmvNotificationEvent>"
        },
        {
            "name": "StoreCreatedEvent",
            "baseName": "StoreCreatedEvent",
            "type": "Array<StoreCreatedEvent>"
        },
        {
            "name": "StoreDeletedEvent",
            "baseName": "StoreDeletedEvent",
            "type": "Array<StoreDeletedEvent>"
        },
        {
            "name": "StoreAddressUpdatedEvent",
            "baseName": "StoreAddressUpdatedEvent",
            "type": "Array<StoreAddressUpdatedEvent>"
        },
        {
            "name": "StoreKioskSettingUpdatedEvent",
            "baseName": "StoreKioskSettingUpdatedEvent",
            "type": "Array<StoreKioskSettingUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneCreatedEvent",
            "baseName": "DeliveryZoneCreatedEvent",
            "type": "Array<DeliveryZoneCreatedEvent>"
        },
        {
            "name": "DeliveryZoneUpdatedEvent",
            "baseName": "DeliveryZoneUpdatedEvent",
            "type": "Array<DeliveryZoneUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneDeletedEvent",
            "baseName": "DeliveryZoneDeletedEvent",
            "type": "Array<DeliveryZoneDeletedEvent>"
        },
        {
            "name": "StoreOpeningHoursUpdatedEvent",
            "baseName": "StoreOpeningHoursUpdatedEvent",
            "type": "Array<StoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "StoreMenuAssignedEvent",
            "baseName": "StoreMenuAssignedEvent",
            "type": "Array<StoreMenuAssignedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideCreatedEvent",
            "baseName": "StoreBusinessHoursOverrideCreatedEvent",
            "type": "Array<StoreBusinessHoursOverrideCreatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideDeletedEvent",
            "baseName": "StoreBusinessHoursOverrideDeletedEvent",
            "type": "Array<StoreBusinessHoursOverrideDeletedEvent>"
        },
        {
            "name": "StoreArchivedEvent",
            "baseName": "StoreArchivedEvent",
            "type": "Array<StoreArchivedEvent>"
        },
        {
            "name": "StoreUnarchivedEvent",
            "baseName": "StoreUnarchivedEvent",
            "type": "Array<StoreUnarchivedEvent>"
        },
        {
            "name": "StorePublishedEvent",
            "baseName": "StorePublishedEvent",
            "type": "Array<StorePublishedEvent>"
        },
        {
            "name": "StoreUnpublishedEvent",
            "baseName": "StoreUnpublishedEvent",
            "type": "Array<StoreUnpublishedEvent>"
        },
        {
            "name": "StoreUpdatedEvent",
            "baseName": "StoreUpdatedEvent",
            "type": "Array<StoreUpdatedEvent>"
        },
        {
            "name": "StorePreOrderConfigUpdatedEvent",
            "baseName": "StorePreOrderConfigUpdatedEvent",
            "type": "Array<StorePreOrderConfigUpdatedEvent>"
        },
        {
            "name": "StoreLogoCreatedEvent",
            "baseName": "StoreLogoCreatedEvent",
            "type": "Array<StoreLogoCreatedEvent>"
        },
        {
            "name": "StoreLogoUpdatedEvent",
            "baseName": "StoreLogoUpdatedEvent",
            "type": "Array<StoreLogoUpdatedEvent>"
        },
        {
            "name": "StoreLogoDeletedEvent",
            "baseName": "StoreLogoDeletedEvent",
            "type": "Array<StoreLogoDeletedEvent>"
        },
        {
            "name": "MenuCreatedEvent",
            "baseName": "MenuCreatedEvent",
            "type": "Array<MenuCreatedEvent>"
        },
        {
            "name": "MenuUpdatedEvent",
            "baseName": "MenuUpdatedEvent",
            "type": "Array<MenuUpdatedEvent>"
        },
        {
            "name": "MenuUploadedEvent",
            "baseName": "MenuUploadedEvent",
            "type": "Array<MenuUploadedEvent>"
        },
        {
            "name": "MenuBulkEditEvent",
            "baseName": "MenuBulkEditEvent",
            "type": "Array<MenuBulkEditEvent>"
        },
        {
            "name": "MenuSectionCreatedEvent",
            "baseName": "MenuSectionCreatedEvent",
            "type": "Array<MenuSectionCreatedEvent>"
        },
        {
            "name": "MenuSectionUpdatedEvent",
            "baseName": "MenuSectionUpdatedEvent",
            "type": "Array<MenuSectionUpdatedEvent>"
        },
        {
            "name": "MenuSectionDeletedEvent",
            "baseName": "MenuSectionDeletedEvent",
            "type": "Array<MenuSectionDeletedEvent>"
        },
        {
            "name": "MenuSectionItemCreatedEvent",
            "baseName": "MenuSectionItemCreatedEvent",
            "type": "Array<MenuSectionItemCreatedEvent>"
        },
        {
            "name": "MenuSectionItemUpdatedEvent",
            "baseName": "MenuSectionItemUpdatedEvent",
            "type": "Array<MenuSectionItemUpdatedEvent>"
        },
        {
            "name": "MenuSectionItemDeletedEvent",
            "baseName": "MenuSectionItemDeletedEvent",
            "type": "Array<MenuSectionItemDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetCreatedEvent",
            "baseName": "MenuItemOptionSetCreatedEvent",
            "type": "Array<MenuItemOptionSetCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetUpdatedEvent",
            "baseName": "MenuItemOptionSetUpdatedEvent",
            "type": "Array<MenuItemOptionSetUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetDeletedEvent",
            "baseName": "MenuItemOptionSetDeletedEvent",
            "type": "Array<MenuItemOptionSetDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemCreatedEvent",
            "baseName": "MenuItemOptionSetItemCreatedEvent",
            "type": "Array<MenuItemOptionSetItemCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemUpdatedEvent",
            "baseName": "MenuItemOptionSetItemUpdatedEvent",
            "type": "Array<MenuItemOptionSetItemUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemDeletedEvent",
            "baseName": "MenuItemOptionSetItemDeletedEvent",
            "type": "Array<MenuItemOptionSetItemDeletedEvent>"
        },
        {
            "name": "MenuCheckpointCreatedEvent",
            "baseName": "MenuCheckpointCreatedEvent",
            "type": "Array<MenuCheckpointCreatedEvent>"
        },
        {
            "name": "StoreGroupCreatedEvent",
            "baseName": "StoreGroupCreatedEvent",
            "type": "Array<StoreGroupCreatedEvent>"
        },
        {
            "name": "StoreGroupUpdatedEvent",
            "baseName": "StoreGroupUpdatedEvent",
            "type": "Array<StoreGroupUpdatedEvent>"
        },
        {
            "name": "StoreGroupDeletedEvent",
            "baseName": "StoreGroupDeletedEvent",
            "type": "Array<StoreGroupDeletedEvent>"
        },
        {
            "name": "CustomerCreatedEvent",
            "baseName": "CustomerCreatedEvent",
            "type": "Array<CustomerCreatedEvent>"
        },
        {
            "name": "CustomerUpdatedEvent",
            "baseName": "CustomerUpdatedEvent",
            "type": "Array<CustomerUpdatedEvent>"
        },
        {
            "name": "CustomerConsentUpdatedEvent",
            "baseName": "CustomerConsentUpdatedEvent",
            "type": "Array<CustomerConsentUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionCreatedEvent",
            "baseName": "WebhookSubscriptionCreatedEvent",
            "type": "Array<WebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "WebhookSubscriptionUpdatedEvent",
            "baseName": "WebhookSubscriptionUpdatedEvent",
            "type": "Array<WebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionDeletedEvent",
            "baseName": "WebhookSubscriptionDeletedEvent",
            "type": "Array<WebhookSubscriptionDeletedEvent>"
        },
        {
            "name": "PrinterTurnedOnEvent",
            "baseName": "PrinterTurnedOnEvent",
            "type": "Array<PrinterTurnedOnEvent>"
        },
        {
            "name": "PrinterTurnedOffEvent",
            "baseName": "PrinterTurnedOffEvent",
            "type": "Array<PrinterTurnedOffEvent>"
        },
        {
            "name": "PrinterAssignedToStoreEvent",
            "baseName": "PrinterAssignedToStoreEvent",
            "type": "Array<PrinterAssignedToStoreEvent>"
        },
        {
            "name": "PrinterUnassignedFromStoreEvent",
            "baseName": "PrinterUnassignedFromStoreEvent",
            "type": "Array<PrinterUnassignedFromStoreEvent>"
        },
        {
            "name": "PhoneCallStartedEvent",
            "baseName": "PhoneCallStartedEvent",
            "type": "Array<PhoneCallStartedEvent>"
        },
        {
            "name": "PhoneCallEndedEvent",
            "baseName": "PhoneCallEndedEvent",
            "type": "Array<PhoneCallEndedEvent>"
        },
        {
            "name": "LoyaltyCampaignCreatedEvent",
            "baseName": "LoyaltyCampaignCreatedEvent",
            "type": "Array<LoyaltyCampaignCreatedEvent>"
        },
        {
            "name": "LoyaltyCampaignDeletedEvent",
            "baseName": "LoyaltyCampaignDeletedEvent",
            "type": "Array<LoyaltyCampaignDeletedEvent>"
        },
        {
            "name": "LoyaltyCampaignUpdatedEvent",
            "baseName": "LoyaltyCampaignUpdatedEvent",
            "type": "Array<LoyaltyCampaignUpdatedEvent>"
        },
        {
            "name": "RetentionCampaignCreatedEvent",
            "baseName": "RetentionCampaignCreatedEvent",
            "type": "Array<RetentionCampaignCreatedEvent>"
        },
        {
            "name": "RetentionCampaignDeletedEvent",
            "baseName": "RetentionCampaignDeletedEvent",
            "type": "Array<RetentionCampaignDeletedEvent>"
        },
        {
            "name": "RetentionCampaignUpdatedEvent",
            "baseName": "RetentionCampaignUpdatedEvent",
            "type": "Array<RetentionCampaignUpdatedEvent>"
        },
        {
            "name": "SmsReceivedEvent",
            "baseName": "SmsReceivedEvent",
            "type": "Array<SmsReceivedEvent>"
        },
        {
            "name": "UserLoginEvent",
            "baseName": "UserLoginEvent",
            "type": "Array<UserLoginEvent>"
        },
        {
            "name": "UserCreatedEvent",
            "baseName": "UserCreatedEvent",
            "type": "Array<UserCreatedEvent>"
        },
        {
            "name": "UserUpdatedEvent",
            "baseName": "UserUpdatedEvent",
            "type": "Array<UserUpdatedEvent>"
        },
        {
            "name": "UserDeletedEvent",
            "baseName": "UserDeletedEvent",
            "type": "Array<UserDeletedEvent>"
        },
        {
            "name": "UserCreatedPasswordEvent",
            "baseName": "UserCreatedPasswordEvent",
            "type": "Array<UserPasswordCreatedEvent>"
        },
        {
            "name": "UserAnsweredSignupQuestionsEvent",
            "baseName": "UserAnsweredSignupQuestionsEvent",
            "type": "Array<UserAnsweredSignupQuestionsEvent>"
        },
        {
            "name": "VoucherCreatedEvent",
            "baseName": "VoucherCreatedEvent",
            "type": "Array<VoucherCreatedEvent>"
        },
        {
            "name": "VoucherUpdatedEvent",
            "baseName": "VoucherUpdatedEvent",
            "type": "Array<VoucherUpdatedEvent>"
        },
        {
            "name": "VoucherDeletedEvent",
            "baseName": "VoucherDeletedEvent",
            "type": "Array<VoucherDeletedEvent>"
        },
        {
            "name": "TeammateInviteSentEvent",
            "baseName": "TeammateInviteSentEvent",
            "type": "Array<TeammateInviteSentEvent>"
        },
        {
            "name": "TeammateInviteAcceptedEvent",
            "baseName": "TeammateInviteAcceptedEvent",
            "type": "Array<TeammateInviteAcceptedEvent>"
        },
        {
            "name": "TeammateUpdatedEvent",
            "baseName": "TeammateUpdatedEvent",
            "type": "Array<TeammateUpdatedEvent>"
        },
        {
            "name": "TeammateDeletedEvent",
            "baseName": "TeammateDeletedEvent",
            "type": "Array<TeammateDeletedEvent>"
        },
        {
            "name": "BankAccountCreatedEvent",
            "baseName": "BankAccountCreatedEvent",
            "type": "Array<BankAccountCreatedEvent>"
        },
        {
            "name": "BankAccountUpdatedEvent",
            "baseName": "BankAccountUpdatedEvent",
            "type": "Array<BankAccountUpdatedEvent>"
        },
        {
            "name": "BankAccountDeletedEvent",
            "baseName": "BankAccountDeletedEvent",
            "type": "Array<BankAccountDeletedEvent>"
        },
        {
            "name": "BankAccountAssignedEvent",
            "baseName": "BankAccountAssignedEvent",
            "type": "Array<BankAccountDeletedEvent>"
        },
        {
            "name": "HydraAssignedEvent",
            "baseName": "HydraAssignedEvent",
            "type": "Array<HydraAssignedEvent>"
        },
        {
            "name": "HydraRequestResetEvent",
            "baseName": "HydraRequestResetEvent",
            "type": "Array<HydraRequestResetEvent>"
        },
        {
            "name": "HydraStoreAssignedEvent",
            "baseName": "HydraStoreAssignedEvent",
            "type": "Array<HydraStoreAssignedEvent>"
        },
        {
            "name": "HydraStoreUnassignedEvent",
            "baseName": "HydraStoreUnassignedEvent",
            "type": "Array<HydraStoreUnassignedEvent>"
        },
        {
            "name": "HydraSettingChangedEvent",
            "baseName": "HydraSettingChangedEvent",
            "type": "Array<HydraSettingChangedEvent>"
        },
        {
            "name": "HydraUnAssignedEvent",
            "baseName": "HydraUnAssignedEvent",
            "type": "Array<HydraUnAssignedEvent>"
        },
        {
            "name": "HydraConnectionStatusChangedEvent",
            "baseName": "HydraConnectionStatusChangedEvent",
            "type": "Array<HydraConnectionStatusChangedEvent>"
        },
        {
            "name": "KioskBluetoothPairingModeEvent",
            "baseName": "KioskBluetoothPairingModeEvent",
            "type": "Array<KioskBluetoothPairingModeEvent>"
        },
        {
            "name": "KioskBluetoothUnpairingModeEvent",
            "baseName": "KioskBluetoothUnpairingModeEvent",
            "type": "Array<KioskBluetoothUnpairingModeEvent>"
        },
        {
            "name": "KioskBluetoothTerminalUnpairedEvent",
            "baseName": "KioskBluetoothTerminalUnpairedEvent",
            "type": "Array<KioskBluetoothTerminalUnpairedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalUpdatedEvent",
            "baseName": "KioskBluetoothTerminalUpdatedEvent",
            "type": "Array<KioskBluetoothTerminalUpdatedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "baseName": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "type": "Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>"
        },
        {
            "name": "KioskBluetoothInstallUpdateInitiateEvent",
            "baseName": "KioskBluetoothInstallUpdateInitiateEvent",
            "type": "Array<KioskBluetoothInstallUpdateInitiateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalCancelUpdateEvent",
            "baseName": "KioskBluetoothTerminalCancelUpdateEvent",
            "type": "Array<KioskBluetoothTerminalCancelUpdateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalFirmwareVersionStatusEvent",
            "baseName": "KioskBluetoothTerminalFirmwareVersionStatusEvent",
            "type": "Array<KioskBluetoothTerminalFirmwareVersionStatusEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInstallationStatusEvent",
            "baseName": "KioskBluetoothTerminalInstallationStatusEvent",
            "type": "Array<KioskBluetoothTerminalInstallationStatusEvent>"
        },
        {
            "name": "PushNotificationScheduledEvent",
            "baseName": "PushNotificationScheduledEvent",
            "type": "Array<PushNotificationScheduledEvent>"
        },
        {
            "name": "PushNotificationSentEvent",
            "baseName": "PushNotificationSentEvent",
            "type": "Array<PushNotificationSentEvent>"
        },
        {
            "name": "PushNotificationDeletedEvent",
            "baseName": "PushNotificationDeletedEvent",
            "type": "Array<PushNotificationDeletedEvent>"
        },
        {
            "name": "DnsVerifiedEvent",
            "baseName": "DnsVerifiedEvent",
            "type": "Array<DnsVerifiedEvent>"
        },
        {
            "name": "CertificateCreatedEvent",
            "baseName": "CertificateCreatedEvent",
            "type": "Array<CertificateCreatedEvent>"
        },
        {
            "name": "CertificateRenewedEvent",
            "baseName": "CertificateRenewedEvent",
            "type": "Array<CertificateRenewedEvent>"
        },
        {
            "name": "WebsiteVanityUrlUpdatedEvent",
            "baseName": "WebsiteVanityUrlUpdatedEvent",
            "type": "Array<WebsiteVanityUrlUpdatedEvent>"
        },
        {
            "name": "WebsiteUpdatedEvent",
            "baseName": "WebsiteUpdatedEvent",
            "type": "Array<WebsiteUpdatedEvent>"
        },
        {
            "name": "OrderCapacityUpdatedEvent",
            "baseName": "OrderCapacityUpdatedEvent",
            "type": "Array<OrderCapacityConfigUpdatedEvent>"
        },
        {
            "name": "ExternalStoreEvent",
            "baseName": "ExternalStoreEvent",
            "type": "Array<ExternalStoreEvent>"
        },
        {
            "name": "AppStoreConfigCreatedEvent",
            "baseName": "AppStoreConfigCreatedEvent",
            "type": "Array<AppStoreConfigCreatedEvent>"
        },
        {
            "name": "AppStoreConfigUpdatedEvent",
            "baseName": "AppStoreConfigUpdatedEvent",
            "type": "Array<AppStoreConfigUpdatedEvent>"
        },
        {
            "name": "AppStoreConfigDeletedEvent",
            "baseName": "AppStoreConfigDeletedEvent",
            "type": "Array<AppStoreConfigDeletedEvent>"
        },
        {
            "name": "CatalogItemCreatedEvent",
            "baseName": "CatalogItemCreatedEvent",
            "type": "Array<CatalogItemCreatedEvent>"
        },
        {
            "name": "CatalogItemUpdatedEvent",
            "baseName": "CatalogItemUpdatedEvent",
            "type": "Array<CatalogItemUpdatedEvent>"
        },
        {
            "name": "CatalogItemArchivedEvent",
            "baseName": "CatalogItemArchivedEvent",
            "type": "Array<CatalogItemArchivedEvent>"
        },
        {
            "name": "CatalogGroupCreatedEvent",
            "baseName": "CatalogGroupCreatedEvent",
            "type": "Array<CatalogGroupCreatedEvent>"
        },
        {
            "name": "CatalogGroupUpdatedEvent",
            "baseName": "CatalogGroupUpdatedEvent",
            "type": "Array<CatalogGroupUpdatedEvent>"
        },
        {
            "name": "CatalogGroupArchivedEvent",
            "baseName": "CatalogGroupArchivedEvent",
            "type": "Array<CatalogGroupArchivedEvent>"
        },
        {
            "name": "StoreTipUpdatedEvent",
            "baseName": "StoreTipUpdatedEvent",
            "type": "Array<StoreTipUpdatedEvent>"
        },
        {
            "name": "LocationAreaCreatedEvent",
            "baseName": "LocationAreaCreatedEvent",
            "type": "Array<LocationAreaCreatedEvent>"
        },
        {
            "name": "LocationAreaUpdatedEvent",
            "baseName": "LocationAreaUpdatedEvent",
            "type": "Array<LocationAreaUpdatedEvent>"
        },
        {
            "name": "LocationCreatedEvent",
            "baseName": "LocationCreatedEvent",
            "type": "Array<LocationCreatedEvent>"
        },
        {
            "name": "LocationDeletedEvent",
            "baseName": "LocationDeletedEvent",
            "type": "Array<LocationDeletedEvent>"
        },
        {
            "name": "StoreServiceChargeUpdatedEvent",
            "baseName": "StoreServiceChargeUpdatedEvent",
            "type": "Array<StoreServiceChargeUpdatedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return EventSearchResult.attributeTypeMap;
    }
}

/**
* External event
*/
export class ExternalStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which did the action
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFormat'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFields'?: string;
    /**
    * Description
    */
    'DescriptionId'?: string;
    /**
    * Ref (reference field)
    */
    'Ref1'?: string;
    /**
    * Ref2 (reference field)
    */
    'Ref2'?: string;
    /**
    * Ref3 (reference field)
    */
    'Ref3'?: string;
    /**
    * Ref4 (reference field)
    */
    'Ref4'?: string;
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Tags
    */
    'Tags'?: Array<string>;
    /**
    * Field changes list
    */
    'FieldChanges'?: Array<FieldChangeInformation>;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DescriptionFormat",
            "baseName": "DescriptionFormat",
            "type": "string"
        },
        {
            "name": "DescriptionFields",
            "baseName": "DescriptionFields",
            "type": "string"
        },
        {
            "name": "DescriptionId",
            "baseName": "DescriptionId",
            "type": "string"
        },
        {
            "name": "Ref1",
            "baseName": "Ref1",
            "type": "string"
        },
        {
            "name": "Ref2",
            "baseName": "Ref2",
            "type": "string"
        },
        {
            "name": "Ref3",
            "baseName": "Ref3",
            "type": "string"
        },
        {
            "name": "Ref4",
            "baseName": "Ref4",
            "type": "string"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "Array<string>"
        },
        {
            "name": "FieldChanges",
            "baseName": "FieldChanges",
            "type": "Array<FieldChangeInformation>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalStoreEvent.attributeTypeMap;
    }
}

/**
* Fee Summary
*/
export class FeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount'?: number;
    /**
    * Percentage rate
    */
    'PercentageRate'?: number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeAmount",
            "baseName": "FeeAmount",
            "type": "number"
        },
        {
            "name": "PercentageRate",
            "baseName": "PercentageRate",
            "type": "number"
        },
        {
            "name": "PerTransactionFee",
            "baseName": "PerTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeeSummary.attributeTypeMap;
    }
}

/**
* Field
*/
export class Field {
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Key
    */
    'Key': string;
    /**
    * Tooltip
    */
    'Tooltip'?: string;
    /**
    * Position
    */
    'Position': number;
    /**
    * Default Value
    */
    'DefaultValue'?: string;
    /**
    * Valid Values  <remarks>Used typically for dropdown/select</remarks>
    */
    'ValidValues'?: Array<ValidValue>;
    /**
    * Validation Regex
    */
    'ValidationRegex'?: string;
    /**
    * Field Type
    */
    'FieldType': Field.FieldTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Tooltip",
            "baseName": "Tooltip",
            "type": "string"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "DefaultValue",
            "baseName": "DefaultValue",
            "type": "string"
        },
        {
            "name": "ValidValues",
            "baseName": "ValidValues",
            "type": "Array<ValidValue>"
        },
        {
            "name": "ValidationRegex",
            "baseName": "ValidationRegex",
            "type": "string"
        },
        {
            "name": "FieldType",
            "baseName": "FieldType",
            "type": "Field.FieldTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Field.attributeTypeMap;
    }
}

export namespace Field {
    export enum FieldTypeEnum {
        Text = <any> 'Text',
        TextArea = <any> 'TextArea',
        Integer = <any> 'Integer',
        Decimal = <any> 'Decimal',
        Date = <any> 'Date',
        DateTime = <any> 'DateTime',
        Time = <any> 'Time',
        Select = <any> 'Select',
        Boolean = <any> 'Boolean'
    }
}
/**
* Change information for a field
*/
export class FieldChangeInformation {
    /**
    * Path (hierarchy)
    */
    'Path'?: string;
    /**
    * Name of field
    */
    'Name'?: string;
    /**
    * Key (code) of field
    */
    'Key'?: string;
    /**
    * Old value
    */
    'OldValue'?: string;
    /**
    * New value
    */
    'NewValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Path",
            "baseName": "Path",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "OldValue",
            "baseName": "OldValue",
            "type": "string"
        },
        {
            "name": "NewValue",
            "baseName": "NewValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FieldChangeInformation.attributeTypeMap;
    }
}

/**
* Field group
*/
export class FieldGroup {
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Tooltip  <remarks>Displays on text hover</remarks>
    */
    'Tooltip'?: string;
    /**
    * Position  <remarks>Position order in the field groups to display</remarks>
    */
    'Position': number;
    /**
    * Fields
    */
    'Fields'?: Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Tooltip",
            "baseName": "Tooltip",
            "type": "string"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "Fields",
            "baseName": "Fields",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return FieldGroup.attributeTypeMap;
    }
}

/**
* Base Event
*/
export class FlipdishEventBase {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishEventBase.attributeTypeMap;
    }
}

/**
* Fees breakdown
*/
export class FlipdishFeesDetails {
    /**
    * Fees on online sales
    */
    'OnlineSalesFees'?: number;
    /**
    * Fees on cash sales
    */
    'CashSalesFees'?: number;
    /**
    * Total online and cash sales
    */
    'TotalSalesFees'?: number;
    /**
    * Fees on refunds for online sales
    */
    'OnlineSalesRefundedFees'?: number;
    /**
    * Fees on refunds for cash sales
    */
    'CashSalesRefundedFees'?: number;
    /**
    * VAT on sales fees
    */
    'SalesFeesVat'?: number;
    /**
    * Total fees
    */
    'TotalFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesFees",
            "baseName": "OnlineSalesFees",
            "type": "number"
        },
        {
            "name": "CashSalesFees",
            "baseName": "CashSalesFees",
            "type": "number"
        },
        {
            "name": "TotalSalesFees",
            "baseName": "TotalSalesFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedFees",
            "baseName": "OnlineSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedFees",
            "baseName": "CashSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "SalesFeesVat",
            "baseName": "SalesFeesVat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishFeesDetails.attributeTypeMap;
    }
}

/**
* Fulfillment information (required for all orders)
*/
export class FulfillmentInfo {
    /**
    * [Required] Dispatch Type (i.e Pickup / Delivery)
    */
    'DispatchType'?: FulfillmentInfo.DispatchTypeEnum;
    /**
    * [Required] Time the order is requested for
    */
    'RequestedForUtc'?: Date;
    /**
    * Location the order is to be delivered to  [Required] Delivery  [Not Required] Pickup
    */
    'Location'?: Location;
    /**
    * Price of the dispatch, normally 0 for collection and a value for delivery  [Required] Delivery  [Not Required] Pickup
    */
    'DispatchAmount'?: Price;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DispatchType",
            "baseName": "DispatchType",
            "type": "FulfillmentInfo.DispatchTypeEnum"
        },
        {
            "name": "RequestedForUtc",
            "baseName": "RequestedForUtc",
            "type": "Date"
        },
        {
            "name": "Location",
            "baseName": "Location",
            "type": "Location"
        },
        {
            "name": "DispatchAmount",
            "baseName": "DispatchAmount",
            "type": "Price"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentInfo.attributeTypeMap;
    }
}

export namespace FulfillmentInfo {
    export enum DispatchTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Terminal location request
*/
export class GeoPointRequest {
    /**
    * Kiosk device latitude
    */
    'Latitude'?: number;
    /**
    * Kiosk device longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeoPointRequest.attributeTypeMap;
    }
}

export class GoogleAddress {
    'Results'?: Array<GoogleAddressResult>;
    'Result'?: GoogleAddressResult;
    'Status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Results",
            "baseName": "Results",
            "type": "Array<GoogleAddressResult>"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "GoogleAddressResult"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddress.attributeTypeMap;
    }
}

export class GoogleAddressComponent {
    'Long_name'?: string;
    'Short_name'?: string;
    'Types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Long_name",
            "baseName": "Long_name",
            "type": "string"
        },
        {
            "name": "Short_name",
            "baseName": "Short_name",
            "type": "string"
        },
        {
            "name": "Types",
            "baseName": "Types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddressComponent.attributeTypeMap;
    }
}

export class GoogleAddressResult {
    'Address_components'?: Array<GoogleAddressComponent>;
    'Formatted_address'?: string;
    'Geometry'?: GoogleGeometry;
    'Place_id'?: string;
    'Types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Address_components",
            "baseName": "Address_components",
            "type": "Array<GoogleAddressComponent>"
        },
        {
            "name": "Formatted_address",
            "baseName": "Formatted_address",
            "type": "string"
        },
        {
            "name": "Geometry",
            "baseName": "Geometry",
            "type": "GoogleGeometry"
        },
        {
            "name": "Place_id",
            "baseName": "Place_id",
            "type": "string"
        },
        {
            "name": "Types",
            "baseName": "Types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddressResult.attributeTypeMap;
    }
}

export class GoogleCoordinates {
    'Lat'?: number;
    'Lng'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Lat",
            "baseName": "Lat",
            "type": "number"
        },
        {
            "name": "Lng",
            "baseName": "Lng",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GoogleCoordinates.attributeTypeMap;
    }
}

export class GoogleGeometry {
    'Location'?: GoogleLocation;
    'Location_type'?: string;
    'Viewport'?: GoogleViewport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "GoogleLocation"
        },
        {
            "name": "Location_type",
            "baseName": "Location_type",
            "type": "string"
        },
        {
            "name": "Viewport",
            "baseName": "Viewport",
            "type": "GoogleViewport"
        }    ];

    static getAttributeTypeMap() {
        return GoogleGeometry.attributeTypeMap;
    }
}

export class GoogleLocation {
    'Lat'?: number;
    'Lng'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Lat",
            "baseName": "Lat",
            "type": "number"
        },
        {
            "name": "Lng",
            "baseName": "Lng",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GoogleLocation.attributeTypeMap;
    }
}

export class GoogleViewport {
    'Northeast'?: GoogleCoordinates;
    'Southwest'?: GoogleCoordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Northeast",
            "baseName": "Northeast",
            "type": "GoogleCoordinates"
        },
        {
            "name": "Southwest",
            "baseName": "Southwest",
            "type": "GoogleCoordinates"
        }    ];

    static getAttributeTypeMap() {
        return GoogleViewport.attributeTypeMap;
    }
}

/**
* Reference to an existing {Flipdish.PublicModels.V1.Catalog.Groups.CatalogGroup}
*/
export class GroupReference {
    /**
    * Details of the referenced {Flipdish.PublicModels.V1.Catalog.Products.Product}
    */
    'Group'?: CatalogGroup;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': GroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Group",
            "baseName": "Group",
            "type": "CatalogGroup"
        },
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "GroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GroupReference.attributeTypeMap;
    }
}

export namespace GroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Describes coordinates that have a group
*/
export class GroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude'?: number;
    /**
    * Longitude of this coordinate
    */
    'Longitude'?: number;
    /**
    * Count of members in the group
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupedCoordinates.attributeTypeMap;
    }
}

/**
* 
*/
export class HomeAction {
    /**
    * 
    */
    'HomeActionId'?: number;
    /**
    * Type of Action
    */
    'HomeActionType'?: HomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order'?: number;
    /**
    * 
    */
    'TitleKey'?: string;
    /**
    * 
    */
    'ActionKey'?: string;
    /**
    * 
    */
    'DescriptionKey'?: string;
    /**
    * 
    */
    'Action'?: string;
    /**
    * 
    */
    'Dismissible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HomeActionId",
            "baseName": "HomeActionId",
            "type": "number"
        },
        {
            "name": "HomeActionType",
            "baseName": "HomeActionType",
            "type": "HomeAction.HomeActionTypeEnum"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "number"
        },
        {
            "name": "TitleKey",
            "baseName": "TitleKey",
            "type": "string"
        },
        {
            "name": "ActionKey",
            "baseName": "ActionKey",
            "type": "string"
        },
        {
            "name": "DescriptionKey",
            "baseName": "DescriptionKey",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "Dismissible",
            "baseName": "Dismissible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HomeAction.attributeTypeMap;
    }
}

export namespace HomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class HomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalMoneySaved",
            "baseName": "TotalMoneySaved",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return HomeStatistics.attributeTypeMap;
    }
}

/**
* Http Request and Response Log
*/
export class HttpRequestAndResponseLog {
    /**
    * Id of the log
    */
    'Guid'?: string;
    /**
    * Verb associated with the HTTP call.
    */
    'Verb'?: string;
    /**
    * Http request URI.
    */
    'RequestUri'?: string;
    /**
    * Http response status code.
    */
    'StatusCode'?: number;
    /**
    * Http response status line.
    */
    'ReasonPhrase'?: string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds'?: number;
    /**
    * Identity of the caller.
    */
    'UserId'?: string;
    /**
    * Ip address of the caller
    */
    'IpAddress'?: string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime'?: string;
    /**
    * Http request headers.
    */
    'RequestHeaders'?: { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody'?: string;
    /**
    * Http request content-length
    */
    'RequestLength'?: number;
    /**
    * Http response headers.
    */
    'ResponseHeaders'?: { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody'?: string;
    /**
    * Http response content-length
    */
    'ResponseLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Guid",
            "baseName": "Guid",
            "type": "string"
        },
        {
            "name": "Verb",
            "baseName": "Verb",
            "type": "string"
        },
        {
            "name": "RequestUri",
            "baseName": "RequestUri",
            "type": "string"
        },
        {
            "name": "StatusCode",
            "baseName": "StatusCode",
            "type": "number"
        },
        {
            "name": "ReasonPhrase",
            "baseName": "ReasonPhrase",
            "type": "string"
        },
        {
            "name": "CallDurationInMilliseconds",
            "baseName": "CallDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        },
        {
            "name": "CreatedDateTime",
            "baseName": "CreatedDateTime",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "RequestLength",
            "baseName": "RequestLength",
            "type": "number"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "ResponseLength",
            "baseName": "ResponseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Hydra assigned event
*/
export class HydraAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraAssignedEvent.attributeTypeMap;
    }
}

/**
* Hydra configuration
*/
export class HydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': Array<HydraConfig.PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': DeviceSettings;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinimumVersion",
            "baseName": "MinimumVersion",
            "type": "string"
        },
        {
            "name": "PaymentOptions",
            "baseName": "PaymentOptions",
            "type": "Array<HydraConfig.PaymentOptionsEnum>"
        },
        {
            "name": "DeviceSettings",
            "baseName": "DeviceSettings",
            "type": "DeviceSettings"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConfig.attributeTypeMap;
    }
}

export namespace HydraConfig {
    export enum PaymentOptionsEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hydra Connection Status Changed Event
*/
export class HydraConnectionStatusChangedEvent {
    /**
    * Hydra Device Id
    */
    'DeviceId'?: string;
    /**
    * Hydra Device Status
    */
    'HydraDeviceStatus'?: HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum;
    /**
    * Hydra Last Poll Time
    */
    'PollTime'?: Date;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "HydraDeviceStatus",
            "baseName": "HydraDeviceStatus",
            "type": "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum"
        },
        {
            "name": "PollTime",
            "baseName": "PollTime",
            "type": "Date"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConnectionStatusChangedEvent.attributeTypeMap;
    }
}

export namespace HydraConnectionStatusChangedEvent {
    export enum HydraDeviceStatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra device details
*/
export class HydraDeviceDetails {
    /**
    * Flipdish internal device identifier
    */
    'HydraConfigId'?: number;
    /**
    * Device Id or Serial Number
    */
    'DeviceId'?: string;
    /**
    * Type of the device
    */
    'DeviceType'?: HydraDeviceDetails.DeviceTypeEnum;
    /**
    * Status of the device
    */
    'Status'?: HydraDeviceDetails.StatusEnum;
    /**
    * Device Name
    */
    'DeviceName'?: string;
    /**
    * Store Names
    */
    'StoreNames'?: Array<HydraStoreData>;
    /**
    * Last poll time in UTC
    */
    'LastPollUtc'?: Date;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "HydraDeviceDetails.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "HydraDeviceDetails.StatusEnum"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<HydraStoreData>"
        },
        {
            "name": "LastPollUtc",
            "baseName": "LastPollUtc",
            "type": "Date"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraDeviceDetails.attributeTypeMap;
    }
}

export namespace HydraDeviceDetails {
    export enum DeviceTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
    export enum StatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra registration result
*/
export class HydraRegistrationRequest {
    /**
    * Stores to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HydraRegistrationRequest.attributeTypeMap;
    }
}

/**
* Hydra request reset event
*/
export class HydraRequestResetEvent {
    /**
    * User who initiated the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraRequestResetEvent.attributeTypeMap;
    }
}

/**
* Hydra settings changed
*/
export class HydraSettingChangedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Hydra configuration
    */
    'HydraConfig'?: HydraConfig;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraConfig",
            "baseName": "HydraConfig",
            "type": "HydraConfig"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraSettingChangedEvent.attributeTypeMap;
    }
}

/**
* Hydra status
*/
export class HydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreIds'?: Array<number>;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;
    /**
    * Hydra images (covers)
    */
    'Images'?: Array<string>;
    /**
    * Hydra User Type
    */
    'UserType'?: HydraStatus.UserTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "IsRegistered",
            "baseName": "IsRegistered",
            "type": "boolean"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<string>"
        },
        {
            "name": "UserType",
            "baseName": "UserType",
            "type": "HydraStatus.UserTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return HydraStatus.attributeTypeMap;
    }
}

export namespace HydraStatus {
    export enum UserTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
}
/**
* Hydra store\\s assigned event
*/
export class HydraStoreAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to assign hydra to
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreAssignedEvent.attributeTypeMap;
    }
}

/**
* Store Data
*/
export class HydraStoreData {
    /**
    * Id of the store
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreData.attributeTypeMap;
    }
}

/**
* Hydra store\\s unassigned event
*/
export class HydraStoreUnassignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to unassign hydra from
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreUnassignedEvent.attributeTypeMap;
    }
}

/**
* Hydra unassigned event
*/
export class HydraUnAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraUnAssignedEvent.attributeTypeMap;
    }
}

/**
* Index Page
*/
export class IndexPage {
    /**
    * Testimonials
    */
    'Testimonials'?: Array<WebsiteTestimonial>;
    /**
    * Images
    */
    'Images'?: Array<WebsiteImage>;
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Testimonials",
            "baseName": "Testimonials",
            "type": "Array<WebsiteTestimonial>"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<WebsiteImage>"
        },
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPage.attributeTypeMap;
    }
}

/**
* Base of Index Page
*/
export class IndexPageBase {
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPageBase.attributeTypeMap;
    }
}

/**
* Job Address
*/
export class JobAddress {
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country
    */
    'Country'?: string;
    /**
    * Zone
    */
    'Zone'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Country",
            "baseName": "Country",
            "type": "string"
        },
        {
            "name": "Zone",
            "baseName": "Zone",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobAddress.attributeTypeMap;
    }
}

/**
* Job Cancellation
*/
export class JobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy'?: string;
    /**
    * Reason Key
    */
    'ReasonKey'?: string;
    /**
    * Comment
    */
    'Comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanceledBy",
            "baseName": "CanceledBy",
            "type": "string"
        },
        {
            "name": "ReasonKey",
            "baseName": "ReasonKey",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobCancellation.attributeTypeMap;
    }
}

/**
* Job Contact
*/
export class JobContact {
    /**
    * Firstname
    */
    'Firstname'?: string;
    /**
    * Lastname
    */
    'Lastname'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Company
    */
    'Company'?: string;
    /**
    * Company Name
    */
    'CompanyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Firstname",
            "baseName": "Firstname",
            "type": "string"
        },
        {
            "name": "Lastname",
            "baseName": "Lastname",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Company",
            "baseName": "Company",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobContact.attributeTypeMap;
    }
}

/**
* Job Delivery
*/
export class JobDelivery {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Picked At
    */
    'PickedAt'?: string;
    /**
    * Delivered At
    */
    'DeliveredAt'?: string;
    /**
    * Tracking Url
    */
    'TrackingUrl'?: string;
    /**
    * Client Reference
    */
    'ClientReference'?: string;
    /**
    * Package Description
    */
    'PackageDescription'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Pickup
    */
    'Pickup'?: JobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff'?: JobDeliveryDetail;
    /**
    * Eta
    */
    'Eta'?: JobEta;
    /**
    * Cancellation
    */
    'Cancellation'?: JobCancellation;
    /**
    * Proof
    */
    'Proof'?: JobProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PickedAt",
            "baseName": "PickedAt",
            "type": "string"
        },
        {
            "name": "DeliveredAt",
            "baseName": "DeliveredAt",
            "type": "string"
        },
        {
            "name": "TrackingUrl",
            "baseName": "TrackingUrl",
            "type": "string"
        },
        {
            "name": "ClientReference",
            "baseName": "ClientReference",
            "type": "string"
        },
        {
            "name": "PackageDescription",
            "baseName": "PackageDescription",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Eta",
            "baseName": "Eta",
            "type": "JobEta"
        },
        {
            "name": "Cancellation",
            "baseName": "Cancellation",
            "type": "JobCancellation"
        },
        {
            "name": "Proof",
            "baseName": "Proof",
            "type": "JobProof"
        }    ];

    static getAttributeTypeMap() {
        return JobDelivery.attributeTypeMap;
    }
}

/**
* Job Delivery Detail
*/
export class JobDeliveryDetail {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Address
    */
    'Address'?: JobAddress;
    /**
    * Contact
    */
    'Contact'?: JobContact;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "JobAddress"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "JobContact"
        }    ];

    static getAttributeTypeMap() {
        return JobDeliveryDetail.attributeTypeMap;
    }
}

/**
* Job Driver
*/
export class JobDriver {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Display Name
    */
    'DisplayName'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Picture Url
    */
    'PictureUrl'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "PictureUrl",
            "baseName": "PictureUrl",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDriver.attributeTypeMap;
    }
}

/**
* Job Eta
*/
export class JobEta {
    /**
    * Pickup
    */
    'Pickup'?: string;
    /**
    * Dropoff
    */
    'Dropoff'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "string"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobEta.attributeTypeMap;
    }
}

/**
* Job Pricing
*/
export class JobPricing {
    /**
    * Currency
    */
    'Currency'?: string;
    /**
    * Tax Percentage
    */
    'TaxPercentage'?: number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded'?: number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded'?: number;
    /**
    * Tax Amount
    */
    'TaxAmount'?: number;
    /**
    * Invoice Url
    */
    'InvoiceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "TaxPercentage",
            "baseName": "TaxPercentage",
            "type": "number"
        },
        {
            "name": "PriceTaxIncluded",
            "baseName": "PriceTaxIncluded",
            "type": "number"
        },
        {
            "name": "PriceTaxExcluded",
            "baseName": "PriceTaxExcluded",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "InvoiceUrl",
            "baseName": "InvoiceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobPricing.attributeTypeMap;
    }
}

/**
* Job Proof
*/
export class JobProof {
    /**
    * Signature Url
    */
    'SignatureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SignatureUrl",
            "baseName": "SignatureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobProof.attributeTypeMap;
    }
}

/**
* Job Response
*/
export class JobResponse {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Created At
    */
    'CreatedAt'?: Date;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Assignment Code
    */
    'AssignmentCode'?: string;
    /**
    * Pickup At
    */
    'PickupAt'?: string;
    /**
    * Dropoff At
    */
    'DropoffAt'?: string;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Distance
    */
    'Distance'?: number;
    /**
    * Duration
    */
    'Duration'?: number;
    /**
    * Deliveries
    */
    'Deliveries'?: Array<JobDelivery>;
    /**
    * Pricing
    */
    'Pricing'?: JobPricing;
    /**
    * Driver
    */
    'Driver'?: JobDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "CreatedAt",
            "baseName": "CreatedAt",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "AssignmentCode",
            "baseName": "AssignmentCode",
            "type": "string"
        },
        {
            "name": "PickupAt",
            "baseName": "PickupAt",
            "type": "string"
        },
        {
            "name": "DropoffAt",
            "baseName": "DropoffAt",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Distance",
            "baseName": "Distance",
            "type": "number"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "number"
        },
        {
            "name": "Deliveries",
            "baseName": "Deliveries",
            "type": "Array<JobDelivery>"
        },
        {
            "name": "Pricing",
            "baseName": "Pricing",
            "type": "JobPricing"
        },
        {
            "name": "Driver",
            "baseName": "Driver",
            "type": "JobDriver"
        }    ];

    static getAttributeTypeMap() {
        return JobResponse.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth Initiate Install Update Event
*/
export class KioskBluetoothInstallUpdateInitiateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothInstallUpdateInitiateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothInstallUpdateInitiateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Pairing mode initiated
*/
export class KioskBluetoothPairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothPairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothPairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk bluetooth Cancel Update Install Event
*/
export class KioskBluetoothTerminalCancelUpdateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalCancelUpdateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalCancelUpdateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Stripe Terminal Update info received event
*/
export class KioskBluetoothTerminalFirmwareVersionStatusEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Serial Number of the device
    */
    'SerialNumber'?: string;
    /**
    * Indicates if Payment Terminal has Firmware Update
    */
    'HasFirmwareUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Config Update
    */
    'HasConfigUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Key Update
    */
    'HasKeyUpdate'?: boolean;
    /**
    * ETA to install the update
    */
    'UpdateTimeEstimate'?: KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum;
    /**
    * User who made the changes
    */
    'UserEventInfo'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "HasFirmwareUpdate",
            "baseName": "HasFirmwareUpdate",
            "type": "boolean"
        },
        {
            "name": "HasConfigUpdate",
            "baseName": "HasConfigUpdate",
            "type": "boolean"
        },
        {
            "name": "HasKeyUpdate",
            "baseName": "HasKeyUpdate",
            "type": "boolean"
        },
        {
            "name": "UpdateTimeEstimate",
            "baseName": "UpdateTimeEstimate",
            "type": "KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum"
        },
        {
            "name": "UserEventInfo",
            "baseName": "UserEventInfo",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalFirmwareVersionStatusEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalFirmwareVersionStatusEvent {
    export enum UpdateTimeEstimateEnum {
        LessThanOneMinute = <any> 'LessThanOneMinute',
        OneToTwoMinutes = <any> 'OneToTwoMinutes',
        TwoToFiveMinutes = <any> 'TwoToFiveMinutes',
        FiveToFifteenMinutes = <any> 'FiveToFifteenMinutes'
    }
}
/**
* Kiosk bluetooth trigger update check event
*/
export class KioskBluetoothTerminalInitiateUpdateCheckEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInitiateUpdateCheckEvent.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth terminal Installation Status
*/
export class KioskBluetoothTerminalInstallationStatusEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Update Install Progress for Card Reader
    */
    'Progress'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Progress",
            "baseName": "Progress",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInstallationStatusEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalInstallationStatusEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothTerminalUnpairedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalUnpairedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalUnpairedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk bluetooth terminal unpaired
*/
export class KioskBluetoothTerminalUpdatedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * Status of the connected terminal
    */
    'BluetoothTerminalStatus'?: BluetoothTerminalStatus;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalStatus",
            "baseName": "BluetoothTerminalStatus",
            "type": "BluetoothTerminalStatus"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalUpdatedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalUpdatedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothUnpairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothUnpairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothUnpairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Get Cash Payment Settings for a UserId
*/
export class KioskCashPaymentSettings {
    /**
    * false :disable cash on kiosk  true :enable cash on kiosk
    */
    'IsCashVisibleToCustomer'?: boolean;
    /**
    * HydraUser ID of the Device
    */
    'UserId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCashVisibleToCustomer",
            "baseName": "IsCashVisibleToCustomer",
            "type": "boolean"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Model containing result of Kiosk cash setting
*/
export class KioskCashSetting {
    /**
    * Indicated whether cash payment is enabled or not eg: true
    */
    'CashPaymentEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CashPaymentEnabled",
            "baseName": "CashPaymentEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return KioskCashSetting.attributeTypeMap;
    }
}

/**
* Connection parameters to IoT
*/
export class KioskIotConnectionParameters {
    /**
    * The device connection string to the IoT server
    */
    'ConnectionString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ConnectionString",
            "baseName": "ConnectionString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskIotConnectionParameters.attributeTypeMap;
    }
}

/**
* Details of a kiosks store settings
*/
export class KioskStoreSettings {
    /**
    * Kiosks store settings
    */
    'StoreKioskSettings'?: Array<StoreKioskSetting>;
    /**
    * Kiosks timezone
    */
    'Timezone'?: string;
    /**
    * Servers current Utc time
    */
    'CurrentUtcTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreKioskSettings",
            "baseName": "StoreKioskSettings",
            "type": "Array<StoreKioskSetting>"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        },
        {
            "name": "CurrentUtcTime",
            "baseName": "CurrentUtcTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return KioskStoreSettings.attributeTypeMap;
    }
}

/**
* Sorted Language
*/
export class Language {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId'?: string;
    /**
    * Display Order
    */
    'DisplayOrder'?: number;
    /**
    * Language Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Language.attributeTypeMap;
    }
}

/**
* Ligthspeed store settings
*/
export class LightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId'?: string;
    /**
    * Use OAuth for authentication
    */
    'UseOAuth'?: boolean;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection'?: number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation'?: string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment'?: boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId'?: string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId'?: string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId'?: string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType'?: LightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId'?: number;
    /**
    * Collection Table ID to send orders
    */
    'CollectionTableId'?: number;
    /**
    * Delivery Table ID to send orders
    */
    'DeliveryTableId'?: number;
    /**
    * Collection Table IDs to send orders to
    */
    'CollectionTableIds'?: { [key: string]: string; };
    /**
    * Delivery Table IDs to send orders to
    */
    'DeliveryTableIds'?: { [key: string]: string; };
    /**
    * Exclude tax
    */
    'UseTaxInclusivePrices'?: boolean;
    /**
    * WARNING: only use this option if the Liteserver is not synchronizing within max 5 minutes with Lightspeed cloud!
    */
    'SkipStatusCheckAndAcceptOrderAfterSending'?: boolean;
    /**
    * Send Table Number to Table Id
    */
    'SendTableNumberToTableId'?: boolean;
    /**
    * Add ChefNote To Product
    */
    'AddChefNoteToProduct'?: boolean;
    /**
    * The Lightspeed Chef Note Item Id to map
    */
    'ChefNoteItemId'?: string;
    /**
    * The Lightspeed Chef Note Modifier Id to map
    */
    'ChefNoteModifierId'?: string;
    /**
    * The Lightspeed Service Charge Id to map
    */
    'ServiceChargeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CompanyId",
            "baseName": "CompanyId",
            "type": "string"
        },
        {
            "name": "UseOAuth",
            "baseName": "UseOAuth",
            "type": "boolean"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesForCollection",
            "baseName": "EstimatedMinutesForCollection",
            "type": "number"
        },
        {
            "name": "GeographicLocation",
            "baseName": "GeographicLocation",
            "type": "string"
        },
        {
            "name": "Establishment",
            "baseName": "Establishment",
            "type": "boolean"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "string"
        },
        {
            "name": "DeliveryFeeId",
            "baseName": "DeliveryFeeId",
            "type": "string"
        },
        {
            "name": "ProcessingFeeId",
            "baseName": "ProcessingFeeId",
            "type": "string"
        },
        {
            "name": "PriceType",
            "baseName": "PriceType",
            "type": "LightspeedSettings.PriceTypeEnum"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "CollectionTableId",
            "baseName": "CollectionTableId",
            "type": "number"
        },
        {
            "name": "DeliveryTableId",
            "baseName": "DeliveryTableId",
            "type": "number"
        },
        {
            "name": "CollectionTableIds",
            "baseName": "CollectionTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "DeliveryTableIds",
            "baseName": "DeliveryTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UseTaxInclusivePrices",
            "baseName": "UseTaxInclusivePrices",
            "type": "boolean"
        },
        {
            "name": "SkipStatusCheckAndAcceptOrderAfterSending",
            "baseName": "SkipStatusCheckAndAcceptOrderAfterSending",
            "type": "boolean"
        },
        {
            "name": "SendTableNumberToTableId",
            "baseName": "SendTableNumberToTableId",
            "type": "boolean"
        },
        {
            "name": "AddChefNoteToProduct",
            "baseName": "AddChefNoteToProduct",
            "type": "boolean"
        },
        {
            "name": "ChefNoteItemId",
            "baseName": "ChefNoteItemId",
            "type": "string"
        },
        {
            "name": "ChefNoteModifierId",
            "baseName": "ChefNoteModifierId",
            "type": "string"
        },
        {
            "name": "ServiceChargeId",
            "baseName": "ServiceChargeId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LightspeedSettings.attributeTypeMap;
    }
}

export namespace LightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Defines a single line item
*/
export class LineItem {
    /**
    * Flipdish Item Id, if unknown leave 'null'
    */
    'Id'?: number;
    /**
    * Item Name
    */
    'Name'?: string;
    /**
    * Menu section name
    */
    'SectionName'?: string;
    /**
    * External Item Id
    */
    'ExternalId'?: string;
    /**
    * Item Quantity
    */
    'Quantity'?: number;
    /**
    * Item Price
    */
    'Price'?: Price;
    /**
    * Item Notes
    */
    'Notes'?: string;
    /**
    * Item Option
    */
    'Options'?: Array<LineItemOption>;
    /**
    * Other Item Metadata
    */
    'Metadata'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "SectionName",
            "baseName": "SectionName",
            "type": "string"
        },
        {
            "name": "ExternalId",
            "baseName": "ExternalId",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "Price"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "Options",
            "baseName": "Options",
            "type": "Array<LineItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return LineItem.attributeTypeMap;
    }
}

/**
* Defines a single line item option
*/
export class LineItemOption {
    /**
    * Flipdish Item Option Id, if unknown leave 'null'
    */
    'Id'?: number;
    /**
    * External Item Option Id
    */
    'ExternalId'?: string;
    /**
    * External Item Option Name
    */
    'Name'?: string;
    /**
    * External Item Option Price
    */
    'Price'?: Price;
    /**
    * Other Item Metadata
    */
    'Metadata'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "ExternalId",
            "baseName": "ExternalId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "Price"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return LineItemOption.attributeTypeMap;
    }
}

/**
* Represents a localised time zone
*/
export class LocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId'?: string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId'?: string;
    /**
    * Display name in users language
    */
    'DisplayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TimeZoneId",
            "baseName": "TimeZoneId",
            "type": "string"
        },
        {
            "name": "IanaTimeZoneId",
            "baseName": "IanaTimeZoneId",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Location to deliver to
*/
export class Location {
    /**
    * Line 1 of the address
    */
    'AddressLine1'?: string;
    /**
    * Line 2 of the address
    */
    'AddressLine2'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;
    /**
    * Postal / Zip Code
    */
    'PostalCode'?: string;
    /**
    * City to deliver to
    */
    'City'?: string;
    /**
    * Coordinates to deliver to
    */
    'Coordinates'?: Coordinates;
    /**
    * Notes for delivery
    */
    'Notes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressLine1",
            "baseName": "AddressLine1",
            "type": "string"
        },
        {
            "name": "AddressLine2",
            "baseName": "AddressLine2",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        },
        {
            "name": "PostalCode",
            "baseName": "PostalCode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Location.attributeTypeMap;
    }
}

/**
* Represents a LocationArea
*/
export class LocationArea {
    /**
    * Id of the LocationArea
    */
    'LocationAreaId'?: number;
    /**
    * Id of the Store that this LocationArea belongs to
    */
    'StoreId'?: number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationArea.attributeTypeMap;
    }
}

/**
* Event for logging creating of LocationAreas
*/
export class LocationAreaCreatedEvent {
    /**
    * LocationArea Id
    */
    'LocationAreaId'?: string;
    /**
    * LocationArea name
    */
    'LocationAreaName'?: string;
    /**
    * User who created the LocationArea
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaCreatedEvent.attributeTypeMap;
    }
}

/**
* Representation of a Location i.e: (Table, Hotel Room, Car Park, etc )
*/
export class LocationAreaLocation {
    /**
    * Id of the Location
    */
    'LocationId': number;
    /**
    * Name of the Location
    */
    'LocationName': string;
    /**
    * The order that the Location should be displayed on the screen
    */
    'DisplayOrder': number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId'?: string;
    /**
    * Shows if the Location is deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaLocation.attributeTypeMap;
    }
}

/**
* Event for logging updates of LocationAreas
*/
export class LocationAreaUpdatedEvent {
    /**
    * LocationArea Id
    */
    'LocationAreaId'?: string;
    /**
    * LocationArea Name
    */
    'LocationAreaName'?: string;
    /**
    * User who updated the LocationArea
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a LocationArea and its Location list
*/
export class LocationAreaWithLocations {
    /**
    * Id of the LocationArea
    */
    'LocationAreaId': number;
    /**
    * Id of the Store that this LocationArea belongs to
    */
    'StoreId': number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;
    /**
    * List of Locations that belongs to this Location Area
    */
    'Locations'?: Array<LocationAreaLocation>;
    /**
    * Returns if the LocationArea is deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "Locations",
            "baseName": "Locations",
            "type": "Array<LocationAreaLocation>"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Event for logging the creating of Locations
*/
export class LocationCreatedEvent {
    /**
    * Location Location Id
    */
    'LocationId'?: number;
    /**
    * Location LocationName
    */
    'LocationName'?: string;
    /**
    * Location DisplayOrder
    */
    'DisplayOrder'?: number;
    /**
    * Location ExternalLocationId
    */
    'ExternalLocationId'?: string;
    /**
    * Location LocationAreaId
    */
    'LocationAreaId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationCreatedEvent.attributeTypeMap;
    }
}

/**
* Event for logging the deleting of Locations
*/
export class LocationDeletedEvent {
    /**
    * Location Id
    */
    'LocationId'?: number;
    /**
    * Location Name
    */
    'LocationName'?: string;
    /**
    * Location DisplayOrder
    */
    'DisplayOrder'?: number;
    /**
    * Location ExternalLocationId
    */
    'ExternalLocationId'?: string;
    /**
    * LocationAreaId
    */
    'LocationAreaId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationDeletedEvent.attributeTypeMap;
    }
}

/**
* Login model
*/
export class LoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoginModel.attributeTypeMap;
    }
}

/**
* Login with PIN model
*/
export class LoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoginWithPinModel.attributeTypeMap;
    }
}

/**
* Loyalty campaign
*/
export class LoyaltyCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Controls how the loyalty voucher's amount is rounded
    */
    'RoundingStrategy'?: number;
    /**
    * Controls whether we should include orders with loyalty vouchers in the campaign calculation
    */
    'ShouldIncludeOrdersWithLoyaltyVoucher'?: boolean;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "RoundingStrategy",
            "baseName": "RoundingStrategy",
            "type": "number"
        },
        {
            "name": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "baseName": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "type": "boolean"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Loyalty campaign base
*/
export class LoyaltyCampaignBase {
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Controls how the loyalty voucher's amount is rounded
    */
    'RoundingStrategy'?: number;
    /**
    * Controls whether we should include orders with loyalty vouchers in the campaign calculation
    */
    'ShouldIncludeOrdersWithLoyaltyVoucher'?: boolean;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "RoundingStrategy",
            "baseName": "RoundingStrategy",
            "type": "number"
        },
        {
            "name": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "baseName": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "type": "boolean"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignBase.attributeTypeMap;
    }
}

/**
* Loyalty campaign created event
*/
export class LoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign deleted event
*/
export class LoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign updated event
*/
export class LoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Lump discount details
*/
export class LumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DiscountAmount",
            "baseName": "DiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LumpDiscountDetails.attributeTypeMap;
    }
}

/**
* Representation of a Location and its External Mapping
*/
export class MappedLocation {
    /**
    * Id of the Location
    */
    'LocationId': number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MappedLocation.attributeTypeMap;
    }
}

/**
* Represents a masked phone number
*/
export class MaskedPhoneNumber {
    /**
    * Defines if the feature is enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Defines the phone number to call
    */
    'PhoneNumber'?: string;
    /**
    * Defines the code to enter
    */
    'Code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MaskedPhoneNumber.attributeTypeMap;
    }
}

/**
* Menu
*/
export class Menu {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<MenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: Menu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: Menu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<MenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "Menu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "Menu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu base
*/
export class MenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: MenuBase.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: MenuBase.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "MenuBase.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuBase.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuBase.attributeTypeMap;
    }
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu bulk event
*/
export class MenuBulkEditEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Menu Name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Product
    */
    'Item'?: string;
    /**
    * Quantity of product
    */
    'InstanceCount'?: number;
    /**
    * Visibility of the item
    */
    'IsAvailable'?: boolean;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Item",
            "baseName": "Item",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuBulkEditEvent.attributeTypeMap;
    }
}

/**
* Information to add a CatalogItem to a Menu
*/
export class MenuCatalogItem {
    /**
    * Product Id to the product to add as Menu Item
    */
    'CatalogItemId': string;
    /**
    * Small | Medium | Large | HiddenImage  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuCatalogItem.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuCatalogItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuCatalogItem.attributeTypeMap;
    }
}

export namespace MenuCatalogItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu Checkpoint
*/
export class MenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId'?: number;
    /**
    * Time of creation of checkpoint
    */
    'Time'?: Date;
    /**
    * Name of checkpoint
    */
    'Name'?: string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCheckpointId",
            "baseName": "MenuCheckpointId",
            "type": "number"
        },
        {
            "name": "Time",
            "baseName": "Time",
            "type": "Date"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpoint.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuCheckpointCreatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Menu identifier
    */
    'Menu'?: Menu;
    /**
    * Menu Id
    */
    'MenuId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpointCreatedEvent.attributeTypeMap;
    }
}

/**
* Menu created event
*/
export class MenuCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCreatedEvent.attributeTypeMap;
    }
}

/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementEditResponse {
    /**
    * Section name
    */
    'SectionName'?: string;
    /**
    * Item name
    */
    'ItemName'?: string;
    /**
    * Option Set name
    */
    'OptionSetName'?: string;
    /**
    * Element name
    */
    'OptionSetItemName'?: string;
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementEditResponse.MenuElementTypeEnum;
    /**
    * Validation message for menu element issue
    */
    'ValidationCode'?: MenuElementEditResponse.ValidationCodeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SectionName",
            "baseName": "SectionName",
            "type": "string"
        },
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "OptionSetName",
            "baseName": "OptionSetName",
            "type": "string"
        },
        {
            "name": "OptionSetItemName",
            "baseName": "OptionSetItemName",
            "type": "string"
        },
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementEditResponse.MenuElementTypeEnum"
        },
        {
            "name": "ValidationCode",
            "baseName": "ValidationCode",
            "type": "MenuElementEditResponse.ValidationCodeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementEditResponse.attributeTypeMap;
    }
}

export namespace MenuElementEditResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
    export enum ValidationCodeEnum {
        Success = <any> 'Success',
        MinimumCountViolation = <any> 'MinimumCountViolation',
        MasterOptionSetViolation = <any> 'MasterOptionSetViolation',
        IncorrectElementTypeInMenu = <any> 'IncorrectElementTypeInMenu',
        DBFailed = <any> 'DBFailed'
    }
}
/**
* Menu element hide
*/
export class MenuElementHide {
    /**
    * id of the menu item or menu option set item
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementHide.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementHide.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementHide.attributeTypeMap;
    }
}

export namespace MenuElementHide {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListItemResponse {
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementListItemResponse.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementListItemResponse.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListItemResponse.attributeTypeMap;
    }
}

export namespace MenuElementListItemResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListResponse {
    /**
    * Menu Name
    */
    'MenuName'?: string;
    /**
    * Menu Item Name
    */
    'MenuElementName'?: string;
    /**
    * Menu Item Count
    */
    'InstanceCount'?: number;
    /**
    * Menu Item is hide or unhide
    */
    'IsAvailable'?: boolean;
    /**
    * List of Items
    */
    'Items'?: Array<MenuElementListItemResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "MenuElementName",
            "baseName": "MenuElementName",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<MenuElementListItemResponse>"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListResponse.attributeTypeMap;
    }
}

/**
* Menu item option set
*/
export class MenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<MenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Catalog item Id when the OptionSet is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<MenuItemOptionSetItem>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSet.attributeTypeMap;
    }
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item option set item
*/
export class MenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * if null, next option set is next. if -1, this is the final option set
    */
    'NextMenuItemOptionSetId'?: number;
    /**
    * Catalog item Id when the OptionSet is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    'TaxRateId'?: number;
    'TaxValue'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "NextMenuItemOptionSetId",
            "baseName": "NextMenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "TaxValue",
            "baseName": "TaxValue",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class MenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItemBase.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetUpdatedEvent.attributeTypeMap;
    }
}

/**
* Collection of Display Orders for a Menu Object (Menu Section / Menu Items / Option Sets etc)
*/
export class MenuObjectDisplayOrders {
    /**
    * List of Objects and their new Display Orders
    */
    'DisplayOrders'?: Array<ObjectDisplayOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplayOrders",
            "baseName": "DisplayOrders",
            "type": "Array<ObjectDisplayOrder>"
        }    ];

    static getAttributeTypeMap() {
        return MenuObjectDisplayOrders.attributeTypeMap;
    }
}

/**
* Menu section
*/
export class MenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId'?: number;
    /**
    * Menu items
    */
    'MenuItems'?: Array<MenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<MenuSectionItem>"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSection.attributeTypeMap;
    }
}

/**
* Menu section availability
*/
export class MenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes'?: Array<BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailability.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailableTimes",
            "baseName": "AvailableTimes",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailability.attributeTypeMap;
    }
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class MenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailabilityBase.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailabilityBase.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailabilityBase.attributeTypeMap;
    }
}

export namespace MenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class MenuSectionBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Section Id
    */
    'MenuSectionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionBase.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item
*/
export class MenuSectionItem {
    /**
    * Menu item identifier. This ID may change at any time. Use `PublicId` if you need a permanent reference to the item.
    */
    'MenuItemId'?: number;
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice'?: number;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<MenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours'?: Array<BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * TaxRate
    */
    'TaxRateId'?: number;
    /**
    * TaxValue - the tax associated with this item, based on TaxRate / TaxType and Currency (currency determines decimal point precision)
    */
    'TaxValue'?: number;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Catalog item Id when the Item is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ActualPrice",
            "baseName": "ActualPrice",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<MenuItemOptionSet>"
        },
        {
            "name": "DailySpecialHours",
            "baseName": "DailySpecialHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "TaxValue",
            "baseName": "TaxValue",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItem.attributeTypeMap;
    }
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class MenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Item Id
    */
    'MenuItemId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemBase.attributeTypeMap;
    }
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Deleted by user
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Store Names
*/
export class MenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuStoreNames.attributeTypeMap;
    }
}

/**
* Menu Summary
*/
export class MenuSummary {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuSummary.attributeTypeMap;
    }
}

/**
* Tax information for Menu
*/
export class MenuTaxDetails {
    /**
    * Tax Rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Display tax for Menu
    */
    'DisplayTax'?: boolean;
    /**
    * TaxType
    */
    'TaxType'?: MenuTaxDetails.TaxTypeEnum;
    /**
    * ItemIds and TaxIds
    */
    'ItemTaxes'?: { [key: string]: number; };
    /**
    * SetItemIds and TaxIds
    */
    'SetItemTaxes'?: { [key: string]: number; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "DisplayTax",
            "baseName": "DisplayTax",
            "type": "boolean"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuTaxDetails.TaxTypeEnum"
        },
        {
            "name": "ItemTaxes",
            "baseName": "ItemTaxes",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "SetItemTaxes",
            "baseName": "SetItemTaxes",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxDetails.attributeTypeMap;
    }
}

export namespace MenuTaxDetails {
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class MenuTaxRate {
    /**
    * Id of Tax Rate
    */
    'TaxRateId'?: number;
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxRate.attributeTypeMap;
    }
}

/**
* Menu updated event
*/
export class MenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * Menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu uploaded event
*/
export class MenuUploadedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * Quantity of events
    */
    'InstanceEventCount'?: string;
    /**
    * The menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "InstanceEventCount",
            "baseName": "InstanceEventCount",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUploadedEvent.attributeTypeMap;
    }
}

/**
* Metadata
*/
export class Metadata {
    /**
    * Menu entity identifier (eg: MenuItemId, MenuItemOptionSetItemId)
    */
    'MenuEntityId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuEntityId",
            "baseName": "MenuEntityId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metadata.attributeTypeMap;
    }
}

/**
* Metafield
*/
export class Metafield {
    /**
    * Key of the metafield.  Allowed characters: lowercase letters, numbers, hyphen, underscore and dot
    */
    'Key': string;
    /**
    * Value of the metafield.
    */
    'Value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metafield.attributeTypeMap;
    }
}

/**
* Metafield Definition
*/
export class MetafieldDefinition {
    /**
    * Indicates if a definition can be edited or not
    */
    'IsReadOnly'?: boolean;
    /**
    * The Metafield will extend the specified {Flipdish.PublicModels.V1.Metafields.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: MetafieldDefinition.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: MetafieldDefinition.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<MetafieldDefinition.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsReadOnly",
            "baseName": "IsReadOnly",
            "type": "boolean"
        },
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "MetafieldDefinition.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "MetafieldDefinition.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<MetafieldDefinition.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetafieldDefinition.attributeTypeMap;
    }
}

export namespace MetafieldDefinition {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* OwnerEntity Metafield Definition Recommendation
*/
export class MetafieldDefinitionRecommendation {
    /**
    * The Metafield will extend the specified {Flipdish.PublicModels.V1.Metafields.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: MetafieldDefinitionRecommendation.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: MetafieldDefinitionRecommendation.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<MetafieldDefinitionRecommendation.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "MetafieldDefinitionRecommendation.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "MetafieldDefinitionRecommendation.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<MetafieldDefinitionRecommendation.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetafieldDefinitionRecommendation.attributeTypeMap;
    }
}

export namespace MetafieldDefinitionRecommendation {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Oauth client (also knowns as 'app')
*/
export class OAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId'?: string;
    /**
    * OAuth App Name
    */
    'OauthAppName'?: string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * OAuth App logo uri
    */
    'LogoUri'?: string;
    /**
    * Supported OpenID Connect flows
    */
    'Flow'?: OAuthApp.FlowEnum;
    /**
    * ReUse: the refresh token handle will stay the same when refreshing tokens   OneTime: the refresh token handle will be updated when refreshing tokens
    */
    'RefreshTokenUsage'?: OAuthApp.RefreshTokenUsageEnum;
    /**
    * Timem it takes for the IdentityToken to expire in seconds
    */
    'AccessTokenLifetime'?: number;
    /**
    * Maximum lifetime of a refresh token in seconds
    */
    'AbsoluteRefreshTokenLifetime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OauthAppId",
            "baseName": "OauthAppId",
            "type": "string"
        },
        {
            "name": "OauthAppName",
            "baseName": "OauthAppName",
            "type": "string"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Flow",
            "baseName": "Flow",
            "type": "OAuthApp.FlowEnum"
        },
        {
            "name": "RefreshTokenUsage",
            "baseName": "RefreshTokenUsage",
            "type": "OAuthApp.RefreshTokenUsageEnum"
        },
        {
            "name": "AccessTokenLifetime",
            "baseName": "AccessTokenLifetime",
            "type": "number"
        },
        {
            "name": "AbsoluteRefreshTokenLifetime",
            "baseName": "AbsoluteRefreshTokenLifetime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OAuthApp.attributeTypeMap;
    }
}

export namespace OAuthApp {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        Hybrid = <any> 'Hybrid',
        ClientCredentials = <any> 'ClientCredentials'
    }
    export enum RefreshTokenUsageEnum {
        ReUse = <any> 'ReUse',
        OneTimeOnly = <any> 'OneTimeOnly'
    }
}
/**
* OAuth token model
*/
export class OAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key'?: string;
    /**
    * Token type
    */
    'TokenType'?: string;
    /**
    * Oauth subject identifier
    */
    'SubjectId'?: string;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Token expiry
    */
    'Expiry'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "TokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "SubjectId",
            "baseName": "SubjectId",
            "type": "string"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "Expiry",
            "baseName": "Expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OAuthTokenModel.attributeTypeMap;
    }
}

/**
* OAuth client redirect uri
*/
export class OauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id'?: number;
    /**
    * Redirect uri
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* 
*/
export class ObjectDisplayOrder {
    /**
    * ID of object to be ordered
    */
    'Id'?: number;
    /**
    * New Display order
    */
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ObjectDisplayOrder.attributeTypeMap;
    }
}

/**
* 
*/
export class OnboardingItemUpdate {
    /**
    * Completion Status for Onboarding Item
    */
    'Status'?: OnboardingItemUpdate.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OnboardingItemUpdate.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingItemUpdate.attributeTypeMap;
    }
}

export namespace OnboardingItemUpdate {
    export enum StatusEnum {
        Pending = <any> 'Pending',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed'
    }
}
/**
* Order
*/
export class Order {
    /**
    * Store summary
    */
    'Store'?: StoreSummary;
    /**
    * Customer summary
    */
    'Customer'?: CustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher'?: OrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees'?: FeeSummary;
    /**
    * Ordered items
    */
    'OrderItems'?: Array<OrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation'?: DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation'?: Coordinates;
    /**
    * Represents customers masked phone number
    */
    'MaskedPhoneNumber'?: MaskedPhoneNumber;
    /**
    * Represents table service drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * Id of user who rejected order, if available
    */
    'RejectedByUserId'?: number;
    /**
    * ChannelOrderId from external channel
    */
    'ChannelOrderId'?: string;
    /**
    * ChannelOrderDisplayId from external channel
    */
    'ChannelOrderDisplayId'?: string;
    /**
    * Channel where the Order comes from
    */
    'Channel'?: Channel;
    /**
    * Generated receipt code for an order
    */
    'ReceiptCode'?: string;
    /**
    * DropOffLocation selected for this order
    */
    'OrderDropOffLocation'?: OrderDropOffLocation;
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * Delivery type
    */
    'DeliveryType'?: Order.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: Order.PickupLocationTypeEnum;
    /**
    * Pickup location type
    */
    'TableServiceCatagory'?: Order.TableServiceCatagoryEnum;
    /**
    * Tip amount
    */
    'TipAmount'?: number;
    /**
    * Delivery amount
    */
    'DeliveryAmount'?: number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount'?: number;
    /**
    * Service Charge Amount
    */
    'ServiceChargeAmount'?: number;
    /**
    * Service Charge Percentage
    */
    'ServiceChargePercentage'?: number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount'?: number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: Order.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription'?: string;
    /**
    * Order state
    */
    'OrderState'?: Order.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder'?: boolean;
    /**
    * Order placed time
    */
    'PlacedTime'?: Date;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Chef note
    */
    'ChefNote'?: string;
    /**
    * Used app type
    */
    'AppType'?: Order.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating'?: number;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: Order.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason'?: Order.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount'?: number;
    /**
    * Delivery tracking status
    */
    'DeliveryTrackingStatus'?: Order.DeliveryTrackingStatusEnum;
    /**
    * Assigned driver identifier
    */
    'DriverId'?: number;
    /**
    * Total tax applied to order
    */
    'TotalTax'?: number;
    /**
    * Unique, 6 character long alpha numeric code for tracking.
    */
    'OrderTrackingCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Store",
            "baseName": "Store",
            "type": "StoreSummary"
        },
        {
            "name": "Customer",
            "baseName": "Customer",
            "type": "CustomerSummary"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "OrderVoucherSummary"
        },
        {
            "name": "Fees",
            "baseName": "Fees",
            "type": "FeeSummary"
        },
        {
            "name": "OrderItems",
            "baseName": "OrderItems",
            "type": "Array<OrderItem>"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        },
        {
            "name": "CustomerLocation",
            "baseName": "CustomerLocation",
            "type": "Coordinates"
        },
        {
            "name": "MaskedPhoneNumber",
            "baseName": "MaskedPhoneNumber",
            "type": "MaskedPhoneNumber"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "RejectedByUserId",
            "baseName": "RejectedByUserId",
            "type": "number"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelOrderDisplayId",
            "baseName": "ChannelOrderDisplayId",
            "type": "string"
        },
        {
            "name": "Channel",
            "baseName": "Channel",
            "type": "Channel"
        },
        {
            "name": "ReceiptCode",
            "baseName": "ReceiptCode",
            "type": "string"
        },
        {
            "name": "OrderDropOffLocation",
            "baseName": "OrderDropOffLocation",
            "type": "OrderDropOffLocation"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "Order.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "Order.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "Order.TableServiceCatagoryEnum"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "OrderItemsAmount",
            "baseName": "OrderItemsAmount",
            "type": "number"
        },
        {
            "name": "ServiceChargeAmount",
            "baseName": "ServiceChargeAmount",
            "type": "number"
        },
        {
            "name": "ServiceChargePercentage",
            "baseName": "ServiceChargePercentage",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "Order.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentAccountDescription",
            "baseName": "PaymentAccountDescription",
            "type": "string"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "Order.OrderStateEnum"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "PlacedTime",
            "baseName": "PlacedTime",
            "type": "Date"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "Order.AppTypeEnum"
        },
        {
            "name": "UserRating",
            "baseName": "UserRating",
            "type": "number"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "Order.PaymentStatusEnum"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "Order.RejectionReasonEnum"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "DeliveryTrackingStatus",
            "baseName": "DeliveryTrackingStatus",
            "type": "Order.DeliveryTrackingStatusEnum"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "TotalTax",
            "baseName": "TotalTax",
            "type": "number"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
    export enum DeliveryTrackingStatusEnum {
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Accepted Event
*/
export class OrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderAcceptedTime",
            "baseName": "OrderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderAcceptedEvent.attributeTypeMap;
    }
}

/**
* Store's Order Capacity Configuration Updated
*/
export class OrderCapacityConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Id of the store whose order capacity configuration has been updated
    */
    'StoreId'?: number;
    /**
    * User which updated order capacity configuration for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated order capacity configuration
    */
    'OrderCapacityConfig'?: StoreOrderCapacityConfigEditModel;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCapacityConfig",
            "baseName": "OrderCapacityConfig",
            "type": "StoreOrderCapacityConfigEditModel"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCapacityConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Created Event
*/
export class OrderCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCreatedTime",
            "baseName": "OrderCreatedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderCustomerTrackingCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: CustomerDeliveryTrackingOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "CustomerDeliveryTrackingOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCustomerTrackingCreatedEvent.attributeTypeMap;
    }
}

/**
* Order Delivery Status Information
*/
export class OrderDeliveryInformation {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * External Reference Id
    */
    'ExternalReferenceId'?: string;
    /**
    * Tracking Url
    */
    'TrackUrl'?: string;
    /**
    * Delivery Status
    */
    'Status'?: OrderDeliveryInformation.StatusEnum;
    /**
    * Delivery Status Notes
    */
    'DeliveryStatusNotes'?: string;
    /**
    * Error Message
    */
    'ErrorMessage'?: string;
    /**
    * Integration Code
    */
    'IntegrationCode'?: string;
    /**
    * Integration Name
    */
    'IntegrationName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "ExternalReferenceId",
            "baseName": "ExternalReferenceId",
            "type": "string"
        },
        {
            "name": "TrackUrl",
            "baseName": "TrackUrl",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OrderDeliveryInformation.StatusEnum"
        },
        {
            "name": "DeliveryStatusNotes",
            "baseName": "DeliveryStatusNotes",
            "type": "string"
        },
        {
            "name": "ErrorMessage",
            "baseName": "ErrorMessage",
            "type": "string"
        },
        {
            "name": "IntegrationCode",
            "baseName": "IntegrationCode",
            "type": "string"
        },
        {
            "name": "IntegrationName",
            "baseName": "IntegrationName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryInformation.attributeTypeMap;
    }
}

export namespace OrderDeliveryInformation {
    export enum StatusEnum {
        None = <any> 'None',
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Delivery Status Information
*/
export class OrderDeliveryInformationBase {
    /**
    * External Reference Id
    */
    'ExternalReferenceId'?: string;
    /**
    * Tracking Url
    */
    'TrackUrl'?: string;
    /**
    * Delivery Status
    */
    'Status'?: OrderDeliveryInformationBase.StatusEnum;
    /**
    * Delivery Status Notes
    */
    'DeliveryStatusNotes'?: string;
    /**
    * Error Message
    */
    'ErrorMessage'?: string;
    /**
    * Integration Code
    */
    'IntegrationCode'?: string;
    /**
    * Integration Name
    */
    'IntegrationName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ExternalReferenceId",
            "baseName": "ExternalReferenceId",
            "type": "string"
        },
        {
            "name": "TrackUrl",
            "baseName": "TrackUrl",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OrderDeliveryInformationBase.StatusEnum"
        },
        {
            "name": "DeliveryStatusNotes",
            "baseName": "DeliveryStatusNotes",
            "type": "string"
        },
        {
            "name": "ErrorMessage",
            "baseName": "ErrorMessage",
            "type": "string"
        },
        {
            "name": "IntegrationCode",
            "baseName": "IntegrationCode",
            "type": "string"
        },
        {
            "name": "IntegrationName",
            "baseName": "IntegrationName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryInformationBase.attributeTypeMap;
    }
}

export namespace OrderDeliveryInformationBase {
    export enum StatusEnum {
        None = <any> 'None',
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* 
*/
export class OrderDeliveryTrackingStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryTrackingStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Dispatched Event
*/
export class OrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderDispatchedTime",
            "baseName": "OrderDispatchedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDispatchedEvent.attributeTypeMap;
    }
}

export class OrderDropOffLocation {
    'OrderId'?: number;
    'LocationName'?: string;
    'LocationAreaName'?: string;
    'LocationId'?: number;
    'LocationAreaId'?: number;
    'ExternalLocationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDropOffLocation.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderIdAndSequenceNumber {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Sequence for delivery
    */
    'Sequence'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Sequence",
            "baseName": "Sequence",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderIdAndSequenceNumber.attributeTypeMap;
    }
}

/**
* Generic model for ingesting external orders from   3rd parties into the system
*/
export class OrderIngestSubmitOrderRequest {
    /**
    * [Required] Indicated the name from where the request is coming from
    */
    'AppType'?: OrderIngestSubmitOrderRequest.AppTypeEnum;
    /**
    * [Required] Store Id
    */
    'StoreId'?: number;
    /**
    * [Required] Currency Code  These must match three letter codes ISO 4127 http://en.wikipedia.org/wiki/ISO_4217
    */
    'CurrencyCode'?: OrderIngestSubmitOrderRequest.CurrencyCodeEnum;
    /**
    * [Required] Cart of the user
    */
    'Cart'?: Cart;
    /**
    * [Required] Relevant fulfillment Information
    */
    'FulfillmentInfo'?: FulfillmentInfo;
    /**
    * [Required] Order ID in the external System
    */
    'ChannelOrderId'?: string;
    /**
    * [Optional] Public Order ID in the external System
    */
    'ChannelPublicOrderId'?: string;
    /**
    * Date the order was placed at in UTC  [Required]
    */
    'OrderDateUtc'?: Date;
    /**
    * Payment Information  [Required]
    */
    'PaymentInfo'?: PaymentInfo;
    /**
    * Contact Information  [Required]
    */
    'Contact'?: Contact;
    /**
    * Tip amount
    */
    'TipAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "OrderIngestSubmitOrderRequest.AppTypeEnum"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "OrderIngestSubmitOrderRequest.CurrencyCodeEnum"
        },
        {
            "name": "Cart",
            "baseName": "Cart",
            "type": "Cart"
        },
        {
            "name": "FulfillmentInfo",
            "baseName": "FulfillmentInfo",
            "type": "FulfillmentInfo"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelPublicOrderId",
            "baseName": "ChannelPublicOrderId",
            "type": "string"
        },
        {
            "name": "OrderDateUtc",
            "baseName": "OrderDateUtc",
            "type": "Date"
        },
        {
            "name": "PaymentInfo",
            "baseName": "PaymentInfo",
            "type": "PaymentInfo"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "Contact"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderIngestSubmitOrderRequest.attributeTypeMap;
    }
}

export namespace OrderIngestSubmitOrderRequest {
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
export class OrderIngestSubmitOrderResponse {
    'OrderId'?: number;
    'ReceiptUrl'?: string;
    'CurrencyCode'?: OrderIngestSubmitOrderResponse.CurrencyCodeEnum;
    'TotalPrice'?: Price;
    'DeliveryFee'?: Price;
    'EstimatedDeliveryTime'?: Date;
    'ChannelOrderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "ReceiptUrl",
            "baseName": "ReceiptUrl",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "OrderIngestSubmitOrderResponse.CurrencyCodeEnum"
        },
        {
            "name": "TotalPrice",
            "baseName": "TotalPrice",
            "type": "Price"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "Price"
        },
        {
            "name": "EstimatedDeliveryTime",
            "baseName": "EstimatedDeliveryTime",
            "type": "Date"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderIngestSubmitOrderResponse.attributeTypeMap;
    }
}

export namespace OrderIngestSubmitOrderResponse {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Order item
*/
export class OrderItem {
    /**
    * Option list
    */
    'OrderItemOptions'?: Array<OrderItemOption>;
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId'?: string;
    /**
    * Menu section name
    */
    'MenuSectionName'?: string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems'?: number;
    /**
    * Menu item identifier
    */
    'MenuItemId'?: number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderItemOptions",
            "baseName": "OrderItemOptions",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "MenuItemDisplayOrder",
            "baseName": "MenuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

/**
* Order item option
*/
export class OrderItemOption {
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId'?: string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId'?: number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder'?: number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemOptionPublicId",
            "baseName": "MenuItemOptionPublicId",
            "type": "string"
        },
        {
            "name": "MenuItemOptionId",
            "baseName": "MenuItemOptionId",
            "type": "number"
        },
        {
            "name": "IsMasterOptionSetItem",
            "baseName": "IsMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "MenuItemOptionDisplayOrder",
            "baseName": "MenuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetDisplayOrder",
            "baseName": "MenuItemOptionSetDisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

/**
* Order Payment Information
*/
export class OrderPaymentInformation {
    /**
    * ID of the Order
    */
    'OrderId'?: number;
    /**
    * Signifies if the payment is refundable
    */
    'PaymentRefundable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PaymentRefundable",
            "baseName": "PaymentRefundable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Order Rating Update Event
*/
export class OrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * New User Rating
    */
    'Rating'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Rating",
            "baseName": "Rating",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRatingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Refunded Event
*/
export class OrderRefundedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The amount refunded
    */
    'RefundedAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRefundedEvent.attributeTypeMap;
    }
}

/**
* Order Rejected Event
*/
export class OrderRejectedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime'?: Date;
    /**
    * Reason for Rejection
    */
    'Reason'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderRejectedTime",
            "baseName": "OrderRejectedTime",
            "type": "Date"
        },
        {
            "name": "Reason",
            "baseName": "Reason",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRejectedEvent.attributeTypeMap;
    }
}

/**
* Order summary
*/
export class OrderSummary {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: OrderSummary.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: OrderSummary.PickupLocationTypeEnum;
    /**
    * Table service category
    */
    'TableServiceCatagory'?: OrderSummary.TableServiceCatagoryEnum;
    /**
    * Order state
    */
    'OrderState'?: OrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone'?: string;
    /**
    * Name of the customer
    */
    'CustomerName'?: string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber'?: string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Payment Account
    */
    'PaymentAccountType'?: OrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: OrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency'?: OrderSummary.CurrencyEnum;
    /**
    * Type of app end user is on
    */
    'AppType'?: OrderSummary.AppTypeEnum;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * id of the collection/drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Channel where the Order comes from
    */
    'Channel'?: Channel;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * ChannelOrderId from external channel
    */
    'ChannelOrderId'?: string;
    /**
    * ChannelOrderDisplayId from external channel
    */
    'ChannelOrderDisplayId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "OrderSummary.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "OrderSummary.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "OrderSummary.TableServiceCatagoryEnum"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "OrderSummary.OrderStateEnum"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreIanaTimeZone",
            "baseName": "StoreIanaTimeZone",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "CustomerPhoneNumber",
            "baseName": "CustomerPhoneNumber",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "OrderSummary.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "OrderSummary.PaymentStatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "OrderSummary.CurrencyEnum"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "OrderSummary.AppTypeEnum"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "Channel",
            "baseName": "Channel",
            "type": "Channel"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelOrderDisplayId",
            "baseName": "ChannelOrderDisplayId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderSummary.attributeTypeMap;
    }
}

export namespace OrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
}
/**
* Order Tip Update Event
*/
export class OrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Tip Amount
    */
    'TipAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher summary
*/
export class OrderVoucherSummary {
    /**
    * Voucher name
    */
    'Name'?: string;
    /**
    * Voucher description
    */
    'Description'?: string;
    /**
    * Voucher code
    */
    'Code'?: string;
    /**
    * Voucher amount
    */
    'Amount'?: number;
    /**
    * Voucher type
    */
    'Type'?: OrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType'?: OrderVoucherSummary.SubTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "OrderVoucherSummary.TypeEnum"
        },
        {
            "name": "SubType",
            "baseName": "SubType",
            "type": "OrderVoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderVoucherSummary.attributeTypeMap;
    }
}

export namespace OrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Breakdown of other charges
*/
export class OtherChargesDetails {
    /**
    * Total amount of other charges
    */
    'TotalOtherCharges'?: number;
    /**
    * Number of other charges
    */
    'ChargesCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalOtherCharges",
            "baseName": "TotalOtherCharges",
            "type": "number"
        },
        {
            "name": "ChargesCount",
            "baseName": "ChargesCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherChargesDetails.attributeTypeMap;
    }
}

/**
* OwnerEntity information to configure its {Flipdish.PublicModels.V1.Metafields.MetafieldDefinition}s
*/
export class OwnerEntityConfiguration {
    /**
    * Owner Entity
    */
    'OwnerEntity'?: OwnerEntityConfiguration.OwnerEntityEnum;
    /**
    * 
    */
    'AllowedBehaviors'?: Array<OwnerEntityConfiguration.AllowedBehaviorsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "OwnerEntityConfiguration.OwnerEntityEnum"
        },
        {
            "name": "AllowedBehaviors",
            "baseName": "AllowedBehaviors",
            "type": "Array<OwnerEntityConfiguration.AllowedBehaviorsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return OwnerEntityConfiguration.attributeTypeMap;
    }
}

export namespace OwnerEntityConfiguration {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum AllowedBehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Owner Entity Configurations
*/
export class OwnerEntityConfigurations {
    /**
    * Owner Entity Configuration
    */
    'Configurations'?: Array<OwnerEntityConfiguration>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Configurations",
            "baseName": "Configurations",
            "type": "Array<OwnerEntityConfiguration>"
        }    ];

    static getAttributeTypeMap() {
        return OwnerEntityConfigurations.attributeTypeMap;
    }
}

/**
* Password reset model
*/
export class PasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "PasswordConfirmation",
            "baseName": "PasswordConfirmation",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetModel.attributeTypeMap;
    }
}

/**
* Payment information
*/
export class PaymentInfo {
    /**
    * Defines if the order was paid
    */
    'Paid'?: boolean;
    /**
    * Payment Description
    */
    'PaymentType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Paid",
            "baseName": "Paid",
            "type": "boolean"
        },
        {
            "name": "PaymentType",
            "baseName": "PaymentType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInfo.attributeTypeMap;
    }
}

/**
* Represents stripe PaymentIntent
*/
export class PaymentIntent {
    /**
    * Id of payment intent
    */
    'Id'?: string;
    /**
    * An arbitrary string attached to the object. Often useful for displaying to users.
    */
    'Description'?: string;
    /**
    * Three-letter <a href=\"https://www.iso.org/iso-4217-currency-codes.html\">ISO currency  code</a>, in lowercase. Must be a <a href=\"https://stripe.com/docs/currencies\">supported  currency</a>.
    */
    'Currency'?: string;
    /**
    * Status of this PaymentIntent, one of requires_payment_method,  requires_confirmation, requires_action, processing,  requires_capture, canceled, or succeeded. Read more about each  PaymentIntent <a href=\"https://stripe.com/docs/payments/intents#intent-statuses\">status</a>.  One of: canceled, processing, requires_action,  requires_capture, requires_confirmation, requires_payment_method,  or succeeded.
    */
    'Status'?: string;
    /**
    * Time at which the object was created. Measured in seconds since the Unix epoch.
    */
    'Created'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Created",
            "baseName": "Created",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PaymentIntent.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal
*/
export class PaymentTerminalDetails {
    /**
    * Terminal Id (tid)
    */
    'TerminalId'?: string;
    /**
    * Status of Terminal
    */
    'Status'?: string;
    /**
    * Currency configured on the terminal
    */
    'Currency'?: string;
    /**
    * Location to Device
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal Transaction
*/
export class PaymentTerminalTransactionDetails {
    /**
    * Card Type
    */
    'CardSchemeName'?: string;
    /**
    * Expirey Date on Card
    */
    'DateOfExpiry'?: string;
    /**
    * AuthCode
    */
    'AuthCode'?: string;
    /**
    * State of Request, \"PENDING\" is not yet completed
    */
    'TransactionResult'?: string;
    /**
    * Masked PAN
    */
    'PrimaryAccountNumber'?: string;
    /**
    * Type of Verification.
    */
    'CardholderVerificationMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CardSchemeName",
            "baseName": "CardSchemeName",
            "type": "string"
        },
        {
            "name": "DateOfExpiry",
            "baseName": "DateOfExpiry",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "TransactionResult",
            "baseName": "TransactionResult",
            "type": "string"
        },
        {
            "name": "PrimaryAccountNumber",
            "baseName": "PrimaryAccountNumber",
            "type": "string"
        },
        {
            "name": "CardholderVerificationMethod",
            "baseName": "CardholderVerificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payout.
*/
export class Payout {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'PayeeBankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: Payout.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    /**
    * Destination bank name
    */
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Type of payout source
    */
    'PayoutType'?: Payout.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: Payout.CurrencyEnum;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;
    /**
    * Payout online sales amount
    */
    'OnlineSalesAmount'?: number;
    /**
    * Payout online sales delivery charges
    */
    'OnlineSalesDeliveryCharges'?: number;
    /**
    * Payout online sales tips
    */
    'OnlineSalesTips'?: number;
    /**
    * Payout online sales service charges
    */
    'OnlineSalesServiceCharges'?: number;
    /**
    * Payout online sales refunded fees
    */
    'OnlineSalesRefundedFees'?: number;
    /**
    * Payout online sales fees
    */
    'OnlineSalesFees'?: number;
    /**
    * Payout online sales refunded amount
    */
    'OnlineSalesRefundedAmount'?: number;
    /**
    * Payout online sales tax
    */
    'OnlineSalesTax'?: number;
    /**
    * Payout total online revenue
    */
    'TotalOnlineRevenue'?: number;
    /**
    * Payout cash sales fees
    */
    'CashSalesFees'?: number;
    /**
    * Payout cash sales refunded fees
    */
    'CashSalesRefundedFees'?: number;
    /**
    * Payout cash fees charged to customer
    */
    'CustomerCashFees'?: number;
    /**
    * Payout sales fees vat
    */
    'SalesFeesVat'?: number;
    /**
    * Payout total fees
    */
    'TotalFees'?: number;
    /**
    * Payout total online revenue adjustments
    */
    'TotalOnlineRevenueAdjustments'?: number;
    /**
    * Payout chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Payout chargeback refunded fees
    */
    'ChargebackRefundedFees'?: number;
    /**
    * Payout chargebacks total cost
    */
    'TotalChargebackCost'?: number;
    /**
    * Payout other charges total
    */
    'TotalOtherCharges'?: number;
    /**
    * Payout opening balance
    */
    'OpeningBalance'?: number;
    /**
    * Payout closing balance
    */
    'ClosingBalance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "PayeeBankAccountId",
            "baseName": "PayeeBankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "Payout.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "Payout.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Payout.CurrencyEnum"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        },
        {
            "name": "OnlineSalesAmount",
            "baseName": "OnlineSalesAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesDeliveryCharges",
            "baseName": "OnlineSalesDeliveryCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesTips",
            "baseName": "OnlineSalesTips",
            "type": "number"
        },
        {
            "name": "OnlineSalesServiceCharges",
            "baseName": "OnlineSalesServiceCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedFees",
            "baseName": "OnlineSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesFees",
            "baseName": "OnlineSalesFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedAmount",
            "baseName": "OnlineSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesTax",
            "baseName": "OnlineSalesTax",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenue",
            "baseName": "TotalOnlineRevenue",
            "type": "number"
        },
        {
            "name": "CashSalesFees",
            "baseName": "CashSalesFees",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedFees",
            "baseName": "CashSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "CustomerCashFees",
            "baseName": "CustomerCashFees",
            "type": "number"
        },
        {
            "name": "SalesFeesVat",
            "baseName": "SalesFeesVat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenueAdjustments",
            "baseName": "TotalOnlineRevenueAdjustments",
            "type": "number"
        },
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "ChargebackRefundedFees",
            "baseName": "ChargebackRefundedFees",
            "type": "number"
        },
        {
            "name": "TotalChargebackCost",
            "baseName": "TotalChargebackCost",
            "type": "number"
        },
        {
            "name": "TotalOtherCharges",
            "baseName": "TotalOtherCharges",
            "type": "number"
        },
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Payout.attributeTypeMap;
    }
}

export namespace Payout {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a chargeback related to a payout
*/
export class PayoutChargeback {
    /**
    * The id of the order the chargeback was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutChargeback.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutChargeback.OrderTypeEnum;
    /**
    * The date the chargeback was done
    */
    'ChargebackDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Amount of refunded fees
    */
    'RefundedFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutChargeback.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutChargeback.OrderTypeEnum"
        },
        {
            "name": "ChargebackDate",
            "baseName": "ChargebackDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutChargeback.attributeTypeMap;
    }
}

export namespace PayoutChargeback {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Holds the information for a whitelabel payout with details broken down by Store
*/
export class PayoutDetail {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'BankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutDetail.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    /**
    * Destination bank name
    */
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Type of payout source
    */
    'PayoutType'?: PayoutDetail.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: PayoutDetail.CurrencyEnum;
    /**
    * Payout information broken down by Store
    */
    'PayoutStores'?: Array<PayoutStore>;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "BankAccountId",
            "baseName": "BankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutDetail.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "PayoutDetail.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutDetail.CurrencyEnum"
        },
        {
            "name": "PayoutStores",
            "baseName": "PayoutStores",
            "type": "Array<PayoutStore>"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PayoutDetail.attributeTypeMap;
    }
}

export namespace PayoutDetail {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for an order related to a payout
*/
export class PayoutOrder {
    /**
    * The id of the order
    */
    'OrderId'?: number;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutOrder.OrderTypeEnum;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutOrder.OrderCurrencyEnum;
    /**
    * Order sales amount
    */
    'Sales'?: number;
    /**
    * Order sales tax amount
    */
    'SalesTax'?: number;
    /**
    * Order delivery charges
    */
    'DeliveryCharges'?: number;
    /**
    * Order tips amount
    */
    'Tips'?: number;
    /**
    * Order voucher amount
    */
    'Voucher'?: number;
    /**
    * Order flat fee amount excluding VAT
    */
    'FlatFeeExcludingVat'?: number;
    'FlatFeeExcludingVAT'?: number;
    /**
    * Order percentage fee excluding VAT
    */
    'PercentageFeeExcludingVat'?: number;
    'PercentageFeeExcludingVAT'?: number;
    /**
    * Order VAT amount
    */
    'Vat'?: number;
    /**
    * Total order fees amount
    */
    'TotalFees'?: number;
    /**
    * Cash fee charged to customer
    */
    'CashFeeChargedToCustomer'?: number;
    /**
    * Order net sales amount
    */
    'NetSales'?: number;
    /**
    * Store id
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutOrder.OrderTypeEnum"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutOrder.OrderCurrencyEnum"
        },
        {
            "name": "Sales",
            "baseName": "Sales",
            "type": "number"
        },
        {
            "name": "SalesTax",
            "baseName": "SalesTax",
            "type": "number"
        },
        {
            "name": "DeliveryCharges",
            "baseName": "DeliveryCharges",
            "type": "number"
        },
        {
            "name": "Tips",
            "baseName": "Tips",
            "type": "number"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVat",
            "baseName": "FlatFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVAT",
            "baseName": "FlatFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVat",
            "baseName": "PercentageFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVAT",
            "baseName": "PercentageFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "Vat",
            "baseName": "Vat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        },
        {
            "name": "CashFeeChargedToCustomer",
            "baseName": "CashFeeChargedToCustomer",
            "type": "number"
        },
        {
            "name": "NetSales",
            "baseName": "NetSales",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOrder.attributeTypeMap;
    }
}

export namespace PayoutOrder {
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a charge related to a payout
*/
export class PayoutOtherCharge {
    /**
    * The id of the charge
    */
    'ChargeId'?: number;
    /**
    * Charge amount
    */
    'Amount'?: number;
    /**
    * Currency of the charge
    */
    'Currency'?: PayoutOtherCharge.CurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'ChargeDate'?: Date;
    /**
    * Charge type
    */
    'ChargeType'?: PayoutOtherCharge.ChargeTypeEnum;
    /**
    * Charge description
    */
    'ChargeDescription'?: string;
    /**
    * Store id
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargeId",
            "baseName": "ChargeId",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutOtherCharge.CurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "ChargeDate",
            "baseName": "ChargeDate",
            "type": "Date"
        },
        {
            "name": "ChargeType",
            "baseName": "ChargeType",
            "type": "PayoutOtherCharge.ChargeTypeEnum"
        },
        {
            "name": "ChargeDescription",
            "baseName": "ChargeDescription",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOtherCharge.attributeTypeMap;
    }
}

export namespace PayoutOtherCharge {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChargeTypeEnum {
        Other = <any> 'Other',
        Fees = <any> 'Fees',
        Chargeback = <any> 'Chargeback',
        TipFailure = <any> 'TipFailure',
        ExternalDisbursement = <any> 'ExternalDisbursement',
        Goods = <any> 'Goods',
        RestaurantSales = <any> 'RestaurantSales',
        Tips = <any> 'Tips'
    }
}
/**
* Holds the information for a refund related to a payout
*/
export class PayoutRefund {
    /**
    * The id of the order the refund was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutRefund.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutRefund.OrderTypeEnum;
    /**
    * The date the refund was done
    */
    'RefundDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Total refund amount
    */
    'TotalRefund'?: number;
    /**
    * Refunded fees amount
    */
    'RefundedFees'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Cash fee refunded to customer
    */
    'CashFeeRefundedToCustomer'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutRefund.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutRefund.OrderTypeEnum"
        },
        {
            "name": "RefundDate",
            "baseName": "RefundDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TotalRefund",
            "baseName": "TotalRefund",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "CashFeeRefundedToCustomer",
            "baseName": "CashFeeRefundedToCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutRefund.attributeTypeMap;
    }
}

export namespace PayoutRefund {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Payout Request ids for filtering on Payouts
*/
export class PayoutRequestIds {
    /**
    * List of bank account ids to search for
    */
    'BankAccountIds'?: Array<number>;
    /**
    * List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
    */
    'States'?: Array<PayoutRequestIds.StatesEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccountIds",
            "baseName": "BankAccountIds",
            "type": "Array<number>"
        },
        {
            "name": "States",
            "baseName": "States",
            "type": "Array<PayoutRequestIds.StatesEnum>"
        }    ];

    static getAttributeTypeMap() {
        return PayoutRequestIds.attributeTypeMap;
    }
}

export namespace PayoutRequestIds {
    export enum StatesEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
}
/**
* Payout details for a single store
*/
export class PayoutStore {
    /**
    * The id of the Store.
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Amount of the payout for this Store
    */
    'Amount'?: number;
    /**
    * Revenue details (DEPRECATED: Use Revenue)
    */
    'OnlineRevenue'?: RevenueDetail;
    /**
    * Revenue details
    */
    'Revenue'?: RevenueDetail;
    /**
    * Revenue Adjustments breakdown
    */
    'RevenueAdjustments'?: RevenueAdjustmentsDetails;
    /**
    * Fees breakdown
    */
    'FlipdishFees'?: FlipdishFeesDetails;
    /**
    * Chargebacks breakdown
    */
    'Chargebacks'?: ChargebackDetails;
    /**
    * Breakdown of other charges
    */
    'OtherCharges'?: OtherChargesDetails;
    /**
    * Period opening and closing balance
    */
    'Balance'?: BalanceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "OnlineRevenue",
            "baseName": "OnlineRevenue",
            "type": "RevenueDetail"
        },
        {
            "name": "Revenue",
            "baseName": "Revenue",
            "type": "RevenueDetail"
        },
        {
            "name": "RevenueAdjustments",
            "baseName": "RevenueAdjustments",
            "type": "RevenueAdjustmentsDetails"
        },
        {
            "name": "FlipdishFees",
            "baseName": "FlipdishFees",
            "type": "FlipdishFeesDetails"
        },
        {
            "name": "Chargebacks",
            "baseName": "Chargebacks",
            "type": "ChargebackDetails"
        },
        {
            "name": "OtherCharges",
            "baseName": "OtherCharges",
            "type": "OtherChargesDetails"
        },
        {
            "name": "Balance",
            "baseName": "Balance",
            "type": "BalanceDetails"
        }    ];

    static getAttributeTypeMap() {
        return PayoutStore.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payouts summary.
*/
export class PayoutSummary {
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutSummary.PayoutStatusEnum;
    /**
    * Total payouts amount
    */
    'TotalAmount'?: number;
    /**
    * Payout currency
    */
    'Currency'?: PayoutSummary.CurrencyEnum;
    /**
    * Total payouts count
    */
    'TotalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutSummary.PayoutStatusEnum"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutSummary.CurrencyEnum"
        },
        {
            "name": "TotalCount",
            "baseName": "TotalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutSummary.attributeTypeMap;
    }
}

export namespace PayoutSummary {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Pending Menu Changes
*/
export class PendingMenuChanges {
    /**
    * Unique catalog element id
    */
    'CatalogElementId'?: string;
    /**
    * Unique menu id
    */
    'MenuId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogElementId",
            "baseName": "CatalogElementId",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PendingMenuChanges.attributeTypeMap;
    }
}

/**
* Percent discount details
*/
export class PercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PercentageDiscount",
            "baseName": "PercentageDiscount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PercentDiscountDetails.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId'?: number;
    /**
    * Time of the call
    */
    'TimeOfCall'?: Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal'?: Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId'?: number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName'?: string;
    /**
    * Name of the caller
    */
    'CallerName'?: string;
    /**
    * UserID of the caller
    */
    'CallerUserId'?: number;
    /**
    * Phone number of the caller
    */
    'CallerNumber'?: string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds'?: number;
    /**
    * The status of the call
    */
    'CallStatus'?: PhoneCall.CallStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneCallId",
            "baseName": "PhoneCallId",
            "type": "number"
        },
        {
            "name": "TimeOfCall",
            "baseName": "TimeOfCall",
            "type": "Date"
        },
        {
            "name": "TimeOfCallLocal",
            "baseName": "TimeOfCallLocal",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "CallerName",
            "baseName": "CallerName",
            "type": "string"
        },
        {
            "name": "CallerUserId",
            "baseName": "CallerUserId",
            "type": "number"
        },
        {
            "name": "CallerNumber",
            "baseName": "CallerNumber",
            "type": "string"
        },
        {
            "name": "CallLengthInSeconds",
            "baseName": "CallLengthInSeconds",
            "type": "number"
        },
        {
            "name": "CallStatus",
            "baseName": "CallStatus",
            "type": "PhoneCall.CallStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCall.attributeTypeMap;
    }
}

export namespace PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Phone call ended event
*/
export class PhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallEndedEvent.attributeTypeMap;
    }
}

/**
* Phone call started event
*/
export class PhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallStartedEvent.attributeTypeMap;
    }
}

/**
* Pre Order Config
*/
export class PreOrderConfig {
    /**
    * Lead Time in Minutes
    */
    'LeadTimeMinutes'?: number;
    /**
    * Interval in minutes
    */
    'IntervalMinutes'?: number;
    /**
    * Max Days to order ahead
    */
    'MaxOrderAheadDays'?: number;
    /**
    * Show ASAP as option
    */
    'IncludeAsap'?: boolean;
    /**
    * Granual Init' Time
    */
    'IncludeMoreGranularInitialTime'?: boolean;
    /**
    * Cut off time previous day
    */
    'CutOffTimePreviousDayBasic'?: string;
    /**
    * Cut off time current day
    */
    'CutOffTimeCurrentDayBasic'?: string;
    /**
    * Type of time displayed.
    */
    'PreOrderTimeDisplayType'?: PreOrderConfig.PreOrderTimeDisplayTypeEnum;
    /**
    * Specifies whether a customer can pre-order outside the store opening hours or not.
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * Force customer to select collection time.
    */
    'RequireExplicitSelectAlways'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "number"
        },
        {
            "name": "IntervalMinutes",
            "baseName": "IntervalMinutes",
            "type": "number"
        },
        {
            "name": "MaxOrderAheadDays",
            "baseName": "MaxOrderAheadDays",
            "type": "number"
        },
        {
            "name": "IncludeAsap",
            "baseName": "IncludeAsap",
            "type": "boolean"
        },
        {
            "name": "IncludeMoreGranularInitialTime",
            "baseName": "IncludeMoreGranularInitialTime",
            "type": "boolean"
        },
        {
            "name": "CutOffTimePreviousDayBasic",
            "baseName": "CutOffTimePreviousDayBasic",
            "type": "string"
        },
        {
            "name": "CutOffTimeCurrentDayBasic",
            "baseName": "CutOffTimeCurrentDayBasic",
            "type": "string"
        },
        {
            "name": "PreOrderTimeDisplayType",
            "baseName": "PreOrderTimeDisplayType",
            "type": "PreOrderConfig.PreOrderTimeDisplayTypeEnum"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "RequireExplicitSelectAlways",
            "baseName": "RequireExplicitSelectAlways",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderConfig.attributeTypeMap;
    }
}

export namespace PreOrderConfig {
    export enum PreOrderTimeDisplayTypeEnum {
        SingleTime = <any> 'SingleTime',
        StartAndEndTime = <any> 'StartAndEndTime',
        DayOnly = <any> 'DayOnly'
    }
}
/**
* Time order can be placed
*/
export class PreOrderTime {
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderTime.attributeTypeMap;
    }
}

/**
* Predefined answer
*/
export class PredefinedAnswer {
    /**
    * Identifier
    */
    'Id'?: number;
    /**
    * Text
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredefinedAnswer.attributeTypeMap;
    }
}

/**
* Defines a price
*/
export class Price {
    /**
    * Amount (including tax)
    */
    'Amount'?: number;
    /**
    * Tax (only required in tax exclusive prices)
    */
    'Tax'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Tax",
            "baseName": "Tax",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Price.attributeTypeMap;
    }
}

/**
* Printer
*/
export class Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber'?: string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "LastPollTime",
            "baseName": "LastPollTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Printer.attributeTypeMap;
    }
}

/**
* Printer assigned to store event
*/
export class PrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterAssignedToStoreEvent.attributeTypeMap;
    }
}

/**
* Printer turned off event
*/
export class PrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOffEvent.attributeTypeMap;
    }
}

/**
* Printer turned on event
*/
export class PrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOnEvent.attributeTypeMap;
    }
}

/**
* Printer assigned from store event
*/
export class PrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterUnassignedFromStoreEvent.attributeTypeMap;
    }
}

/**
* Processing fee config
*/
export class ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee'?: number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "ProcessingFeeConfig.PaymentAccountTypeEnum"
        },
        {
            "name": "PercentFee",
            "baseName": "PercentFee",
            "type": "number"
        },
        {
            "name": "FixedFee",
            "baseName": "FixedFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessingFeeConfig.attributeTypeMap;
    }
}

export namespace ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
}
/**
* Product
*/
export class Product {
    /**
    * Unique catalog Item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the item is archived
    */
    'IsArchived'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<GroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ProductType': Product.ProductTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Product name
    */
    'Name': string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<GroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "Product.ProductTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Product.attributeTypeMap;
    }
}

export namespace Product {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Publish Menu Changes
*/
export class PublishMenuChanges {
    /**
    * Optional Catalog element id
    */
    'CatalogElementId'?: string;
    /**
    * Optional Collection of Menu id
    */
    'MenuIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogElementId",
            "baseName": "CatalogElementId",
            "type": "string"
        },
        {
            "name": "MenuIds",
            "baseName": "MenuIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return PublishMenuChanges.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationDeletedEvent.attributeTypeMap;
    }
}

/**
* Push Notification Details
*/
export class PushNotificationRequest {
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationRequest.attributeTypeMap;
    }
}

/**
* Push Notification
*/
export class PushNotificationResponse {
    /**
    * Sent
    */
    'Sent'?: boolean;
    /**
    * Push notification identifier
    */
    'ScheduledPushNotificationId'?: number;
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sent",
            "baseName": "Sent",
            "type": "boolean"
        },
        {
            "name": "ScheduledPushNotificationId",
            "baseName": "ScheduledPushNotificationId",
            "type": "number"
        },
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationScheduledEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'User'?: UserEventInfo;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationScheduledEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationSentEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationSentEvent.attributeTypeMap;
    }
}

/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class Range {
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Day of week
    */
    'DayOfWeek'?: Range.DayOfWeekEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* 
*/
export class RedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: RedeemInvitationResult.InvitationStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "RedeemInvitationResult.InvitationStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return RedeemInvitationResult.attributeTypeMap;
    }
}

export namespace RedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* Refund
*/
export class Refund {
    /**
    * Refund reason
    */
    'RefundReason'?: string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If true, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RefundReason",
            "baseName": "RefundReason",
            "type": "string"
        },
        {
            "name": "RefundAmount",
            "baseName": "RefundAmount",
            "type": "number"
        },
        {
            "name": "NotifyCustomer",
            "baseName": "NotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

/**
* Reject
*/
export class Reject {
    /**
    * Reject reason.
    */
    'RejectReason': Reject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RejectReason",
            "baseName": "RejectReason",
            "type": "Reject.RejectReasonEnum"
        },
        {
            "name": "DoNotNotifyCustomer",
            "baseName": "DoNotNotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Reject.attributeTypeMap;
    }
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Request login PIN response
*/
export class RequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class RequestLoginPinResposne {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LoginPinSentViaEmail",
            "baseName": "LoginPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinResposne.attributeTypeMap;
    }
}

/**
* 
*/
export class RequestPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetModel.attributeTypeMap;
    }
}

/**
* Request Password Reset PIN response
*/
export class RequestPasswordResetPinResponse {
    /**
    * Password Reset PIN sent via email to user
    */
    'PasswordResetPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PasswordResetPinSentViaEmail",
            "baseName": "PasswordResetPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetPinResponse.attributeTypeMap;
    }
}

export class Response {
    'Stores'?: Array<StoreItemHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreItemHeader>"
        }    ];

    static getAttributeTypeMap() {
        return Response.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAllMetadataResult {
    /**
    * Generic data object.
    */
    'Data': Array<AllMetadataResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AllMetadataResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAllMetadataResult.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmCurrencyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmHourlyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmHourlyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmHourlyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmHourlyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAppStoreAppConfigurationHeader {
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppConfigurationHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppConfigurationHeader>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAppStoreAppConfigurationHeader.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAppStoreAppConfigurationSummary {
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppConfigurationSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppConfigurationSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAppStoreAppConfigurationSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBankAccountSummary {
    /**
    * Generic data object.
    */
    'Data': Array<BankAccountSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BankAccountSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBankAccountSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultChannel {
    /**
    * Generic data object.
    */
    'Data': Array<Channel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Channel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultChannel.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultCountryWithAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': Array<CountryWithAccountFieldsDefinitions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CountryWithAccountFieldsDefinitions>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultCountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': Array<DeliveryZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DeliveryZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriver {
    /**
    * Generic data object.
    */
    'Data': Array<Driver>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Driver>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDriver.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriverStore {
    /**
    * Generic data object.
    */
    'Data': Array<DriverStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DriverStore>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDriverStore.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultEmvTerminalWithAssignments {
    /**
    * Generic data object.
    */
    'Data': Array<EmvTerminalWithAssignments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<EmvTerminalWithAssignments>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultEmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultHomeAction {
    /**
    * Generic data object.
    */
    'Data': Array<HomeAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HomeAction>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultHomeAction.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultKioskCashPaymentSettings {
    /**
    * Generic data object.
    */
    'Data': Array<KioskCashPaymentSettings>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<KioskCashPaymentSettings>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultKioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocalisedTimeZone {
    /**
    * Generic data object.
    */
    'Data': Array<LocalisedTimeZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocalisedTimeZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocationAreaLocation {
    /**
    * Generic data object.
    */
    'Data': Array<LocationAreaLocation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocationAreaLocation>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocationAreaLocation.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocationAreaWithLocations {
    /**
    * Generic data object.
    */
    'Data': Array<LocationAreaWithLocations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocationAreaWithLocations>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<LoyaltyCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LoyaltyCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuCheckpoint {
    /**
    * Generic data object.
    */
    'Data': Array<MenuCheckpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuCheckpoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuCheckpoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementEditResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementEditResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementEditResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementEditResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementListResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementListResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementListResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementListResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuStoreNames {
    /**
    * Generic data object.
    */
    'Data': Array<MenuStoreNames>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuStoreNames>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuStoreNames.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSummary {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuTaxDetails {
    /**
    * Generic data object.
    */
    'Data': Array<MenuTaxDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuTaxDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuTaxDetails.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': Array<OAuthApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthApp>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': Array<OauthClientRedirectUri>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPayoutSummary {
    /**
    * Generic data object.
    */
    'Data': Array<PayoutSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPayoutSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPreOrderTime {
    /**
    * Generic data object.
    */
    'Data': Array<PreOrderTime>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PreOrderTime>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPreOrderTime.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<ProcessingFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ProcessingFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestApiDefaultResponse {
    /**
    * Generic data object.
    */
    'Data': Array<RestApiDefaultResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<RetentionCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RetentionCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': Array<StoreChannelAssignment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreChannelAssignment>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreChannelStoreMapping {
    /**
    * Generic data object.
    */
    'Data': Array<StoreChannelStoreMapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreChannelStoreMapping>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreListItem {
    /**
    * Generic data object.
    */
    'Data': Array<StoreListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreListItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreListItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<StoreStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreStatistics.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultSupportedCountry {
    /**
    * Generic data object.
    */
    'Data': Array<SupportedCountry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<SupportedCountry>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultSupportedCountry.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Array<Teammate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Teammate>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultVoucherDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<VoucherDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultVoucherDataPoint.attributeTypeMap;
    }
}

/**
* Rest api default response
*/
export class RestApiDefaultResponse {
    /**
    * Data string
    */
    'Data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api error result
*/
export class RestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Error code
    */
    'ErrorCode'?: number;
    /**
    * Stack trace
    */
    'StackTrace'?: string;
    /**
    * List of errors grouped by field name
    */
    'Errors'?: Array<ValidationErrorResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "ErrorCode",
            "baseName": "ErrorCode",
            "type": "number"
        },
        {
            "name": "StackTrace",
            "baseName": "StackTrace",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<ValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiErrorResult.attributeTypeMap;
    }
}

/**
* 
*/
export class RestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': EventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "EventSearchResult"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

/**
* Rest Api Forbidden Result
*/
export class RestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiForbiddenResult.attributeTypeMap;
    }
}

/**
* Rest api integer result
*/
export class RestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultApp {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<App>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<App>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultApp.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultAppStoreAppSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultAppStoreAppSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultBusinessHoursOverride {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursOverride>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultCatalogGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<CatalogGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CatalogGroup>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultCatalogGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultCatalogItem {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<CatalogItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CatalogItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultCatalogItem.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHttpRequestAndResponseLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HttpRequestAndResponseLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHydraDeviceDetails {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HydraDeviceDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HydraDeviceDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHydraDeviceDetails.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultMetafieldDefinition {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<MetafieldDefinition>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MetafieldDefinition>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultMetafieldDefinition.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultMetafieldDefinitionRecommendation {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<MetafieldDefinitionRecommendation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MetafieldDefinitionRecommendation>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultMetafieldDefinitionRecommendation.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOAuthTokenModel {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OAuthTokenModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOAuthTokenModel.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Order>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Order>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrderSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OrderSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrderSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayout {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Payout>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Payout>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayout.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutChargeback {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutChargeback>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutChargeback>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutChargeback.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOrder>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOtherCharge {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOtherCharge>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOtherCharge>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOtherCharge.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutRefund {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutRefund>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutRefund>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutRefund.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPendingMenuChanges {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PendingMenuChanges>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PendingMenuChanges>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPendingMenuChanges.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPhoneCall {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PhoneCall>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PhoneCall>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPhoneCall.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultProduct {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Product>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Product>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultProduct.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPushNotificationResponse {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PushNotificationResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PushNotificationResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStore {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Store>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Store>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStore.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroup>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroupExtended {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroupExtended>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroupExtended>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroupExtended.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreHeader {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreHeader>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreHeader.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreValidationConfig {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreValidationConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreValidationConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreValidationConfig.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultVoucherSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<VoucherSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultVoucherSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookSubscription {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookSubscription.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountDetail {
    /**
    * Generic data object.
    */
    'Data': AccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': AccountFieldsDefinitions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountFieldsDefinitions"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAddressFormResponse {
    /**
    * Generic data object.
    */
    'Data': AddressFormResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AddressFormResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAddressFormResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatistics {
    /**
    * Generic data object.
    */
    'Data': ApmStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatus {
    /**
    * Generic data object.
    */
    'Data': ApmStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApp {
    /**
    * Generic data object.
    */
    'Data': App;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "App"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': AppChannelAssignment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppChannelAssignment"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppCompliance {
    /**
    * Generic data object.
    */
    'Data': AppCompliance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppCompliance"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppCompliance.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreApp {
    /**
    * Generic data object.
    */
    'Data': AppStoreApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreAppConfiguration {
    /**
    * Generic data object.
    */
    'Data': AppStoreAppConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreAppConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreAppConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAssignedBankAccount {
    /**
    * Generic data object.
    */
    'Data': AssignedBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AssignedBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAssignedBankAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBankAccountDetail {
    /**
    * Generic data object.
    */
    'Data': BankAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BankAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBankAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBluetoothTerminalStatus {
    /**
    * Generic data object.
    */
    'Data': BluetoothTerminalStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BluetoothTerminalStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBluetoothTerminalStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursOverride {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursOverride;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursOverride"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursPeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursPeriod"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCardReader {
    /**
    * Generic data object.
    */
    'Data': CardReader;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CardReader"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCardReader.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCatalogGroup {
    /**
    * Generic data object.
    */
    'Data': CatalogGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CatalogGroup"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCatalogGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCatalogItem {
    /**
    * Generic data object.
    */
    'Data': CatalogItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CatalogItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCatalogItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultChannel {
    /**
    * Generic data object.
    */
    'Data': Channel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Channel"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultChannel.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCoordinates {
    /**
    * Generic data object.
    */
    'Data': Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCoordinates.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCreatedMenuSectionItems {
    /**
    * Generic data object.
    */
    'Data': CreatedMenuSectionItems;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CreatedMenuSectionItems"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCreatedMenuSectionItems.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCustomer {
    /**
    * Generic data object.
    */
    'Data': Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCustomer.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': DeliveryZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DeliveryZone"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDnsRecordInformation {
    /**
    * Generic data object.
    */
    'Data': DnsRecordInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DnsRecordInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDnsRecordInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDriver {
    /**
    * Generic data object.
    */
    'Data': Driver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Driver"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDriver.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHomeStatistics {
    /**
    * Generic data object.
    */
    'Data': HomeStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HomeStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHomeStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraConfig {
    /**
    * Generic data object.
    */
    'Data': HydraConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraDeviceDetails {
    /**
    * Generic data object.
    */
    'Data': HydraDeviceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraDeviceDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraDeviceDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraStatus {
    /**
    * Generic data object.
    */
    'Data': HydraStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPage {
    /**
    * Generic data object.
    */
    'Data': IndexPage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPageBase {
    /**
    * Generic data object.
    */
    'Data': IndexPageBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPageBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPageBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultJobResponse {
    /**
    * Generic data object.
    */
    'Data': JobResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "JobResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultJobResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskCashSetting {
    /**
    * Generic data object.
    */
    'Data': KioskCashSetting;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskCashSetting"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskCashSetting.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskIotConnectionParameters {
    /**
    * Generic data object.
    */
    'Data': KioskIotConnectionParameters;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskIotConnectionParameters"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskIotConnectionParameters.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskStoreSettings {
    /**
    * Generic data object.
    */
    'Data': KioskStoreSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskStoreSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskStoreSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLightspeedSettings {
    /**
    * Generic data object.
    */
    'Data': LightspeedSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LightspeedSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLightspeedSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationArea {
    /**
    * Generic data object.
    */
    'Data': LocationArea;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationArea"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationArea.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationAreaLocation {
    /**
    * Generic data object.
    */
    'Data': LocationAreaLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationAreaLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationAreaLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationAreaWithLocations {
    /**
    * Generic data object.
    */
    'Data': LocationAreaWithLocations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationAreaWithLocations"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': LoyaltyCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LoyaltyCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMappedLocation {
    /**
    * Generic data object.
    */
    'Data': MappedLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MappedLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMappedLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenu {
    /**
    * Generic data object.
    */
    'Data': Menu;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Menu"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenu.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSetItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': MenuSection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSection"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionAvailability {
    /**
    * Generic data object.
    */
    'Data': MenuSectionAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionAvailability"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionAvailability.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': MenuSectionItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Metadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Metadata"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetafieldDefinition {
    /**
    * Generic data object.
    */
    'Data': MetafieldDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MetafieldDefinition"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetafieldDefinition.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': OAuthApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OAuthApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': OauthClientRedirectUri;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrder {
    /**
    * Generic data object.
    */
    'Data': Order;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrder.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderDeliveryInformation {
    /**
    * Generic data object.
    */
    'Data': OrderDeliveryInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderDeliveryInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderDeliveryInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderIngestSubmitOrderResponse {
    /**
    * Generic data object.
    */
    'Data': OrderIngestSubmitOrderResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderIngestSubmitOrderResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderIngestSubmitOrderResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderPaymentInformation {
    /**
    * Generic data object.
    */
    'Data': OrderPaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderPaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentIntent {
    /**
    * Generic data object.
    */
    'Data': PaymentIntent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentIntent"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentIntent.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalTransactionDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalTransactionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalTransactionDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPreOrderConfig {
    /**
    * Generic data object.
    */
    'Data': PreOrderConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PreOrderConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPreOrderConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': ProcessingFeeConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ProcessingFeeConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProduct {
    /**
    * Generic data object.
    */
    'Data': Product;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Product"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProduct.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPushNotificationResponse {
    /**
    * Generic data object.
    */
    'Data': PushNotificationResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PushNotificationResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRedeemInvitationResult {
    /**
    * Generic data object.
    */
    'Data': RedeemInvitationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RedeemInvitationResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRedeemInvitationResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': RetentionCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RetentionCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultServiceCharge {
    /**
    * Generic data object.
    */
    'Data': ServiceCharge;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ServiceCharge"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultServiceCharge.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStore {
    /**
    * Generic data object.
    */
    'Data': Store;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Store"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStore.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreAddress {
    /**
    * Generic data object.
    */
    'Data': StoreAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreAddress"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreAddress.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': StoreChannelAssignment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreChannelAssignment"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreEndOfDayReport {
    /**
    * Generic data object.
    */
    'Data': StoreEndOfDayReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreEndOfDayReport"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreEndOfDayReport.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroup {
    /**
    * Generic data object.
    */
    'Data': StoreGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroup"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroupBase {
    /**
    * Generic data object.
    */
    'Data': StoreGroupBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroupBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroupBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreKioskSettings {
    /**
    * Generic data object.
    */
    'Data': StoreKioskSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreKioskSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreKioskSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreOrderCapacityConfig {
    /**
    * Generic data object.
    */
    'Data': StoreOrderCapacityConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreOrderCapacityConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreOrderCapacityConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeConnectedAccount {
    /**
    * Generic data object.
    */
    'Data': StripeConnectedAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeConnectedAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeConnectedAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalConnectionToken {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalConnectionToken;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalConnectionToken"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalConnectionToken.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalLocation {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalPrivateKey {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalPrivateKey;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalPrivateKey"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalPrivateKey.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStuartSettings {
    /**
    * Generic data object.
    */
    'Data': StuartSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StuartSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStuartSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Teammate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Teammate"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTelemetrySeriesResult {
    /**
    * Generic data object.
    */
    'Data': TelemetrySeriesResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "TelemetrySeriesResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTelemetrySeriesResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTipConfiguration {
    /**
    * Generic data object.
    */
    'Data': TipConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "TipConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTipConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultVoucherWithStats {
    /**
    * Generic data object.
    */
    'Data': VoucherWithStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "VoucherWithStats"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultVoucherWithStats.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteImage {
    /**
    * Generic data object.
    */
    'Data': WebsiteImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteImage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteImage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteTestimonial {
    /**
    * Generic data object.
    */
    'Data': WebsiteTestimonial;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteTestimonial"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Rest api string array result
*/
export class RestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringArrayResult.attributeTypeMap;
    }
}

/**
* Rest api string result
*/
export class RestApiStringResult {
    /**
    * Data string
    */
    'Data': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringResult.attributeTypeMap;
    }
}

/**
* Rest api unauthorized result
*/
export class RestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiUnauthorizedResult.attributeTypeMap;
    }
}

/**
* Retention campaign
*/
export class RetentionCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaign.attributeTypeMap;
    }
}

/**
* Retention campaign base
*/
export class RetentionCampaignBase {
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignBase.attributeTypeMap;
    }
}

/**
* Retention campaign created event
*/
export class RetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign deleted event
*/
export class RetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign updated event
*/
export class RetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Revenue Adjustments breakdown
*/
export class RevenueAdjustmentsDetails {
    /**
    * Online sales refunds
    */
    'OnlineSalesRefundedAmount'?: number;
    /**
    * Cash sales refunds
    */
    'CashSalesRefundedAmount'?: number;
    /**
    * Customer cash fees
    */
    'CustomerCashFees'?: number;
    /**
    * Number of refunds
    */
    'RefundsCount'?: number;
    /**
    * Total revenue adjustments
    */
    'TotalOnlineRevenueAdjustments'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesRefundedAmount",
            "baseName": "OnlineSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedAmount",
            "baseName": "CashSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CustomerCashFees",
            "baseName": "CustomerCashFees",
            "type": "number"
        },
        {
            "name": "RefundsCount",
            "baseName": "RefundsCount",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenueAdjustments",
            "baseName": "TotalOnlineRevenueAdjustments",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueAdjustmentsDetails.attributeTypeMap;
    }
}

/**
* Sales information
*/
export class RevenueDetail {
    /**
    * Online sales amount
    */
    'OnlineSalesAmount'?: number;
    /**
    * Online sales tax
    */
    'OnlineSalesTax'?: number;
    /**
    * Online sales amount plus online sales tax
    */
    'OnlineSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'OnlineSalesFeesBaseAmount'?: number;
    /**
    * Cash sales amount
    */
    'CashSalesAmount'?: number;
    /**
    * Cash sales tax
    */
    'CashSalesTax'?: number;
    /**
    * Cash sales amount plus online sales tax
    */
    'CashSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'CashSalesFeesBaseAmount'?: number;
    /**
    * Total Sales (online and cash) including tax
    */
    'TotalSalesIncludingTax'?: number;
    /**
    * Delivery charges on online sales
    */
    'OnlineSalesDeliveryCharges'?: number;
    /**
    * Tips for online sales
    */
    'OnlineSalesTips'?: number;
    /**
    * Online sales plus online delivery charges and tips
    */
    'TotalOnlineRevenue'?: number;
    /**
    * Service charge on online sales
    */
    'OnlineSalesServiceCharges'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesAmount",
            "baseName": "OnlineSalesAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesTax",
            "baseName": "OnlineSalesTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesIncludingTax",
            "baseName": "OnlineSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesFeesBaseAmount",
            "baseName": "OnlineSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "CashSalesAmount",
            "baseName": "CashSalesAmount",
            "type": "number"
        },
        {
            "name": "CashSalesTax",
            "baseName": "CashSalesTax",
            "type": "number"
        },
        {
            "name": "CashSalesIncludingTax",
            "baseName": "CashSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "CashSalesFeesBaseAmount",
            "baseName": "CashSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "TotalSalesIncludingTax",
            "baseName": "TotalSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesDeliveryCharges",
            "baseName": "OnlineSalesDeliveryCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesTips",
            "baseName": "OnlineSalesTips",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenue",
            "baseName": "TotalOnlineRevenue",
            "type": "number"
        },
        {
            "name": "OnlineSalesServiceCharges",
            "baseName": "OnlineSalesServiceCharges",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueDetail.attributeTypeMap;
    }
}

/**
* Search Criteria for Audit Logs
*/
export class SearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit'?: number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page'?: number;
    /**
    * Start date
    */
    'Start'?: Date;
    /**
    * End date
    */
    'End'?: Date;
    /**
    * Events that have Order Id
    */
    'OrderId'?: number;
    /**
    * Events that have Store Id
    */
    'StoreId'?: number;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Events that have User Id
    */
    'UserId'?: number;
    /**
    * Events that have User Email
    */
    'UserEmail'?: string;
    /**
    * Events that have User Name
    */
    'UserName'?: string;
    /**
    * Events that have voucher code
    */
    'VoucherCode'?: string;
    /**
    * Events that have event type\\s
    */
    'EventType'?: Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "Array<string>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCriteria.attributeTypeMap;
    }
}

/**
* Store Service Charge
*/
export class ServiceCharge {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * The Default Service Charge Value
    */
    'PercentageValue'?: number;
    /**
    * Enable Service Charge for store true(on) / false(off)
    */
    'Enabled'?: boolean;
    /**
    * Sets the service charge to be optional
    */
    'IsOptional'?: boolean;
    /**
    * Display service charge together with processing fee
    */
    'DisplayWithProcessingFee'?: boolean;
    /**
    * If true, will include voucher value in calculation   i.e 10E order with 1E service charge and 5E voucher would have service charge at 0.5E
    */
    'IncludesVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PercentageValue",
            "baseName": "PercentageValue",
            "type": "number"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "IsOptional",
            "baseName": "IsOptional",
            "type": "boolean"
        },
        {
            "name": "DisplayWithProcessingFee",
            "baseName": "DisplayWithProcessingFee",
            "type": "boolean"
        },
        {
            "name": "IncludesVouchers",
            "baseName": "IncludesVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ServiceCharge.attributeTypeMap;
    }
}

/**
* Set password with PIN model
*/
export class SetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SetPasswordWithPinModel.attributeTypeMap;
    }
}

/**
* Setting
*/
export class Setting {
    /**
    * Key
    */
    'Key'?: string;
    /**
    * Value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Setting.attributeTypeMap;
    }
}

/**
* 
*/
export class SignupStep {
    /**
    * Action needs to take
    */
    'Action'?: SignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question'?: string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers'?: Array<PredefinedAnswer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Action",
            "baseName": "Action",
            "type": "SignupStep.ActionEnum"
        },
        {
            "name": "Question",
            "baseName": "Question",
            "type": "string"
        },
        {
            "name": "PredefinedAnswers",
            "baseName": "PredefinedAnswers",
            "type": "Array<PredefinedAnswer>"
        }    ];

    static getAttributeTypeMap() {
        return SignupStep.attributeTypeMap;
    }
}

export namespace SignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription'
    }
}
/**
* Sms Info
*/
export class SmsInfo {
    /**
    * Origin phone number
    */
    'From'?: string;
    /**
    * Destination phone number
    */
    'To'?: string;
    /**
    * Text message
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "string"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "string"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsInfo.attributeTypeMap;
    }
}

/**
* Sms received event
*/
export class SmsReceivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The sms info
    */
    'SmsInfo'?: SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SmsInfo",
            "baseName": "SmsInfo",
            "type": "SmsInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsReceivedEvent.attributeTypeMap;
    }
}

/**
* A single currency data point, with no date
*/
export class StatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency'?: StatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount'?: number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount'?: number;
    /**
    * Value of orders for this currency
    */
    'OrderValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StatisticsCurrencyDataPoint.CurrencyEnum"
        },
        {
            "name": "UserCount",
            "baseName": "UserCount",
            "type": "number"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StatisticsCurrencyDataPoint.attributeTypeMap;
    }
}

export namespace StatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store
*/
export class Store {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId'?: number;
    /**
    * Store address
    */
    'Address'?: StoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones'?: Array<DeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber'?: string;
    /**
    * Pickup hours
    */
    'PickupHours'?: Array<BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours'?: Array<BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery'?: string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup'?: string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType'?: Store.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes'?: Array<StoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone'?: string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone'?: string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency'?: Store.CurrencyEnum;
    /**
    * Is PerOrder Enabled for Delivery
    */
    'PreOrderDeliveryEnabled'?: boolean;
    /**
    * Is PerOrder Enabled for Pickup
    */
    'PreOrderPickupEnabled'?: boolean;
    /**
    * Url for logo image
    */
    'LogoUrl'?: string;
    /**
    * Fraud Prevention Strategy
    */
    'FraudPreventionStrategy'?: string;
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "StoreAddress"
        },
        {
            "name": "DeliveryZones",
            "baseName": "DeliveryZones",
            "type": "Array<DeliveryZone>"
        },
        {
            "name": "ApmPhoneNumber",
            "baseName": "ApmPhoneNumber",
            "type": "string"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "DeliveryHours",
            "baseName": "DeliveryHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "OrderConfirmationMessageOverrideDelivery",
            "baseName": "OrderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "OrderConfirmationMessageOverridePickup",
            "baseName": "OrderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "PrintoutLayoutType",
            "baseName": "PrintoutLayoutType",
            "type": "Store.PrintoutLayoutTypeEnum"
        },
        {
            "name": "StoreNotes",
            "baseName": "StoreNotes",
            "type": "Array<StoreNote>"
        },
        {
            "name": "MicrosoftTimeZone",
            "baseName": "MicrosoftTimeZone",
            "type": "string"
        },
        {
            "name": "IanaTimeZone",
            "baseName": "IanaTimeZone",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Store.CurrencyEnum"
        },
        {
            "name": "PreOrderDeliveryEnabled",
            "baseName": "PreOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "PreOrderPickupEnabled",
            "baseName": "PreOrderPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "LogoUrl",
            "baseName": "LogoUrl",
            "type": "string"
        },
        {
            "name": "FraudPreventionStrategy",
            "baseName": "FraudPreventionStrategy",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Store.attributeTypeMap;
    }
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store address
*/
export class StoreAddress {
    /**
    * Address identifier
    */
    'AddressId'?: number;
    /**
    * Coordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;
    /**
    * Dyanmic field/value pairs, defined by the form assigned to the given country code.
    */
    'AddressFields'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressId",
            "baseName": "AddressId",
            "type": "number"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        },
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddress.attributeTypeMap;
    }
}

/**
* Store address base
*/
export class StoreAddressBase {
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;
    /**
    * Dyanmic field/value pairs, defined by the form assigned to the given country code.
    */
    'AddressFields'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        },
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressBase.attributeTypeMap;
    }
}

/**
* Address form payload.
*/
export class StoreAddressForm {
    /**
    * The dynamic fields generated by the address form.
    */
    'AddressFields': { [key: string]: any; };
    /**
    * ISO 2 letters code for the country, should be the same as the form that generates the fields.
    */
    'CountryCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressForm.attributeTypeMap;
    }
}

/**
* Store Address Updated Event
*/
export class StoreAddressUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store address
    */
    'StoreAddress'?: StoreAddress;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreAddress",
            "baseName": "StoreAddress",
            "type": "StoreAddress"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Archived Event
*/
export class StoreArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which archived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Archived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreArchivedEvent.attributeTypeMap;
    }
}

/**
* Store Base
*/
export class StoreBase {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBase.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Created
*/
export class StoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Deleted
*/
export class StoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideDeletedEvent.attributeTypeMap;
    }
}

/**
* Store campaign start time
*/
export class StoreCampaignStartTime {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Campaign start time in Utc
    */
    'TsStart'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TsStart",
            "baseName": "TsStart",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreCampaignStartTime.attributeTypeMap;
    }
}

/**
* Represents a store that is assigned to a Sales Channel
*/
export class StoreChannelAssignment {
    /**
    * Channel ID
    */
    'ChannelId'?: number;
    /**
    * Store ID
    */
    'StoreId'?: number;
    /**
    * Store Name
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Describes an ID mapping between Flipdish Store and Channel Store
*/
export class StoreChannelStoreMapping {
    /**
    * Channel Id
    */
    'ChannelId'?: number;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Channel Store Id
    */
    'ChannelStoreId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChannelStoreId",
            "baseName": "ChannelStoreId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Settings for cloning a store
*/
export class StoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TargetStoreGroupId",
            "baseName": "TargetStoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreCloneSettings.attributeTypeMap;
    }
}

export class StoreConfig {
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store has a Bank Account attached
    */
    'BankAccountAttached'?: boolean;
    /**
    * True if the store is assigned to a Menu
    */
    'MenuAssigned'?: boolean;
    /**
    * True if the store has a valid Address
    */
    'HasFullAddress'?: boolean;
    /**
    * True if the store has Pickup hours
    */
    'PickupHours'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "BankAccountAttached",
            "baseName": "BankAccountAttached",
            "type": "boolean"
        },
        {
            "name": "MenuAssigned",
            "baseName": "MenuAssigned",
            "type": "boolean"
        },
        {
            "name": "HasFullAddress",
            "baseName": "HasFullAddress",
            "type": "boolean"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StoreConfig.attributeTypeMap;
    }
}

/**
* Store Create Base
*/
export class StoreCreateBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreateBase.attributeTypeMap;
    }
}

/**
* Store Created Event
*/
export class StoreCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which created this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Data Point
*/
export class StoreDataPoint {
    /**
    * Day
    */
    'Day'?: Date;
    /**
    * Value for the day
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "Date"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDataPoint.attributeTypeMap;
    }
}

/**
* Store Deleted Event
*/
export class StoreDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeletedEvent.attributeTypeMap;
    }
}

/**
* Store end of day report
*/
export class StoreEndOfDayReport {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Currency
    */
    'Currency'?: StoreEndOfDayReport.CurrencyEnum;
    /**
    * Order Count
    */
    'OrderCount'?: number;
    /**
    * Order Value
    */
    'OrderValue'?: number;
    /**
    * Order Value Excluding Delivery Fees
    */
    'OrderValueExcludingDeliveryFees'?: number;
    /**
    * Collection Order Count
    */
    'CollectionOrderCount'?: number;
    /**
    * Collection Cash Order Count
    */
    'CollectionCashOrderCount'?: number;
    /**
    * Collection Paid Online Order Count
    */
    'CollectionPaidOnlineOrderCount'?: number;
    /**
    * Collection Order Value
    */
    'CollectionOrderValue'?: number;
    /**
    * Collection Cash Order Value
    */
    'CollectionCashOrderValue'?: number;
    /**
    * Collection Paid Online Order Value
    */
    'CollectionPaidOnlineOrderValue'?: number;
    /**
    * Delivery Order Count
    */
    'DeliveryOrderCount'?: number;
    /**
    * Delivery Cash Order Count
    */
    'DeliveryCashOrderCount'?: number;
    /**
    * Delivery Paid Online Order Count
    */
    'DeliveryPaidOnlineOrderCount'?: number;
    /**
    * Delivery Order Value
    */
    'DeliveryOrderValue'?: number;
    /**
    * Delivery Cash Order Value
    */
    'DeliveryCashOrderValue'?: number;
    /**
    * Delivery Paid Online Order Value
    */
    'DeliveryPaidOnlineOrderValue'?: number;
    /**
    * Paid Online Order Count
    */
    'PaidOnlineOrderCount'?: number;
    /**
    * Cash Order Count
    */
    'CashOrderCount'?: number;
    /**
    * Paid Online Order Value
    */
    'PaidOnlineOrderValue'?: number;
    /**
    * Cash Order Value
    */
    'CashOrderValue'?: number;
    /**
    * Paid Online Order Value Excluding Delivery Fees
    */
    'PaidOnlineOrderValueExcludingDeliveryFees'?: number;
    /**
    * Cash Order Value Excluding Delivery Fees
    */
    'CashOrderValueExcludingDeliveryFees'?: number;
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreEndOfDayReport.CurrencyEnum"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        },
        {
            "name": "OrderValueExcludingDeliveryFees",
            "baseName": "OrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CollectionOrderCount",
            "baseName": "CollectionOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderCount",
            "baseName": "CollectionCashOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderCount",
            "baseName": "CollectionPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionOrderValue",
            "baseName": "CollectionOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderValue",
            "baseName": "CollectionCashOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderValue",
            "baseName": "CollectionPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryOrderCount",
            "baseName": "DeliveryOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderCount",
            "baseName": "DeliveryCashOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderCount",
            "baseName": "DeliveryPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryOrderValue",
            "baseName": "DeliveryOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderValue",
            "baseName": "DeliveryCashOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderValue",
            "baseName": "DeliveryPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderCount",
            "baseName": "PaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CashOrderCount",
            "baseName": "CashOrderCount",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValue",
            "baseName": "PaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "CashOrderValue",
            "baseName": "CashOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValueExcludingDeliveryFees",
            "baseName": "PaidOnlineOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CashOrderValueExcludingDeliveryFees",
            "baseName": "CashOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreEndOfDayReport.attributeTypeMap;
    }
}

export namespace StoreEndOfDayReport {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group
*/
export class StoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroup.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroup.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroup.attributeTypeMap;
    }
}

export namespace StoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Update Store Group
*/
export class StoreGroupBase {
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupBase.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupBase.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupBase.attributeTypeMap;
    }
}

export namespace StoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Created Event
*/
export class StoreGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Group Deleted Event
*/
export class StoreGroupDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Extended
*/
export class StoreGroupExtended {
    /**
    * Total Amount of Stores
    */
    'TotalStores'?: number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates'?: Array<GroupedCoordinates>;
    /**
    * Store Headers associated with Store Group
    */
    'StoreHeaders'?: Array<StoreHeader>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupExtended.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalStores",
            "baseName": "TotalStores",
            "type": "number"
        },
        {
            "name": "GroupedCoordinates",
            "baseName": "GroupedCoordinates",
            "type": "Array<GroupedCoordinates>"
        },
        {
            "name": "StoreHeaders",
            "baseName": "StoreHeaders",
            "type": "Array<StoreHeader>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupExtended.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupExtended.attributeTypeMap;
    }
}

export namespace StoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Updated Event
*/
export class StoreGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents the most basic store information, used mostly for searches
*/
export class StoreHeader {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Name
    */
    'Category'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Category",
            "baseName": "Category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreHeader.attributeTypeMap;
    }
}

export class StoreItemHeader {
    'StoreId'?: number;
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreItemHeader.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSetting {
    /**
    * Kiosk setting id
    */
    'KioskSettingId'?: number;
    /**
    * Store kiosk name
    */
    'KioskName'?: string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName'?: boolean;
    /**
    * Require customer phone number flag
    */
    'RequireCustomerPhoneNumber'?: boolean;
    /**
    * Request customer phone number flag (Option to Skip)
    */
    'RequestCustomerPhoneNumber'?: boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber'?: boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOption'?: boolean;
    /**
    * Physical restaurant id
    */
    'PhysicalRestaurantId'?: number;
    /**
    * Hydra config id
    */
    'HydraConfigId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskSettingId",
            "baseName": "KioskSettingId",
            "type": "number"
        },
        {
            "name": "KioskName",
            "baseName": "KioskName",
            "type": "string"
        },
        {
            "name": "RequireCustomerName",
            "baseName": "RequireCustomerName",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerPhoneNumber",
            "baseName": "RequireCustomerPhoneNumber",
            "type": "boolean"
        },
        {
            "name": "RequestCustomerPhoneNumber",
            "baseName": "RequestCustomerPhoneNumber",
            "type": "boolean"
        },
        {
            "name": "RequestTableNumber",
            "baseName": "RequestTableNumber",
            "type": "boolean"
        },
        {
            "name": "OfferDineInOrTakeawayOption",
            "baseName": "OfferDineInOrTakeawayOption",
            "type": "boolean"
        },
        {
            "name": "PhysicalRestaurantId",
            "baseName": "PhysicalRestaurantId",
            "type": "number"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSetting.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSettingModel {
    /**
    * Name of the Kiosk
    */
    'KioskName'?: string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName'?: boolean;
    /**
    * Require customer phone number flag
    */
    'RequireCustomerPhoneNumber'?: boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber'?: boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOptions'?: boolean;
    /**
    * Order in which the Kiosks should be listed
    */
    'SortOrder'?: number;
    /**
    * Kiosk (Hydra) config id
    */
    'ConfigId'?: number;
    /**
    * Id of the store (Physical Restaurant)
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskName",
            "baseName": "KioskName",
            "type": "string"
        },
        {
            "name": "RequireCustomerName",
            "baseName": "RequireCustomerName",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerPhoneNumber",
            "baseName": "RequireCustomerPhoneNumber",
            "type": "boolean"
        },
        {
            "name": "RequestTableNumber",
            "baseName": "RequestTableNumber",
            "type": "boolean"
        },
        {
            "name": "OfferDineInOrTakeawayOptions",
            "baseName": "OfferDineInOrTakeawayOptions",
            "type": "boolean"
        },
        {
            "name": "SortOrder",
            "baseName": "SortOrder",
            "type": "number"
        },
        {
            "name": "ConfigId",
            "baseName": "ConfigId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSettingModel.attributeTypeMap;
    }
}

/**
* Store kiosk setting updated
*/
export class StoreKioskSettingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store kiosk settings
    */
    'StoreKioskSetting'?: StoreKioskSetting;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreKioskSetting",
            "baseName": "StoreKioskSetting",
            "type": "StoreKioskSetting"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSettingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSettings {
    /**
    * List of Store Kiosk Settings
    */
    'KioskStoreSettings'?: Array<StoreKioskSettingModel>;
    /**
    * Store Logo Url
    */
    'StoreLogoUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskStoreSettings",
            "baseName": "KioskStoreSettings",
            "type": "Array<StoreKioskSettingModel>"
        },
        {
            "name": "StoreLogoUrl",
            "baseName": "StoreLogoUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSettings.attributeTypeMap;
    }
}

/**
* Store id and name
*/
export class StoreListItem {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Name
    */
    'StoreName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Store Group Name
    */
    'StoreGroupName'?: string;
    /**
    * Store has loyalty campaign
    */
    'HasLoyaltyCampaign'?: boolean;
    /**
    * Store has retention campaign
    */
    'HasRetentionCampaign'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "StoreGroupName",
            "baseName": "StoreGroupName",
            "type": "string"
        },
        {
            "name": "HasLoyaltyCampaign",
            "baseName": "HasLoyaltyCampaign",
            "type": "boolean"
        },
        {
            "name": "HasRetentionCampaign",
            "baseName": "HasRetentionCampaign",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StoreListItem.attributeTypeMap;
    }
}

/**
* Store logo created
*/
export class StoreLogoCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who added the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoCreatedEvent.attributeTypeMap;
    }
}

/**
* Store logo deleted
*/
export class StoreLogoDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who removed the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoDeletedEvent.attributeTypeMap;
    }
}

/**
* Store logo updated
*/
export class StoreLogoUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who updated the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Assigned To Store Event
*/
export class StoreMenuAssignedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * MenuId Id
    */
    'MenuId'?: number;
    /**
    * User who assigned the menu to the store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreMenuAssignedEvent.attributeTypeMap;
    }
}

/**
* Store note
*/
export class StoreNote {
    /**
    * User identifier
    */
    'UserId'?: number;
    /**
    * Create time
    */
    'CreateTime'?: Date;
    /**
    * Note
    */
    'Note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Note",
            "baseName": "Note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreNote.attributeTypeMap;
    }
}

/**
* Store Opening Hours Updated Event
*/
export class StoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated opening hours for this store
    */
    'User'?: UserEventInfo;
    /**
    * Type of opening hours Delivery / Pickup
    */
    'DeliveryType'?: StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum;
    /**
    * The period that was updated
    */
    'BusinessHoursPeriodOld'?: BusinessHoursPeriod;
    /**
    * The new values of the period
    */
    'BusinessHoursPeriod'?: BusinessHoursPeriod;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum"
        },
        {
            "name": "BusinessHoursPeriodOld",
            "baseName": "BusinessHoursPeriodOld",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "BusinessHoursPeriod",
            "baseName": "BusinessHoursPeriod",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

export namespace StoreOpeningHoursUpdatedEvent {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration
*/
export class StoreOrderCapacityConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Signifies whether the order capacity configuration is for Delivery / Pickup
    */
    'DeliveryType'?: StoreOrderCapacityConfig.DeliveryTypeEnum;
    /**
    * Store Interval - time between orders, e.g. 10 minutes between each order time available to customer
    */
    'StoreIntervalInMinutes'?: number;
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOrderCapacityConfig.DeliveryTypeEnum"
        },
        {
            "name": "StoreIntervalInMinutes",
            "baseName": "StoreIntervalInMinutes",
            "type": "number"
        },
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfig.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityConfig {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration edit
*/
export class StoreOrderCapacityConfigEditModel {
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfigEditModel.attributeTypeMap;
    }
}

/**
* Represents a single order capacity period
*/
export class StoreOrderCapacityPeriod {
    /**
    * The maximum number of orders per each store order interval in this order capacity period.  E.g. for a period from 9:00 till 11:00, if the store's interval is 10 minutes, and MaxOrderNumberPerStoreInterval is set to 5,  it means that within each 10-minute interval between 9:00 and 11:00 (i.e. 9:00-9:10, 9:10-9:20, .. , 10:50-11:00) it will be possible to  request at most 5 orders.
    */
    'MaxOrderNumberPerStoreInterval'?: number;
    /**
    * Day of the week the period pertains to
    */
    'DayOfTheWeek'?: StoreOrderCapacityPeriod.DayOfTheWeekEnum;
    /**
    * The hour the period starts at
    */
    'PeriodStartHour'?: number;
    /**
    * The minutes after the hour the period starts at
    */
    'PeriodStartMinutes'?: number;
    /**
    * The hour the period ends at
    */
    'PeriodEndHour'?: number;
    /**
    * The minutes after the hour the period ends at
    */
    'PeriodEndMinutes'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxOrderNumberPerStoreInterval",
            "baseName": "MaxOrderNumberPerStoreInterval",
            "type": "number"
        },
        {
            "name": "DayOfTheWeek",
            "baseName": "DayOfTheWeek",
            "type": "StoreOrderCapacityPeriod.DayOfTheWeekEnum"
        },
        {
            "name": "PeriodStartHour",
            "baseName": "PeriodStartHour",
            "type": "number"
        },
        {
            "name": "PeriodStartMinutes",
            "baseName": "PeriodStartMinutes",
            "type": "number"
        },
        {
            "name": "PeriodEndHour",
            "baseName": "PeriodEndHour",
            "type": "number"
        },
        {
            "name": "PeriodEndMinutes",
            "baseName": "PeriodEndMinutes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityPeriod.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityPeriod {
    export enum DayOfTheWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Store Pre order config updated
*/
export class StorePreOrderConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Pre Order Configuration
    */
    'PreOrderConfig'?: PreOrderConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PreOrderConfig",
            "baseName": "PreOrderConfig",
            "type": "PreOrderConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePreOrderConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Published Event
*/
export class StorePublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which published this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Published Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePublishedEvent.attributeTypeMap;
    }
}

/**
* Service Charge Updated Event
*/
export class StoreServiceChargeUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which made the update
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Service Charge Configuration
    */
    'ServiceCharge'?: ServiceCharge;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ServiceCharge",
            "baseName": "ServiceCharge",
            "type": "ServiceCharge"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreServiceChargeUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store statistics
*/
export class StoreStatistics {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Data Points
    */
    'Data'?: Array<StoreDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return StoreStatistics.attributeTypeMap;
    }
}

/**
* Store summary
*/
export class StoreSummary {
    /**
    * Store identifier
    */
    'Id'?: number;
    /**
    * Store name
    */
    'Name'?: string;
    /**
    * Stores menu identifier
    */
    'MenuId'?: number;
    /**
    * Store metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency'?: StoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates'?: Coordinates;
    /**
    * Timezone of store
    */
    'StoreTimezone'?: string;
    /**
    * Store group id of store
    */
    'StoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreSummary.CurrencyEnum"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "StoreTimezone",
            "baseName": "StoreTimezone",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreSummary.attributeTypeMap;
    }
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Tip Updated
*/
export class StoreTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which made the update
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Configuration change
    */
    'Config'?: UpdateTipConfiguration;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Config",
            "baseName": "Config",
            "type": "UpdateTipConfiguration"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Unarchived Event
*/
export class StoreUnarchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unarchived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unarchived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnarchivedEvent.attributeTypeMap;
    }
}

/**
* Store Unpublished Event
*/
export class StoreUnpublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unpublished this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unpublished Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnpublishedEvent.attributeTypeMap;
    }
}

/**
* Store Updated Event
*/
export class StoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUpdatedEvent.attributeTypeMap;
    }
}

/**
* Hey
*/
export class StoreValidationConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    'Name'?: string;
    /**
    * Is Store Valid for Kiosk
    */
    'IsValid'?: boolean;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    'ConfigValidation'?: StoreConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsValid",
            "baseName": "IsValid",
            "type": "boolean"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "ConfigValidation",
            "baseName": "ConfigValidation",
            "type": "StoreConfig"
        }    ];

    static getAttributeTypeMap() {
        return StoreValidationConfig.attributeTypeMap;
    }
}

/**
* Represents a request for Stripe account link creation
*/
export class StripeAccountLinkRequest {
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * URL to be hit if link creation succeeds
    */
    'ReturnUrl'?: string;
    /**
    * Which information to collect from users at this stage
    */
    'Collect'?: StripeAccountLinkRequest.CollectEnum;
    /**
    * Either onboarding or edit user information
    */
    'Type'?: StripeAccountLinkRequest.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "ReturnUrl",
            "baseName": "ReturnUrl",
            "type": "string"
        },
        {
            "name": "Collect",
            "baseName": "Collect",
            "type": "StripeAccountLinkRequest.CollectEnum"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "StripeAccountLinkRequest.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeAccountLinkRequest.attributeTypeMap;
    }
}

export namespace StripeAccountLinkRequest {
    export enum CollectEnum {
        CurrentlyDue = <any> 'CurrentlyDue',
        EventuallyDue = <any> 'EventuallyDue'
    }
    export enum TypeEnum {
        Onboarding = <any> 'Onboarding',
        Update = <any> 'Update'
    }
}
/**
* Represents a Stripe custom connected account
*/
export class StripeConnectedAccount {
    /**
    * Flipdish connected account identifier
    */
    'FlipdishConnectedAccountId'?: number;
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * Id of the WhitelabelConfig the connected account is assigned to
    */
    'WhitelabelConfigId'?: number;
    /**
    * Card payments capability status (Inactive, Pending, Active, Unrequested)
    */
    'CardPaymentsStatus'?: StripeConnectedAccount.CardPaymentsStatusEnum;
    /**
    * Transfers capability status (Inactive, Pending, Active, Unrequested)
    */
    'TransfersStatus'?: StripeConnectedAccount.TransfersStatusEnum;
    /**
    * Current status of the account
    */
    'AccountStatus'?: StripeConnectedAccount.AccountStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FlipdishConnectedAccountId",
            "baseName": "FlipdishConnectedAccountId",
            "type": "number"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "WhitelabelConfigId",
            "baseName": "WhitelabelConfigId",
            "type": "number"
        },
        {
            "name": "CardPaymentsStatus",
            "baseName": "CardPaymentsStatus",
            "type": "StripeConnectedAccount.CardPaymentsStatusEnum"
        },
        {
            "name": "TransfersStatus",
            "baseName": "TransfersStatus",
            "type": "StripeConnectedAccount.TransfersStatusEnum"
        },
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccount.AccountStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccount.attributeTypeMap;
    }
}

export namespace StripeConnectedAccount {
    export enum CardPaymentsStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum TransfersStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
}
/**
* Represents information about a Stripe connected account associated with a bank account
*/
export class StripeConnectedAccountInfo {
    /**
    * Stripe connected account status
    */
    'AccountStatus'?: StripeConnectedAccountInfo.AccountStatusEnum;
    /**
    * Stripe connected account id
    */
    'StripeId'?: string;
    /**
    * Current status of the Card Payment capability of the account
    */
    'CardPaymentStatus'?: StripeConnectedAccountInfo.CardPaymentStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccountInfo.AccountStatusEnum"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "CardPaymentStatus",
            "baseName": "CardPaymentStatus",
            "type": "StripeConnectedAccountInfo.CardPaymentStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccountInfo.attributeTypeMap;
    }
}

export namespace StripeConnectedAccountInfo {
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
    export enum CardPaymentStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
}
/**
* Stripe Terminal Connection Token
*/
export class StripeTerminalConnectionToken {
    /**
    * Connection Token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalConnectionToken.attributeTypeMap;
    }
}

/**
* Stripe Terminal Private Key
*/
export class StripeTerminalLocation {
    /**
    * Registered location of the terminal
    */
    'Location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalLocation.attributeTypeMap;
    }
}

/**
* Stripe Terminal Private Key
*/
export class StripeTerminalPrivateKey {
    /**
    * Registered location of the terminal
    */
    'Location'?: string;
    /**
    * Secret used to pass to stripe to attach terminal
    */
    'Secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "string"
        },
        {
            "name": "Secret",
            "baseName": "Secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalPrivateKey.attributeTypeMap;
    }
}

/**
* Stuart settings
*/
export class StuartSettings {
    /**
    * Client Id
    */
    'ClientId'?: string;
    /**
    * Client Secret
    */
    'ClientSecret'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication'?: string;
    /**
    * Override Flipdish Webhook Url
    */
    'OverrideWebhookUrl'?: boolean;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime'?: number;
    /**
    * Package type
    */
    'PackageType'?: StuartSettings.PackageTypeEnum;
    /**
    * Transport type
    */
    'TransportType'?: StuartSettings.TransportTypeEnum;
    /**
    * Determines if Flipdish order should be cancel when Stuart cancels delivery
    */
    'CancelOrderIfStuartCancelDelivery'?: boolean;
    'TransportPrices'?: StuartSettingsTransportPrices;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "ClientSecret",
            "baseName": "ClientSecret",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "WebhookUrlBasicAuthentication",
            "baseName": "WebhookUrlBasicAuthentication",
            "type": "string"
        },
        {
            "name": "OverrideWebhookUrl",
            "baseName": "OverrideWebhookUrl",
            "type": "boolean"
        },
        {
            "name": "MinutesToPickupBeforeThanDeliveryTime",
            "baseName": "MinutesToPickupBeforeThanDeliveryTime",
            "type": "number"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "StuartSettings.PackageTypeEnum"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "StuartSettings.TransportTypeEnum"
        },
        {
            "name": "CancelOrderIfStuartCancelDelivery",
            "baseName": "CancelOrderIfStuartCancelDelivery",
            "type": "boolean"
        },
        {
            "name": "TransportPrices",
            "baseName": "TransportPrices",
            "type": "StuartSettingsTransportPrices"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettings.attributeTypeMap;
    }
}

export namespace StuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
    export enum TransportTypeEnum {
        Bike = <any> 'Bike',
        Cargobike = <any> 'Cargobike',
        Cargobikexl = <any> 'Cargobikexl',
        Motorbike = <any> 'Motorbike',
        Motorbikexl = <any> 'Motorbikexl',
        Car = <any> 'Car',
        Van = <any> 'Van'
    }
}
/**
* If the order exceeds are certain amount this configuration will determine a new vehicle type
*/
export class StuartSettingsTransportPrices {
    'Bike'?: number;
    'Cargobike'?: number;
    'Cargobikexl'?: number;
    'Motorbike'?: number;
    'Motorbikexl'?: number;
    'Car'?: number;
    'Van'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Bike",
            "baseName": "Bike",
            "type": "number"
        },
        {
            "name": "Cargobike",
            "baseName": "Cargobike",
            "type": "number"
        },
        {
            "name": "Cargobikexl",
            "baseName": "Cargobikexl",
            "type": "number"
        },
        {
            "name": "Motorbike",
            "baseName": "Motorbike",
            "type": "number"
        },
        {
            "name": "Motorbikexl",
            "baseName": "Motorbikexl",
            "type": "number"
        },
        {
            "name": "Car",
            "baseName": "Car",
            "type": "number"
        },
        {
            "name": "Van",
            "baseName": "Van",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettingsTransportPrices.attributeTypeMap;
    }
}

/**
* Describes a supported country
*/
export class SupportedCountry {
    /**
    * Country code
    */
    'CountryCode'?: string;
    /**
    * Nice display name for a country
    */
    'Name'?: string;
    /**
    * Country internatinoal phone code prefix
    */
    'PhoneCode'?: number;
    /**
    * Language code
    */
    'LanguageCode'?: string;
    /**
    * Language name
    */
    'LanguageName'?: string;
    /**
    * The phone number provided to Store staff which, in conjunction with a one-time-code, will connect them to the customer.
    */
    'OtpNumber'?: string;
    /**
    * The store's support phone number, displayed to customers.
    */
    'SupportNumber'?: string;
    /**
    * Address layout format. This changes the layout of address entry forms on the web app, iOS and Android app and should be set based on local custom.
    */
    'AddressLayout'?: SupportedCountry.AddressLayoutEnum;
    /**
    * Post code type
    */
    'PostCodeType'?: SupportedCountry.PostCodeTypeEnum;
    /**
    * Supported region. This is not used.
    */
    'SupportRegion'?: SupportedCountry.SupportRegionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PhoneCode",
            "baseName": "PhoneCode",
            "type": "number"
        },
        {
            "name": "LanguageCode",
            "baseName": "LanguageCode",
            "type": "string"
        },
        {
            "name": "LanguageName",
            "baseName": "LanguageName",
            "type": "string"
        },
        {
            "name": "OtpNumber",
            "baseName": "OtpNumber",
            "type": "string"
        },
        {
            "name": "SupportNumber",
            "baseName": "SupportNumber",
            "type": "string"
        },
        {
            "name": "AddressLayout",
            "baseName": "AddressLayout",
            "type": "SupportedCountry.AddressLayoutEnum"
        },
        {
            "name": "PostCodeType",
            "baseName": "PostCodeType",
            "type": "SupportedCountry.PostCodeTypeEnum"
        },
        {
            "name": "SupportRegion",
            "baseName": "SupportRegion",
            "type": "SupportedCountry.SupportRegionEnum"
        }    ];

    static getAttributeTypeMap() {
        return SupportedCountry.attributeTypeMap;
    }
}

export namespace SupportedCountry {
    export enum AddressLayoutEnum {
        BuildingFirst = <any> 'BuildingFirst',
        AddressFirst = <any> 'AddressFirst',
        FullStreetAddressFirst = <any> 'FullStreetAddressFirst'
    }
    export enum PostCodeTypeEnum {
        None = <any> 'None',
        PostCode = <any> 'PostCode',
        Zip = <any> 'Zip'
    }
    export enum SupportRegionEnum {
        Default = <any> 'Default',
        Spain = <any> 'Spain',
        Benelux = <any> 'Benelux'
    }
}
/**
* 
*/
export class Teammate {
    /**
    * Unique indentifier
    */
    'TeammateId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Last activity
    */
    'LastActivity'?: Date;
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: Teammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: Teammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TeammateId",
            "baseName": "TeammateId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "LastActivity",
            "baseName": "LastActivity",
            "type": "Date"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "Teammate.InvitationStatusEnum"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "Teammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return Teammate.attributeTypeMap;
    }
}

export namespace Teammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Support = <any> 'Support'
    }
}
/**
* 
*/
export class TeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel'?: TeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "TeammateBase.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TeammateBase.attributeTypeMap;
    }
}

export namespace TeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Support = <any> 'Support'
    }
}
/**
* 
*/
export class TeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who deleted the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who accepted the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteAcceptedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who sent the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who updated the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateUpdatedEvent.attributeTypeMap;
    }
}

export class TelemetrySeriesProperty {
    'Name'?: string;
    'Type'?: string;
    'IntValues'?: Array<number>;
    'StringValues'?: Array<string>;
    'DoubleValues'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "IntValues",
            "baseName": "IntValues",
            "type": "Array<number>"
        },
        {
            "name": "StringValues",
            "baseName": "StringValues",
            "type": "Array<string>"
        },
        {
            "name": "DoubleValues",
            "baseName": "DoubleValues",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesProperty.attributeTypeMap;
    }
}

export class TelemetrySeriesQueryParameters {
    'KioskId'?: string;
    'Variables'?: Array<string>;
    'StartDate'?: Date;
    'EndDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskId",
            "baseName": "KioskId",
            "type": "string"
        },
        {
            "name": "Variables",
            "baseName": "Variables",
            "type": "Array<string>"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "EndDate",
            "baseName": "EndDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesQueryParameters.attributeTypeMap;
    }
}

export class TelemetrySeriesResult {
    'Timestamps'?: Array<Date>;
    'Properties'?: Array<TelemetrySeriesProperty>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Timestamps",
            "baseName": "Timestamps",
            "type": "Array<Date>"
        },
        {
            "name": "Properties",
            "baseName": "Properties",
            "type": "Array<TelemetrySeriesProperty>"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesResult.attributeTypeMap;
    }
}

/**
* Describes the configuration of tipping
*/
export class TipConfiguration {
    /**
    * Configuration is for this StoreId
    */
    'StoreId'?: number;
    /**
    * Are tips enabled?
    */
    'IsEnabled'?: boolean;
    /**
    * Are custom tips allowed?
    */
    'AllowCustomTips'?: boolean;
    /**
    * Ordered list of tip breakpoints (smallest -&gt; largest)
    */
    'Percentages'?: Array<number>;
    /**
    * Defines a default percentage, it must be in the list of Percentages
    */
    'DefaultPercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowCustomTips",
            "baseName": "AllowCustomTips",
            "type": "boolean"
        },
        {
            "name": "Percentages",
            "baseName": "Percentages",
            "type": "Array<number>"
        },
        {
            "name": "DefaultPercentage",
            "baseName": "DefaultPercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TipConfiguration.attributeTypeMap;
    }
}

/**
* Un-Register card reader request
*/
export class UnRegisterCardReaderRequest {
    /**
    * Device card readerid
    */
    'ReaderId': string;
    /**
    * The kiosk device id
    */
    'KioskDeviceId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ReaderId",
            "baseName": "ReaderId",
            "type": "string"
        },
        {
            "name": "KioskDeviceId",
            "baseName": "KioskDeviceId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UnRegisterCardReaderRequest.attributeTypeMap;
    }
}

/**
* Update App store app
*/
export class UpdateAppStoreApp {
    /**
    * Details
    */
    'Details': string;
    /**
    * Configuration type  <example>External link</example><example>Flipdish hosted</example>
    */
    'ConfigurationType': UpdateAppStoreApp.ConfigurationTypeEnum;
    /**
    * Store selector type
    */
    'StoreSelectorType': UpdateAppStoreApp.StoreSelectorTypeEnum;
    /**
    * Field groups
    */
    'FieldGroups'?: Array<FieldGroup>;
    /**
    * Setup instructions
    */
    'SetupInstructions'?: string;
    /**
    * External setup link
    */
    'ExternalSetupLink'?: string;
    /**
    * Teammate app access level
    */
    'TeammateAppAccessLevel'?: UpdateAppStoreApp.TeammateAppAccessLevelEnum;
    /**
    * Permissions type
    */
    'PermissionsType': UpdateAppStoreApp.PermissionsTypeEnum;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Is application enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Categories
    */
    'Categories': Array<UpdateAppStoreApp.CategoriesEnum>;
    /**
    * Countries
    */
    'Countries': Array<UpdateAppStoreApp.CountriesEnum>;
    /**
    * Developer Name
    */
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "UpdateAppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "UpdateAppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "UpdateAppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "UpdateAppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<UpdateAppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<UpdateAppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreApp.attributeTypeMap;
    }
}

export namespace UpdateAppStoreApp {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* Update App store app configuration
*/
export class UpdateAppStoreAppConfiguration {
    /**
    * Is enabled
    */
    'IsEnabled': boolean;
    /**
    * Stores id's
    */
    'StoreIds'?: Array<number>;
    /**
    * Settings
    */
    'Settings'?: Array<Setting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppConfiguration.attributeTypeMap;
    }
}

/**
* App store app configuration webhook event
*/
export class UpdateAppStoreAppConfigurationWebhookDTO {
    /**
    * Unique App store app configuration id
    */
    'Id': string;
    /**
    * Is enabled
    */
    'IsEnabled': boolean;
    /**
    * Store id's
    */
    'StoreIds'?: Array<number>;
    /**
    * Settings
    */
    'Settings'?: Array<Setting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppConfigurationWebhookDTO.attributeTypeMap;
    }
}

/**
* Update Catalog Group
*/
export class UpdateCatalogGroup {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Group name
    */
    'Name'?: string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this group
    */
    'Items'?: Array<UpdateCatalogItemReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<UpdateCatalogItemReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogGroup.attributeTypeMap;
    }
}

/**
* Data to update a {Flipdish.PublicModels.V1.Catalog.Items.CatalogGroupReference}
*/
export class UpdateCatalogGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': UpdateCatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "UpdateCatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogGroupReference.attributeTypeMap;
    }
}

export namespace UpdateCatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Update Catalog Item
*/
export class UpdateCatalogItem {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Product name
    */
    'Name'?: string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price'?: number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<UpdateCatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<UpdateCatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogItem.attributeTypeMap;
    }
}

/**
* Data to update a {!:CatalogGroupReference}
*/
export class UpdateCatalogItemReference {
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ItemType': UpdateCatalogItemReference.ItemTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "UpdateCatalogItemReference.ItemTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogItemReference.attributeTypeMap;
    }
}

export namespace UpdateCatalogItemReference {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* UpdateDriver Push Notification Token
*/
export class UpdateDriverNotificationToken {
    /**
    * Push notifications token, cannot be null
    */
    'PushNotificationsToken': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PushNotificationsToken",
            "baseName": "PushNotificationsToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverNotificationToken.attributeTypeMap;
    }
}

/**
* Update Driver Profile
*/
export class UpdateDriverProfileModel {
    /**
    * The new name of the Driver.
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverProfileModel.attributeTypeMap;
    }
}

/**
* Data to update a {Flipdish.PublicModels.V1.Catalog.Products.GroupReference}
*/
export class UpdateGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': UpdateGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "UpdateGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateGroupReference.attributeTypeMap;
    }
}

export namespace UpdateGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Input model for updating a LocationArea
*/
export class UpdateLocationArea {
    /**
    * Location Area Id
    */
    'LocationAreaId': number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;
    /**
    * Sets if the Location Area should be soft deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLocationArea.attributeTypeMap;
    }
}

/**
* Information to update a {Flipdish.PublicModels.V1.Metafields.MetafieldDefinition}
*/
export class UpdateMetafieldDefinition {
    /**
    * Field Name
    */
    'Name'?: string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<UpdateMetafieldDefinition.BehaviorsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<UpdateMetafieldDefinition.BehaviorsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMetafieldDefinition.attributeTypeMap;
    }
}

export namespace UpdateMetafieldDefinition {
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Update Product
*/
export class UpdateProduct {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Product name
    */
    'Name'?: string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price'?: number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<UpdateGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<UpdateGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateProduct.attributeTypeMap;
    }
}

/**
* Describes the configuration of tipping
*/
export class UpdateTipConfiguration {
    /**
    * Are tips enabled?
    */
    'IsEnabled'?: boolean;
    /**
    * Are custom tips allowed?
    */
    'AllowCustomTips'?: boolean;
    /**
    * Ordered list of tip breakpoints (smallest -&gt; largest)
    */
    'Percentages'?: Array<number>;
    /**
    * Defines a default percentage, it must be in the list of Percentages
    */
    'DefaultPercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowCustomTips",
            "baseName": "AllowCustomTips",
            "type": "boolean"
        },
        {
            "name": "Percentages",
            "baseName": "Percentages",
            "type": "Array<number>"
        },
        {
            "name": "DefaultPercentage",
            "baseName": "DefaultPercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTipConfiguration.attributeTypeMap;
    }
}

/**
* User answered signup questions event
*/
export class UserAnsweredSignupQuestionsEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The users answers
    */
    'SignupAnswers'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "SignupAnswers",
            "baseName": "SignupAnswers",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserAnsweredSignupQuestionsEvent.attributeTypeMap;
    }
}

/**
* User created event
*/
export class UserCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserCreatedEvent.attributeTypeMap;
    }
}

/**
* User deleted event
*/
export class UserDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDeletedEvent.attributeTypeMap;
    }
}

/**
* User Event Info
*/
export class UserEventInfo {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * User Email
    */
    'UserEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserEventInfo.attributeTypeMap;
    }
}

/**
* User login event
*/
export class UserLoginEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserLoginEvent.attributeTypeMap;
    }
}

/**
* User created password event
*/
export class UserPasswordCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserPasswordCreatedEvent.attributeTypeMap;
    }
}

/**
* User updated event
*/
export class UserUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdatedEvent.attributeTypeMap;
    }
}

/**
* Valid Value
*/
export class ValidValue {
    /**
    * Code
    */
    'Code': string;
    /**
    * Name
    */
    'Name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ValidValue.attributeTypeMap;
    }
}

/**
* Validation error result
*/
export class ValidationErrorResult {
    /**
    * Field name
    */
    'FieldName'?: string;
    /**
    * List of errors relates to field
    */
    'Errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FieldName",
            "baseName": "FieldName",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ValidationErrorResult.attributeTypeMap;
    }
}

/**
* Voucher
*/
export class Voucher {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: Voucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: Voucher.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: Voucher.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: Voucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Voucher.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "Voucher.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "Voucher.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Voucher.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Voucher.attributeTypeMap;
    }
}

export namespace Voucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Voucher Base
*/
export class VoucherBase {
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherBase.attributeTypeMap;
    }
}

/**
* Voucher Created Event
*/
export class VoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which created this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherCreatedEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class VoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDataPoint.attributeTypeMap;
    }
}

/**
* Voucher Deleted Event
*/
export class VoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which deleted this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDeletedEvent.attributeTypeMap;
    }
}

/**
* Voucher Summary
*/
export class VoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Status
    */
    'Status'?: VoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherSummary.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherSummary.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherSummary.VoucherSubTypeEnum"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VoucherSummary.attributeTypeMap;
    }
}

export namespace VoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Updated Event
*/
export class VoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which updated this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher With Statistics
*/
export class VoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed'?: number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers'?: number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders'?: number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted'?: number;
    /**
    * Average Order Size
    */
    'AverageOrderSize'?: number;
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: VoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherWithStats.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherWithStats.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: VoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalUsed",
            "baseName": "TotalUsed",
            "type": "number"
        },
        {
            "name": "TotalCustomers",
            "baseName": "TotalCustomers",
            "type": "number"
        },
        {
            "name": "TotalAmountFromOrders",
            "baseName": "TotalAmountFromOrders",
            "type": "number"
        },
        {
            "name": "TotalDiscounted",
            "baseName": "TotalDiscounted",
            "type": "number"
        },
        {
            "name": "AverageOrderSize",
            "baseName": "AverageOrderSize",
            "type": "number"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherWithStats.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherWithStats.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherWithStats.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "VoucherWithStats.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherWithStats.attributeTypeMap;
    }
}

export namespace VoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Sample payload of a webhook event
*/
export class WebhookEventSample {
    /**
    * Event name
    */
    'Type'?: string;
    /**
    * Sample event creation date and time
    */
    'CreateTime'?: Date;
    /**
    * Sample event body
    */
    'Body'?: FlipdishEventBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Body",
            "baseName": "Body",
            "type": "FlipdishEventBase"
        }    ];

    static getAttributeTypeMap() {
        return WebhookEventSample.attributeTypeMap;
    }
}

/**
* Webhook log
*/
export class WebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId'?: number;
    /**
    * Event created
    */
    'EventCreated'?: string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered'?: string;
    /**
    * Webhook event name
    */
    'WebhookEventName'?: string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl'?: string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode'?: string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus'?: string;
    /**
    * Request headers
    */
    'RequestHeaders'?: string;
    /**
    * Request body
    */
    'RequestBody'?: string;
    /**
    * Received response headers
    */
    'ResponseHeaders'?: string;
    /**
    * Received response body
    */
    'ResponseBody'?: string;
    /**
    * Duration of HTTP request
    */
    'Duration'?: string;
    /**
    * Retry count
    */
    'RetryCount'?: number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId'?: string;
    /**
    * Flipdish webhook version
    */
    'Version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebhookSubscriptionOwnerUserId",
            "baseName": "WebhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "EventCreated",
            "baseName": "EventCreated",
            "type": "string"
        },
        {
            "name": "WebhookTriggered",
            "baseName": "WebhookTriggered",
            "type": "string"
        },
        {
            "name": "WebhookEventName",
            "baseName": "WebhookEventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionCallbackUrl",
            "baseName": "WebhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "HttpResponseStatusCode",
            "baseName": "HttpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "HttpResponseStatus",
            "baseName": "HttpResponseStatus",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "string"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "string"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "string"
        },
        {
            "name": "RetryCount",
            "baseName": "RetryCount",
            "type": "number"
        },
        {
            "name": "FlipdishWebhookId",
            "baseName": "FlipdishWebhookId",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

/**
* Webhook subscription
*/
export class WebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version'?: string;
    /**
    * Webhook subscription event names
    */
    'EventNames'?: Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl'?: string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled'?: boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "EventNames",
            "baseName": "EventNames",
            "type": "Array<string>"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "VerifyToken",
            "baseName": "VerifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscription.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId'?: number;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Webhook callback url
    */
    'CallbackUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "WebhookSubscriptionId",
            "baseName": "WebhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a website image
*/
export class WebsiteImage {
    /**
    * Represents the id of the image
    */
    'ImageId'?: number;
    /**
    * Represents the location of the image
    */
    'ImageLocation'?: WebsiteImage.ImageLocationEnum;
    /**
    * Represents the image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageId",
            "baseName": "ImageId",
            "type": "number"
        },
        {
            "name": "ImageLocation",
            "baseName": "ImageLocation",
            "type": "WebsiteImage.ImageLocationEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteImage.attributeTypeMap;
    }
}

export namespace WebsiteImage {
    export enum ImageLocationEnum {
        IndexHeader = <any> 'IndexHeader',
        IndexAboutSectionLeft = <any> 'IndexAboutSectionLeft',
        IndexAboutSectionRight = <any> 'IndexAboutSectionRight',
        IndexGallery = <any> 'IndexGallery',
        IndexOpeningHoursHeader = <any> 'IndexOpeningHoursHeader',
        IndexTestimonialsHeader = <any> 'IndexTestimonialsHeader'
    }
}
/**
* Represents a testimonial
*/
export class WebsiteTestimonial {
    /**
    * Id of the testimonial
    */
    'TestimonialId'?: number;
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TestimonialId",
            "baseName": "TestimonialId",
            "type": "number"
        },
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Represents a testimonial base
*/
export class WebsiteTestimonialBase {
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonialBase.attributeTypeMap;
    }
}

/**
* WebsiteUpdatedEvent
*/
export class WebsiteUpdatedEvent {
    /**
    * App Name id of the whitelabel of the website
    */
    'AppNameId'?: string;
    /**
    * User updating the website
    */
    'User'?: UserEventInfo;
    /**
    * Description of event
    */
    'Description'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppNameId",
            "baseName": "AppNameId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteUpdatedEvent.attributeTypeMap;
    }
}

/**
* Website vanity url
*/
export class WebsiteVanityUrlUpdatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the url
    */
    'User'?: UserEventInfo;
    /**
    * New vanity url
    */
    'VanityUrl'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "VanityUrl",
            "baseName": "VanityUrl",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteVanityUrlUpdatedEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AccountFieldDefinition.KeyEnum": AccountFieldDefinition.KeyEnum,
        "AccountFieldDefinition.TypeEnum": AccountFieldDefinition.TypeEnum,
        "AccountFieldKeyValuePair.KeyEnum": AccountFieldKeyValuePair.KeyEnum,
        "ApmHourlyDataPoint.DayEnum": ApmHourlyDataPoint.DayEnum,
        "App.AppAccessLevelEnum": App.AppAccessLevelEnum,
        "App.AppResourceSetEnum": App.AppResourceSetEnum,
        "App.ApplicationCategoryEnum": App.ApplicationCategoryEnum,
        "AppCompliance.ComplianceTypeEnum": AppCompliance.ComplianceTypeEnum,
        "AppConfigUpdateModel.ApplicationCategoryEnum": AppConfigUpdateModel.ApplicationCategoryEnum,
        "AppStoreApp.VerificationStatusEnum": AppStoreApp.VerificationStatusEnum,
        "AppStoreApp.ConfigurationTypeEnum": AppStoreApp.ConfigurationTypeEnum,
        "AppStoreApp.StoreSelectorTypeEnum": AppStoreApp.StoreSelectorTypeEnum,
        "AppStoreApp.TeammateAppAccessLevelEnum": AppStoreApp.TeammateAppAccessLevelEnum,
        "AppStoreApp.PermissionsTypeEnum": AppStoreApp.PermissionsTypeEnum,
        "AppStoreApp.CategoriesEnum": AppStoreApp.CategoriesEnum,
        "AppStoreApp.CountriesEnum": AppStoreApp.CountriesEnum,
        "AppStoreAppConfiguration.VerificationStatusEnum": AppStoreAppConfiguration.VerificationStatusEnum,
        "AppStoreAppConfiguration.ConfigurationTypeEnum": AppStoreAppConfiguration.ConfigurationTypeEnum,
        "AppStoreAppConfiguration.StoreSelectorTypeEnum": AppStoreAppConfiguration.StoreSelectorTypeEnum,
        "AppStoreAppConfiguration.TeammateAppAccessLevelEnum": AppStoreAppConfiguration.TeammateAppAccessLevelEnum,
        "AppStoreAppConfiguration.PermissionsTypeEnum": AppStoreAppConfiguration.PermissionsTypeEnum,
        "AppStoreAppConfiguration.CategoriesEnum": AppStoreAppConfiguration.CategoriesEnum,
        "AppStoreAppConfiguration.CountriesEnum": AppStoreAppConfiguration.CountriesEnum,
        "AppStoreAppConfigurationSummary.ConfigurationTypeEnum": AppStoreAppConfigurationSummary.ConfigurationTypeEnum,
        "AppStoreAppConfigurationSummary.StoreSelectorTypeEnum": AppStoreAppConfigurationSummary.StoreSelectorTypeEnum,
        "AppStoreAppSummary.VerificationStatusEnum": AppStoreAppSummary.VerificationStatusEnum,
        "AppStoreAppSummary.CategoriesEnum": AppStoreAppSummary.CategoriesEnum,
        "AppStoreAppSummary.CountriesEnum": AppStoreAppSummary.CountriesEnum,
        "BankAccount.AccountStateEnum": BankAccount.AccountStateEnum,
        "BankAccountCreate.CurrencyCodeEnum": BankAccountCreate.CurrencyCodeEnum,
        "BankAccountCreate.BusinessTypeEnum": BankAccountCreate.BusinessTypeEnum,
        "BankAccountDetail.AccountStateEnum": BankAccountDetail.AccountStateEnum,
        "BankAccountDetail.CurrencyCodeEnum": BankAccountDetail.CurrencyCodeEnum,
        "BankAccountDetail.BusinessTypeEnum": BankAccountDetail.BusinessTypeEnum,
        "BankAccountDetailsUpdateRequest.BusinessTypeEnum": BankAccountDetailsUpdateRequest.BusinessTypeEnum,
        "BankAccountSummary.AccountStateEnum": BankAccountSummary.AccountStateEnum,
        "BankAccountSummary.BusinessTypeEnum": BankAccountSummary.BusinessTypeEnum,
        "BluetoothTerminalStatus.DeviceTypeEnum": BluetoothTerminalStatus.DeviceTypeEnum,
        "BluetoothTerminalStatus.StatusEnum": BluetoothTerminalStatus.StatusEnum,
        "BusinessHoursOverride.DeliveryTypeEnum": BusinessHoursOverride.DeliveryTypeEnum,
        "BusinessHoursOverride.TypeEnum": BusinessHoursOverride.TypeEnum,
        "BusinessHoursOverrideBase.DeliveryTypeEnum": BusinessHoursOverrideBase.DeliveryTypeEnum,
        "BusinessHoursOverrideBase.TypeEnum": BusinessHoursOverrideBase.TypeEnum,
        "BusinessHoursPeriod.DayOfWeekEnum": BusinessHoursPeriod.DayOfWeekEnum,
        "BusinessHoursPeriodBase.DayOfWeekEnum": BusinessHoursPeriodBase.DayOfWeekEnum,
        "CatalogGroup.GroupTypeEnum": CatalogGroup.GroupTypeEnum,
        "CatalogGroupReference.GroupTypeEnum": CatalogGroupReference.GroupTypeEnum,
        "CatalogItem.ItemTypeEnum": CatalogItem.ItemTypeEnum,
        "CatalogItemReference.ItemTypeEnum": CatalogItemReference.ItemTypeEnum,
        "Channel.SourceEnum": Channel.SourceEnum,
        "CreateAppStoreApp.ConfigurationTypeEnum": CreateAppStoreApp.ConfigurationTypeEnum,
        "CreateAppStoreApp.StoreSelectorTypeEnum": CreateAppStoreApp.StoreSelectorTypeEnum,
        "CreateAppStoreApp.TeammateAppAccessLevelEnum": CreateAppStoreApp.TeammateAppAccessLevelEnum,
        "CreateAppStoreApp.PermissionsTypeEnum": CreateAppStoreApp.PermissionsTypeEnum,
        "CreateAppStoreApp.CategoriesEnum": CreateAppStoreApp.CategoriesEnum,
        "CreateAppStoreApp.CountriesEnum": CreateAppStoreApp.CountriesEnum,
        "CreateCatalogGroup.GroupTypeEnum": CreateCatalogGroup.GroupTypeEnum,
        "CreateCatalogGroupReference.GroupTypeEnum": CreateCatalogGroupReference.GroupTypeEnum,
        "CreateCatalogItem.ItemTypeEnum": CreateCatalogItem.ItemTypeEnum,
        "CreateCatalogItemReference.ItemTypeEnum": CreateCatalogItemReference.ItemTypeEnum,
        "CreateFullMenu.MenuSectionBehaviourEnum": CreateFullMenu.MenuSectionBehaviourEnum,
        "CreateFullMenu.TaxTypeEnum": CreateFullMenu.TaxTypeEnum,
        "CreateFullMenuItemOptionSet.CellLayoutTypeEnum": CreateFullMenuItemOptionSet.CellLayoutTypeEnum,
        "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum": CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum,
        "CreateFullMenuSectionItem.SpicinessRatingEnum": CreateFullMenuSectionItem.SpicinessRatingEnum,
        "CreateFullMenuSectionItem.CellLayoutTypeEnum": CreateFullMenuSectionItem.CellLayoutTypeEnum,
        "CreateGroupReference.GroupTypeEnum": CreateGroupReference.GroupTypeEnum,
        "CreateMetafieldDefinition.OwnerEntityEnum": CreateMetafieldDefinition.OwnerEntityEnum,
        "CreateMetafieldDefinition.ValueTypeEnum": CreateMetafieldDefinition.ValueTypeEnum,
        "CreateMetafieldDefinition.BehaviorsEnum": CreateMetafieldDefinition.BehaviorsEnum,
        "CreateProduct.ProductTypeEnum": CreateProduct.ProductTypeEnum,
        "CreateTeammate.AppAccessLevelEnum": CreateTeammate.AppAccessLevelEnum,
        "CreateVoucher.VoucherTypeEnum": CreateVoucher.VoucherTypeEnum,
        "CurrencyData.CurrencyEnum": CurrencyData.CurrencyEnum,
        "CustomerDeliveryTrackingOrder.CurrencyEnum": CustomerDeliveryTrackingOrder.CurrencyEnum,
        "DriverStore.PresenceEnum": DriverStore.PresenceEnum,
        "Field.FieldTypeEnum": Field.FieldTypeEnum,
        "FulfillmentInfo.DispatchTypeEnum": FulfillmentInfo.DispatchTypeEnum,
        "GroupReference.GroupTypeEnum": GroupReference.GroupTypeEnum,
        "HomeAction.HomeActionTypeEnum": HomeAction.HomeActionTypeEnum,
        "HydraConfig.PaymentOptionsEnum": HydraConfig.PaymentOptionsEnum,
        "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum": HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum,
        "HydraDeviceDetails.DeviceTypeEnum": HydraDeviceDetails.DeviceTypeEnum,
        "HydraDeviceDetails.StatusEnum": HydraDeviceDetails.StatusEnum,
        "HydraStatus.UserTypeEnum": HydraStatus.UserTypeEnum,
        "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum": KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum": KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum,
        "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum,
        "LightspeedSettings.PriceTypeEnum": LightspeedSettings.PriceTypeEnum,
        "Menu.MenuSectionBehaviourEnum": Menu.MenuSectionBehaviourEnum,
        "Menu.TaxTypeEnum": Menu.TaxTypeEnum,
        "MenuBase.MenuSectionBehaviourEnum": MenuBase.MenuSectionBehaviourEnum,
        "MenuBase.TaxTypeEnum": MenuBase.TaxTypeEnum,
        "MenuCatalogItem.CellLayoutTypeEnum": MenuCatalogItem.CellLayoutTypeEnum,
        "MenuElementEditResponse.MenuElementTypeEnum": MenuElementEditResponse.MenuElementTypeEnum,
        "MenuElementEditResponse.ValidationCodeEnum": MenuElementEditResponse.ValidationCodeEnum,
        "MenuElementHide.MenuElementTypeEnum": MenuElementHide.MenuElementTypeEnum,
        "MenuElementListItemResponse.MenuElementTypeEnum": MenuElementListItemResponse.MenuElementTypeEnum,
        "MenuItemOptionSet.CellLayoutTypeEnum": MenuItemOptionSet.CellLayoutTypeEnum,
        "MenuItemOptionSetBase.CellLayoutTypeEnum": MenuItemOptionSetBase.CellLayoutTypeEnum,
        "MenuItemOptionSetItem.CellLayoutTypeEnum": MenuItemOptionSetItem.CellLayoutTypeEnum,
        "MenuItemOptionSetItemBase.CellLayoutTypeEnum": MenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "MenuSectionAvailability.AvailabilityModeEnum": MenuSectionAvailability.AvailabilityModeEnum,
        "MenuSectionAvailabilityBase.AvailabilityModeEnum": MenuSectionAvailabilityBase.AvailabilityModeEnum,
        "MenuSectionItem.SpicinessRatingEnum": MenuSectionItem.SpicinessRatingEnum,
        "MenuSectionItem.CellLayoutTypeEnum": MenuSectionItem.CellLayoutTypeEnum,
        "MenuSectionItemBase.SpicinessRatingEnum": MenuSectionItemBase.SpicinessRatingEnum,
        "MenuSectionItemBase.CellLayoutTypeEnum": MenuSectionItemBase.CellLayoutTypeEnum,
        "MenuTaxDetails.TaxTypeEnum": MenuTaxDetails.TaxTypeEnum,
        "MetafieldDefinition.OwnerEntityEnum": MetafieldDefinition.OwnerEntityEnum,
        "MetafieldDefinition.ValueTypeEnum": MetafieldDefinition.ValueTypeEnum,
        "MetafieldDefinition.BehaviorsEnum": MetafieldDefinition.BehaviorsEnum,
        "MetafieldDefinitionRecommendation.OwnerEntityEnum": MetafieldDefinitionRecommendation.OwnerEntityEnum,
        "MetafieldDefinitionRecommendation.ValueTypeEnum": MetafieldDefinitionRecommendation.ValueTypeEnum,
        "MetafieldDefinitionRecommendation.BehaviorsEnum": MetafieldDefinitionRecommendation.BehaviorsEnum,
        "OAuthApp.FlowEnum": OAuthApp.FlowEnum,
        "OAuthApp.RefreshTokenUsageEnum": OAuthApp.RefreshTokenUsageEnum,
        "OnboardingItemUpdate.StatusEnum": OnboardingItemUpdate.StatusEnum,
        "Order.DeliveryTypeEnum": Order.DeliveryTypeEnum,
        "Order.PickupLocationTypeEnum": Order.PickupLocationTypeEnum,
        "Order.TableServiceCatagoryEnum": Order.TableServiceCatagoryEnum,
        "Order.PaymentAccountTypeEnum": Order.PaymentAccountTypeEnum,
        "Order.OrderStateEnum": Order.OrderStateEnum,
        "Order.AppTypeEnum": Order.AppTypeEnum,
        "Order.PaymentStatusEnum": Order.PaymentStatusEnum,
        "Order.RejectionReasonEnum": Order.RejectionReasonEnum,
        "Order.DeliveryTrackingStatusEnum": Order.DeliveryTrackingStatusEnum,
        "OrderDeliveryInformation.StatusEnum": OrderDeliveryInformation.StatusEnum,
        "OrderDeliveryInformationBase.StatusEnum": OrderDeliveryInformationBase.StatusEnum,
        "OrderIngestSubmitOrderRequest.AppTypeEnum": OrderIngestSubmitOrderRequest.AppTypeEnum,
        "OrderIngestSubmitOrderRequest.CurrencyCodeEnum": OrderIngestSubmitOrderRequest.CurrencyCodeEnum,
        "OrderIngestSubmitOrderResponse.CurrencyCodeEnum": OrderIngestSubmitOrderResponse.CurrencyCodeEnum,
        "OrderSummary.DeliveryTypeEnum": OrderSummary.DeliveryTypeEnum,
        "OrderSummary.PickupLocationTypeEnum": OrderSummary.PickupLocationTypeEnum,
        "OrderSummary.TableServiceCatagoryEnum": OrderSummary.TableServiceCatagoryEnum,
        "OrderSummary.OrderStateEnum": OrderSummary.OrderStateEnum,
        "OrderSummary.PaymentAccountTypeEnum": OrderSummary.PaymentAccountTypeEnum,
        "OrderSummary.PaymentStatusEnum": OrderSummary.PaymentStatusEnum,
        "OrderSummary.CurrencyEnum": OrderSummary.CurrencyEnum,
        "OrderSummary.AppTypeEnum": OrderSummary.AppTypeEnum,
        "OrderVoucherSummary.TypeEnum": OrderVoucherSummary.TypeEnum,
        "OrderVoucherSummary.SubTypeEnum": OrderVoucherSummary.SubTypeEnum,
        "OwnerEntityConfiguration.OwnerEntityEnum": OwnerEntityConfiguration.OwnerEntityEnum,
        "OwnerEntityConfiguration.AllowedBehaviorsEnum": OwnerEntityConfiguration.AllowedBehaviorsEnum,
        "Payout.PayoutStatusEnum": Payout.PayoutStatusEnum,
        "Payout.PayoutTypeEnum": Payout.PayoutTypeEnum,
        "Payout.CurrencyEnum": Payout.CurrencyEnum,
        "PayoutChargeback.OrderCurrencyEnum": PayoutChargeback.OrderCurrencyEnum,
        "PayoutChargeback.OrderTypeEnum": PayoutChargeback.OrderTypeEnum,
        "PayoutDetail.PayoutStatusEnum": PayoutDetail.PayoutStatusEnum,
        "PayoutDetail.PayoutTypeEnum": PayoutDetail.PayoutTypeEnum,
        "PayoutDetail.CurrencyEnum": PayoutDetail.CurrencyEnum,
        "PayoutOrder.OrderTypeEnum": PayoutOrder.OrderTypeEnum,
        "PayoutOrder.OrderCurrencyEnum": PayoutOrder.OrderCurrencyEnum,
        "PayoutOtherCharge.CurrencyEnum": PayoutOtherCharge.CurrencyEnum,
        "PayoutOtherCharge.ChargeTypeEnum": PayoutOtherCharge.ChargeTypeEnum,
        "PayoutRefund.OrderCurrencyEnum": PayoutRefund.OrderCurrencyEnum,
        "PayoutRefund.OrderTypeEnum": PayoutRefund.OrderTypeEnum,
        "PayoutRequestIds.StatesEnum": PayoutRequestIds.StatesEnum,
        "PayoutSummary.PayoutStatusEnum": PayoutSummary.PayoutStatusEnum,
        "PayoutSummary.CurrencyEnum": PayoutSummary.CurrencyEnum,
        "PhoneCall.CallStatusEnum": PhoneCall.CallStatusEnum,
        "PreOrderConfig.PreOrderTimeDisplayTypeEnum": PreOrderConfig.PreOrderTimeDisplayTypeEnum,
        "ProcessingFeeConfig.PaymentAccountTypeEnum": ProcessingFeeConfig.PaymentAccountTypeEnum,
        "Product.ProductTypeEnum": Product.ProductTypeEnum,
        "Range.DayOfWeekEnum": Range.DayOfWeekEnum,
        "RedeemInvitationResult.InvitationStatusEnum": RedeemInvitationResult.InvitationStatusEnum,
        "Reject.RejectReasonEnum": Reject.RejectReasonEnum,
        "SignupStep.ActionEnum": SignupStep.ActionEnum,
        "StatisticsCurrencyDataPoint.CurrencyEnum": StatisticsCurrencyDataPoint.CurrencyEnum,
        "Store.PrintoutLayoutTypeEnum": Store.PrintoutLayoutTypeEnum,
        "Store.CurrencyEnum": Store.CurrencyEnum,
        "StoreEndOfDayReport.CurrencyEnum": StoreEndOfDayReport.CurrencyEnum,
        "StoreGroup.CurrencyEnum": StoreGroup.CurrencyEnum,
        "StoreGroupBase.CurrencyEnum": StoreGroupBase.CurrencyEnum,
        "StoreGroupExtended.CurrencyEnum": StoreGroupExtended.CurrencyEnum,
        "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum": StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum,
        "StoreOrderCapacityConfig.DeliveryTypeEnum": StoreOrderCapacityConfig.DeliveryTypeEnum,
        "StoreOrderCapacityPeriod.DayOfTheWeekEnum": StoreOrderCapacityPeriod.DayOfTheWeekEnum,
        "StoreSummary.CurrencyEnum": StoreSummary.CurrencyEnum,
        "StripeAccountLinkRequest.CollectEnum": StripeAccountLinkRequest.CollectEnum,
        "StripeAccountLinkRequest.TypeEnum": StripeAccountLinkRequest.TypeEnum,
        "StripeConnectedAccount.CardPaymentsStatusEnum": StripeConnectedAccount.CardPaymentsStatusEnum,
        "StripeConnectedAccount.TransfersStatusEnum": StripeConnectedAccount.TransfersStatusEnum,
        "StripeConnectedAccount.AccountStatusEnum": StripeConnectedAccount.AccountStatusEnum,
        "StripeConnectedAccountInfo.AccountStatusEnum": StripeConnectedAccountInfo.AccountStatusEnum,
        "StripeConnectedAccountInfo.CardPaymentStatusEnum": StripeConnectedAccountInfo.CardPaymentStatusEnum,
        "StuartSettings.PackageTypeEnum": StuartSettings.PackageTypeEnum,
        "StuartSettings.TransportTypeEnum": StuartSettings.TransportTypeEnum,
        "SupportedCountry.AddressLayoutEnum": SupportedCountry.AddressLayoutEnum,
        "SupportedCountry.PostCodeTypeEnum": SupportedCountry.PostCodeTypeEnum,
        "SupportedCountry.SupportRegionEnum": SupportedCountry.SupportRegionEnum,
        "Teammate.InvitationStatusEnum": Teammate.InvitationStatusEnum,
        "Teammate.AppAccessLevelEnum": Teammate.AppAccessLevelEnum,
        "TeammateBase.AppAccessLevelEnum": TeammateBase.AppAccessLevelEnum,
        "UpdateAppStoreApp.ConfigurationTypeEnum": UpdateAppStoreApp.ConfigurationTypeEnum,
        "UpdateAppStoreApp.StoreSelectorTypeEnum": UpdateAppStoreApp.StoreSelectorTypeEnum,
        "UpdateAppStoreApp.TeammateAppAccessLevelEnum": UpdateAppStoreApp.TeammateAppAccessLevelEnum,
        "UpdateAppStoreApp.PermissionsTypeEnum": UpdateAppStoreApp.PermissionsTypeEnum,
        "UpdateAppStoreApp.CategoriesEnum": UpdateAppStoreApp.CategoriesEnum,
        "UpdateAppStoreApp.CountriesEnum": UpdateAppStoreApp.CountriesEnum,
        "UpdateCatalogGroupReference.GroupTypeEnum": UpdateCatalogGroupReference.GroupTypeEnum,
        "UpdateCatalogItemReference.ItemTypeEnum": UpdateCatalogItemReference.ItemTypeEnum,
        "UpdateGroupReference.GroupTypeEnum": UpdateGroupReference.GroupTypeEnum,
        "UpdateMetafieldDefinition.BehaviorsEnum": UpdateMetafieldDefinition.BehaviorsEnum,
        "Voucher.StatusEnum": Voucher.StatusEnum,
        "Voucher.VoucherTypeEnum": Voucher.VoucherTypeEnum,
        "Voucher.VoucherSubTypeEnum": Voucher.VoucherSubTypeEnum,
        "Voucher.CurrencyEnum": Voucher.CurrencyEnum,
        "VoucherSummary.StatusEnum": VoucherSummary.StatusEnum,
        "VoucherSummary.VoucherTypeEnum": VoucherSummary.VoucherTypeEnum,
        "VoucherSummary.VoucherSubTypeEnum": VoucherSummary.VoucherSubTypeEnum,
        "VoucherWithStats.StatusEnum": VoucherWithStats.StatusEnum,
        "VoucherWithStats.VoucherTypeEnum": VoucherWithStats.VoucherTypeEnum,
        "VoucherWithStats.VoucherSubTypeEnum": VoucherWithStats.VoucherSubTypeEnum,
        "VoucherWithStats.CurrencyEnum": VoucherWithStats.CurrencyEnum,
        "WebsiteImage.ImageLocationEnum": WebsiteImage.ImageLocationEnum,
}

let typeMap: {[index: string]: any} = {
    "Accept": Accept,
    "AccountDetail": AccountDetail,
    "AccountDetailBase": AccountDetailBase,
    "AccountFieldDefinition": AccountFieldDefinition,
    "AccountFieldKeyValuePair": AccountFieldKeyValuePair,
    "AccountFieldsDefinitions": AccountFieldsDefinitions,
    "AddItemDetails": AddItemDetails,
    "AddressFormDisplayFormat": AddressFormDisplayFormat,
    "AddressFormResponse": AddressFormResponse,
    "AllMetadataResult": AllMetadataResult,
    "AnalyticsClientEvent": AnalyticsClientEvent,
    "ApmCurrencyDataPoint": ApmCurrencyDataPoint,
    "ApmDataPoint": ApmDataPoint,
    "ApmHourlyDataPoint": ApmHourlyDataPoint,
    "ApmStatistics": ApmStatistics,
    "ApmStatus": ApmStatus,
    "App": App,
    "AppChannelAssignment": AppChannelAssignment,
    "AppCompliance": AppCompliance,
    "AppConfigUpdateModel": AppConfigUpdateModel,
    "AppCreatedEvent": AppCreatedEvent,
    "AppStoreApp": AppStoreApp,
    "AppStoreAppConfiguration": AppStoreAppConfiguration,
    "AppStoreAppConfigurationHeader": AppStoreAppConfigurationHeader,
    "AppStoreAppConfigurationSummary": AppStoreAppConfigurationSummary,
    "AppStoreAppSummary": AppStoreAppSummary,
    "AppStoreConfigCreatedEvent": AppStoreConfigCreatedEvent,
    "AppStoreConfigDeletedEvent": AppStoreConfigDeletedEvent,
    "AppStoreConfigUpdatedEvent": AppStoreConfigUpdatedEvent,
    "AppUpdatedEvent": AppUpdatedEvent,
    "AssignedBankAccount": AssignedBankAccount,
    "BalanceDetails": BalanceDetails,
    "BankAccount": BankAccount,
    "BankAccountCreate": BankAccountCreate,
    "BankAccountCreatedEvent": BankAccountCreatedEvent,
    "BankAccountDeletedEvent": BankAccountDeletedEvent,
    "BankAccountDetail": BankAccountDetail,
    "BankAccountDetailsUpdateRequest": BankAccountDetailsUpdateRequest,
    "BankAccountSummary": BankAccountSummary,
    "BankAccountUpdatedEvent": BankAccountUpdatedEvent,
    "BluetoothTerminalStatus": BluetoothTerminalStatus,
    "BusinessHoursOverride": BusinessHoursOverride,
    "BusinessHoursOverrideBase": BusinessHoursOverrideBase,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "BusinessHoursPeriodBase": BusinessHoursPeriodBase,
    "CampaignStatistics": CampaignStatistics,
    "CardReader": CardReader,
    "CardReaderRegistrationRequest": CardReaderRegistrationRequest,
    "Cart": Cart,
    "CatalogGroup": CatalogGroup,
    "CatalogGroupArchivedEvent": CatalogGroupArchivedEvent,
    "CatalogGroupCreatedEvent": CatalogGroupCreatedEvent,
    "CatalogGroupReference": CatalogGroupReference,
    "CatalogGroupUpdatedEvent": CatalogGroupUpdatedEvent,
    "CatalogImage": CatalogImage,
    "CatalogItem": CatalogItem,
    "CatalogItemArchivedEvent": CatalogItemArchivedEvent,
    "CatalogItemCreatedEvent": CatalogItemCreatedEvent,
    "CatalogItemReference": CatalogItemReference,
    "CatalogItemUpdatedEvent": CatalogItemUpdatedEvent,
    "CertificateCreatedEvent": CertificateCreatedEvent,
    "CertificateRenewedEvent": CertificateRenewedEvent,
    "ChangePasswordModel": ChangePasswordModel,
    "Channel": Channel,
    "ChannelStoreMapping": ChannelStoreMapping,
    "ChargebackDetails": ChargebackDetails,
    "ConfiguredStore": ConfiguredStore,
    "Contact": Contact,
    "Coordinates": Coordinates,
    "CountryWithAccountFieldsDefinitions": CountryWithAccountFieldsDefinitions,
    "CreateAccountModel": CreateAccountModel,
    "CreateAppStoreApp": CreateAppStoreApp,
    "CreateCatalogGroup": CreateCatalogGroup,
    "CreateCatalogGroupReference": CreateCatalogGroupReference,
    "CreateCatalogItem": CreateCatalogItem,
    "CreateCatalogItemReference": CreateCatalogItemReference,
    "CreateFullMenu": CreateFullMenu,
    "CreateFullMenuItemOptionSet": CreateFullMenuItemOptionSet,
    "CreateFullMenuItemOptionSetItem": CreateFullMenuItemOptionSetItem,
    "CreateFullMenuSection": CreateFullMenuSection,
    "CreateFullMenuSectionItem": CreateFullMenuSectionItem,
    "CreateGroupReference": CreateGroupReference,
    "CreateLocation": CreateLocation,
    "CreateLocationArea": CreateLocationArea,
    "CreateMenuSectionItemFromCatalogItems": CreateMenuSectionItemFromCatalogItems,
    "CreateMenuTaxRate": CreateMenuTaxRate,
    "CreateMetadata": CreateMetadata,
    "CreateMetafieldDefinition": CreateMetafieldDefinition,
    "CreateProduct": CreateProduct,
    "CreateTeammate": CreateTeammate,
    "CreateVoucher": CreateVoucher,
    "CreatedMenuSectionItems": CreatedMenuSectionItems,
    "CreditNoteDetails": CreditNoteDetails,
    "CspReport": CspReport,
    "CspReportRequest": CspReportRequest,
    "CurrencyData": CurrencyData,
    "Customer": Customer,
    "CustomerConsentUpdatedEvent": CustomerConsentUpdatedEvent,
    "CustomerCreatedEvent": CustomerCreatedEvent,
    "CustomerDeliveryTrackingOrder": CustomerDeliveryTrackingOrder,
    "CustomerDeliveryTrackingOrderLine": CustomerDeliveryTrackingOrderLine,
    "CustomerSummary": CustomerSummary,
    "CustomerUpdateModel": CustomerUpdateModel,
    "CustomerUpdatedEvent": CustomerUpdatedEvent,
    "DashboardEmbed": DashboardEmbed,
    "DeliveryLocation": DeliveryLocation,
    "DeliveryZone": DeliveryZone,
    "DeliveryZoneBase": DeliveryZoneBase,
    "DeliveryZoneCreatedEvent": DeliveryZoneCreatedEvent,
    "DeliveryZoneDeletedEvent": DeliveryZoneDeletedEvent,
    "DeliveryZoneUpdatedEvent": DeliveryZoneUpdatedEvent,
    "DeviceSettings": DeviceSettings,
    "DnsRecordInformation": DnsRecordInformation,
    "DnsVerifiedEvent": DnsVerifiedEvent,
    "Driver": Driver,
    "DriverInvitation": DriverInvitation,
    "DriverLoginModel": DriverLoginModel,
    "DriverRequestLoginPinModel": DriverRequestLoginPinModel,
    "DriverStore": DriverStore,
    "DynamicFormField": DynamicFormField,
    "DynamicFormFieldOption": DynamicFormFieldOption,
    "DynamicFormRule": DynamicFormRule,
    "DynamicFormRules": DynamicFormRules,
    "EmvNotificationEvent": EmvNotificationEvent,
    "EmvTerminal": EmvTerminal,
    "EmvTerminalWithAssignments": EmvTerminalWithAssignments,
    "EventSearchResult": EventSearchResult,
    "ExternalStoreEvent": ExternalStoreEvent,
    "FeeSummary": FeeSummary,
    "Field": Field,
    "FieldChangeInformation": FieldChangeInformation,
    "FieldGroup": FieldGroup,
    "FlipdishEventBase": FlipdishEventBase,
    "FlipdishFeesDetails": FlipdishFeesDetails,
    "FulfillmentInfo": FulfillmentInfo,
    "GeoPointRequest": GeoPointRequest,
    "GoogleAddress": GoogleAddress,
    "GoogleAddressComponent": GoogleAddressComponent,
    "GoogleAddressResult": GoogleAddressResult,
    "GoogleCoordinates": GoogleCoordinates,
    "GoogleGeometry": GoogleGeometry,
    "GoogleLocation": GoogleLocation,
    "GoogleViewport": GoogleViewport,
    "GroupReference": GroupReference,
    "GroupedCoordinates": GroupedCoordinates,
    "HomeAction": HomeAction,
    "HomeStatistics": HomeStatistics,
    "HttpRequestAndResponseLog": HttpRequestAndResponseLog,
    "HydraAssignedEvent": HydraAssignedEvent,
    "HydraConfig": HydraConfig,
    "HydraConnectionStatusChangedEvent": HydraConnectionStatusChangedEvent,
    "HydraDeviceDetails": HydraDeviceDetails,
    "HydraRegistrationRequest": HydraRegistrationRequest,
    "HydraRequestResetEvent": HydraRequestResetEvent,
    "HydraSettingChangedEvent": HydraSettingChangedEvent,
    "HydraStatus": HydraStatus,
    "HydraStoreAssignedEvent": HydraStoreAssignedEvent,
    "HydraStoreData": HydraStoreData,
    "HydraStoreUnassignedEvent": HydraStoreUnassignedEvent,
    "HydraUnAssignedEvent": HydraUnAssignedEvent,
    "IndexPage": IndexPage,
    "IndexPageBase": IndexPageBase,
    "JobAddress": JobAddress,
    "JobCancellation": JobCancellation,
    "JobContact": JobContact,
    "JobDelivery": JobDelivery,
    "JobDeliveryDetail": JobDeliveryDetail,
    "JobDriver": JobDriver,
    "JobEta": JobEta,
    "JobPricing": JobPricing,
    "JobProof": JobProof,
    "JobResponse": JobResponse,
    "KioskBluetoothInstallUpdateInitiateEvent": KioskBluetoothInstallUpdateInitiateEvent,
    "KioskBluetoothPairingModeEvent": KioskBluetoothPairingModeEvent,
    "KioskBluetoothTerminalCancelUpdateEvent": KioskBluetoothTerminalCancelUpdateEvent,
    "KioskBluetoothTerminalFirmwareVersionStatusEvent": KioskBluetoothTerminalFirmwareVersionStatusEvent,
    "KioskBluetoothTerminalInitiateUpdateCheckEvent": KioskBluetoothTerminalInitiateUpdateCheckEvent,
    "KioskBluetoothTerminalInstallationStatusEvent": KioskBluetoothTerminalInstallationStatusEvent,
    "KioskBluetoothTerminalUnpairedEvent": KioskBluetoothTerminalUnpairedEvent,
    "KioskBluetoothTerminalUpdatedEvent": KioskBluetoothTerminalUpdatedEvent,
    "KioskBluetoothUnpairingModeEvent": KioskBluetoothUnpairingModeEvent,
    "KioskCashPaymentSettings": KioskCashPaymentSettings,
    "KioskCashSetting": KioskCashSetting,
    "KioskIotConnectionParameters": KioskIotConnectionParameters,
    "KioskStoreSettings": KioskStoreSettings,
    "Language": Language,
    "LightspeedSettings": LightspeedSettings,
    "LineItem": LineItem,
    "LineItemOption": LineItemOption,
    "LocalisedTimeZone": LocalisedTimeZone,
    "Location": Location,
    "LocationArea": LocationArea,
    "LocationAreaCreatedEvent": LocationAreaCreatedEvent,
    "LocationAreaLocation": LocationAreaLocation,
    "LocationAreaUpdatedEvent": LocationAreaUpdatedEvent,
    "LocationAreaWithLocations": LocationAreaWithLocations,
    "LocationCreatedEvent": LocationCreatedEvent,
    "LocationDeletedEvent": LocationDeletedEvent,
    "LoginModel": LoginModel,
    "LoginWithPinModel": LoginWithPinModel,
    "LoyaltyCampaign": LoyaltyCampaign,
    "LoyaltyCampaignBase": LoyaltyCampaignBase,
    "LoyaltyCampaignCreatedEvent": LoyaltyCampaignCreatedEvent,
    "LoyaltyCampaignDeletedEvent": LoyaltyCampaignDeletedEvent,
    "LoyaltyCampaignUpdatedEvent": LoyaltyCampaignUpdatedEvent,
    "LumpDiscountDetails": LumpDiscountDetails,
    "MappedLocation": MappedLocation,
    "MaskedPhoneNumber": MaskedPhoneNumber,
    "Menu": Menu,
    "MenuBase": MenuBase,
    "MenuBulkEditEvent": MenuBulkEditEvent,
    "MenuCatalogItem": MenuCatalogItem,
    "MenuCheckpoint": MenuCheckpoint,
    "MenuCheckpointCreatedEvent": MenuCheckpointCreatedEvent,
    "MenuCreatedEvent": MenuCreatedEvent,
    "MenuElementEditResponse": MenuElementEditResponse,
    "MenuElementHide": MenuElementHide,
    "MenuElementListItemResponse": MenuElementListItemResponse,
    "MenuElementListResponse": MenuElementListResponse,
    "MenuItemOptionSet": MenuItemOptionSet,
    "MenuItemOptionSetBase": MenuItemOptionSetBase,
    "MenuItemOptionSetCreatedEvent": MenuItemOptionSetCreatedEvent,
    "MenuItemOptionSetDeletedEvent": MenuItemOptionSetDeletedEvent,
    "MenuItemOptionSetItem": MenuItemOptionSetItem,
    "MenuItemOptionSetItemBase": MenuItemOptionSetItemBase,
    "MenuItemOptionSetItemCreatedEvent": MenuItemOptionSetItemCreatedEvent,
    "MenuItemOptionSetItemDeletedEvent": MenuItemOptionSetItemDeletedEvent,
    "MenuItemOptionSetItemUpdatedEvent": MenuItemOptionSetItemUpdatedEvent,
    "MenuItemOptionSetUpdatedEvent": MenuItemOptionSetUpdatedEvent,
    "MenuObjectDisplayOrders": MenuObjectDisplayOrders,
    "MenuSection": MenuSection,
    "MenuSectionAvailability": MenuSectionAvailability,
    "MenuSectionAvailabilityBase": MenuSectionAvailabilityBase,
    "MenuSectionBase": MenuSectionBase,
    "MenuSectionCreatedEvent": MenuSectionCreatedEvent,
    "MenuSectionDeletedEvent": MenuSectionDeletedEvent,
    "MenuSectionItem": MenuSectionItem,
    "MenuSectionItemBase": MenuSectionItemBase,
    "MenuSectionItemCreatedEvent": MenuSectionItemCreatedEvent,
    "MenuSectionItemDeletedEvent": MenuSectionItemDeletedEvent,
    "MenuSectionItemUpdatedEvent": MenuSectionItemUpdatedEvent,
    "MenuSectionUpdatedEvent": MenuSectionUpdatedEvent,
    "MenuStoreNames": MenuStoreNames,
    "MenuSummary": MenuSummary,
    "MenuTaxDetails": MenuTaxDetails,
    "MenuTaxRate": MenuTaxRate,
    "MenuUpdatedEvent": MenuUpdatedEvent,
    "MenuUploadedEvent": MenuUploadedEvent,
    "Metadata": Metadata,
    "Metafield": Metafield,
    "MetafieldDefinition": MetafieldDefinition,
    "MetafieldDefinitionRecommendation": MetafieldDefinitionRecommendation,
    "OAuthApp": OAuthApp,
    "OAuthTokenModel": OAuthTokenModel,
    "OauthClientRedirectUri": OauthClientRedirectUri,
    "ObjectDisplayOrder": ObjectDisplayOrder,
    "OnboardingItemUpdate": OnboardingItemUpdate,
    "Order": Order,
    "OrderAcceptedEvent": OrderAcceptedEvent,
    "OrderCapacityConfigUpdatedEvent": OrderCapacityConfigUpdatedEvent,
    "OrderCreatedEvent": OrderCreatedEvent,
    "OrderCustomerTrackingCreatedEvent": OrderCustomerTrackingCreatedEvent,
    "OrderDeliveryInformation": OrderDeliveryInformation,
    "OrderDeliveryInformationBase": OrderDeliveryInformationBase,
    "OrderDeliveryTrackingStatusUpdatedEvent": OrderDeliveryTrackingStatusUpdatedEvent,
    "OrderDispatchedEvent": OrderDispatchedEvent,
    "OrderDropOffLocation": OrderDropOffLocation,
    "OrderIdAndSequenceNumber": OrderIdAndSequenceNumber,
    "OrderIngestSubmitOrderRequest": OrderIngestSubmitOrderRequest,
    "OrderIngestSubmitOrderResponse": OrderIngestSubmitOrderResponse,
    "OrderItem": OrderItem,
    "OrderItemOption": OrderItemOption,
    "OrderPaymentInformation": OrderPaymentInformation,
    "OrderRatingUpdatedEvent": OrderRatingUpdatedEvent,
    "OrderRefundedEvent": OrderRefundedEvent,
    "OrderRejectedEvent": OrderRejectedEvent,
    "OrderSummary": OrderSummary,
    "OrderTipUpdatedEvent": OrderTipUpdatedEvent,
    "OrderVoucherSummary": OrderVoucherSummary,
    "OtherChargesDetails": OtherChargesDetails,
    "OwnerEntityConfiguration": OwnerEntityConfiguration,
    "OwnerEntityConfigurations": OwnerEntityConfigurations,
    "PasswordResetModel": PasswordResetModel,
    "PaymentInfo": PaymentInfo,
    "PaymentIntent": PaymentIntent,
    "PaymentTerminalDetails": PaymentTerminalDetails,
    "PaymentTerminalTransactionDetails": PaymentTerminalTransactionDetails,
    "Payout": Payout,
    "PayoutChargeback": PayoutChargeback,
    "PayoutDetail": PayoutDetail,
    "PayoutOrder": PayoutOrder,
    "PayoutOtherCharge": PayoutOtherCharge,
    "PayoutRefund": PayoutRefund,
    "PayoutRequestIds": PayoutRequestIds,
    "PayoutStore": PayoutStore,
    "PayoutSummary": PayoutSummary,
    "PendingMenuChanges": PendingMenuChanges,
    "PercentDiscountDetails": PercentDiscountDetails,
    "PhoneCall": PhoneCall,
    "PhoneCallEndedEvent": PhoneCallEndedEvent,
    "PhoneCallStartedEvent": PhoneCallStartedEvent,
    "PreOrderConfig": PreOrderConfig,
    "PreOrderTime": PreOrderTime,
    "PredefinedAnswer": PredefinedAnswer,
    "Price": Price,
    "Printer": Printer,
    "PrinterAssignedToStoreEvent": PrinterAssignedToStoreEvent,
    "PrinterTurnedOffEvent": PrinterTurnedOffEvent,
    "PrinterTurnedOnEvent": PrinterTurnedOnEvent,
    "PrinterUnassignedFromStoreEvent": PrinterUnassignedFromStoreEvent,
    "ProcessingFeeConfig": ProcessingFeeConfig,
    "Product": Product,
    "PublishMenuChanges": PublishMenuChanges,
    "PushNotificationDeletedEvent": PushNotificationDeletedEvent,
    "PushNotificationRequest": PushNotificationRequest,
    "PushNotificationResponse": PushNotificationResponse,
    "PushNotificationScheduledEvent": PushNotificationScheduledEvent,
    "PushNotificationSentEvent": PushNotificationSentEvent,
    "Range": Range,
    "RedeemInvitationResult": RedeemInvitationResult,
    "Refund": Refund,
    "Reject": Reject,
    "RequestLoginPinModel": RequestLoginPinModel,
    "RequestLoginPinResposne": RequestLoginPinResposne,
    "RequestPasswordResetModel": RequestPasswordResetModel,
    "RequestPasswordResetPinResponse": RequestPasswordResetPinResponse,
    "Response": Response,
    "RestApiArrayResultAllMetadataResult": RestApiArrayResultAllMetadataResult,
    "RestApiArrayResultApmCurrencyDataPoint": RestApiArrayResultApmCurrencyDataPoint,
    "RestApiArrayResultApmDataPoint": RestApiArrayResultApmDataPoint,
    "RestApiArrayResultApmHourlyDataPoint": RestApiArrayResultApmHourlyDataPoint,
    "RestApiArrayResultAppStoreAppConfigurationHeader": RestApiArrayResultAppStoreAppConfigurationHeader,
    "RestApiArrayResultAppStoreAppConfigurationSummary": RestApiArrayResultAppStoreAppConfigurationSummary,
    "RestApiArrayResultBankAccountSummary": RestApiArrayResultBankAccountSummary,
    "RestApiArrayResultBusinessHoursPeriod": RestApiArrayResultBusinessHoursPeriod,
    "RestApiArrayResultChannel": RestApiArrayResultChannel,
    "RestApiArrayResultCountryWithAccountFieldsDefinitions": RestApiArrayResultCountryWithAccountFieldsDefinitions,
    "RestApiArrayResultDeliveryZone": RestApiArrayResultDeliveryZone,
    "RestApiArrayResultDriver": RestApiArrayResultDriver,
    "RestApiArrayResultDriverStore": RestApiArrayResultDriverStore,
    "RestApiArrayResultEmvTerminalWithAssignments": RestApiArrayResultEmvTerminalWithAssignments,
    "RestApiArrayResultHomeAction": RestApiArrayResultHomeAction,
    "RestApiArrayResultKioskCashPaymentSettings": RestApiArrayResultKioskCashPaymentSettings,
    "RestApiArrayResultLocalisedTimeZone": RestApiArrayResultLocalisedTimeZone,
    "RestApiArrayResultLocationAreaLocation": RestApiArrayResultLocationAreaLocation,
    "RestApiArrayResultLocationAreaWithLocations": RestApiArrayResultLocationAreaWithLocations,
    "RestApiArrayResultLoyaltyCampaign": RestApiArrayResultLoyaltyCampaign,
    "RestApiArrayResultMenuCheckpoint": RestApiArrayResultMenuCheckpoint,
    "RestApiArrayResultMenuElementEditResponse": RestApiArrayResultMenuElementEditResponse,
    "RestApiArrayResultMenuElementListResponse": RestApiArrayResultMenuElementListResponse,
    "RestApiArrayResultMenuItemOptionSet": RestApiArrayResultMenuItemOptionSet,
    "RestApiArrayResultMenuItemOptionSetItem": RestApiArrayResultMenuItemOptionSetItem,
    "RestApiArrayResultMenuSection": RestApiArrayResultMenuSection,
    "RestApiArrayResultMenuSectionItem": RestApiArrayResultMenuSectionItem,
    "RestApiArrayResultMenuStoreNames": RestApiArrayResultMenuStoreNames,
    "RestApiArrayResultMenuSummary": RestApiArrayResultMenuSummary,
    "RestApiArrayResultMenuTaxDetails": RestApiArrayResultMenuTaxDetails,
    "RestApiArrayResultMetadata": RestApiArrayResultMetadata,
    "RestApiArrayResultOAuthApp": RestApiArrayResultOAuthApp,
    "RestApiArrayResultOauthClientRedirectUri": RestApiArrayResultOauthClientRedirectUri,
    "RestApiArrayResultPayoutSummary": RestApiArrayResultPayoutSummary,
    "RestApiArrayResultPreOrderTime": RestApiArrayResultPreOrderTime,
    "RestApiArrayResultProcessingFeeConfig": RestApiArrayResultProcessingFeeConfig,
    "RestApiArrayResultRestApiDefaultResponse": RestApiArrayResultRestApiDefaultResponse,
    "RestApiArrayResultRetentionCampaign": RestApiArrayResultRetentionCampaign,
    "RestApiArrayResultStoreChannelAssignment": RestApiArrayResultStoreChannelAssignment,
    "RestApiArrayResultStoreChannelStoreMapping": RestApiArrayResultStoreChannelStoreMapping,
    "RestApiArrayResultStoreListItem": RestApiArrayResultStoreListItem,
    "RestApiArrayResultStoreStatistics": RestApiArrayResultStoreStatistics,
    "RestApiArrayResultSupportedCountry": RestApiArrayResultSupportedCountry,
    "RestApiArrayResultTeammate": RestApiArrayResultTeammate,
    "RestApiArrayResultVoucherDataPoint": RestApiArrayResultVoucherDataPoint,
    "RestApiDefaultResponse": RestApiDefaultResponse,
    "RestApiErrorResult": RestApiErrorResult,
    "RestApiEventSearchPaginationResult": RestApiEventSearchPaginationResult,
    "RestApiForbiddenResult": RestApiForbiddenResult,
    "RestApiIntegerResult": RestApiIntegerResult,
    "RestApiPaginationResultApp": RestApiPaginationResultApp,
    "RestApiPaginationResultAppStoreAppSummary": RestApiPaginationResultAppStoreAppSummary,
    "RestApiPaginationResultBusinessHoursOverride": RestApiPaginationResultBusinessHoursOverride,
    "RestApiPaginationResultCatalogGroup": RestApiPaginationResultCatalogGroup,
    "RestApiPaginationResultCatalogItem": RestApiPaginationResultCatalogItem,
    "RestApiPaginationResultHttpRequestAndResponseLog": RestApiPaginationResultHttpRequestAndResponseLog,
    "RestApiPaginationResultHydraDeviceDetails": RestApiPaginationResultHydraDeviceDetails,
    "RestApiPaginationResultMetafieldDefinition": RestApiPaginationResultMetafieldDefinition,
    "RestApiPaginationResultMetafieldDefinitionRecommendation": RestApiPaginationResultMetafieldDefinitionRecommendation,
    "RestApiPaginationResultOAuthTokenModel": RestApiPaginationResultOAuthTokenModel,
    "RestApiPaginationResultOrder": RestApiPaginationResultOrder,
    "RestApiPaginationResultOrderSummary": RestApiPaginationResultOrderSummary,
    "RestApiPaginationResultPayout": RestApiPaginationResultPayout,
    "RestApiPaginationResultPayoutChargeback": RestApiPaginationResultPayoutChargeback,
    "RestApiPaginationResultPayoutOrder": RestApiPaginationResultPayoutOrder,
    "RestApiPaginationResultPayoutOtherCharge": RestApiPaginationResultPayoutOtherCharge,
    "RestApiPaginationResultPayoutRefund": RestApiPaginationResultPayoutRefund,
    "RestApiPaginationResultPendingMenuChanges": RestApiPaginationResultPendingMenuChanges,
    "RestApiPaginationResultPhoneCall": RestApiPaginationResultPhoneCall,
    "RestApiPaginationResultProduct": RestApiPaginationResultProduct,
    "RestApiPaginationResultPushNotificationResponse": RestApiPaginationResultPushNotificationResponse,
    "RestApiPaginationResultStore": RestApiPaginationResultStore,
    "RestApiPaginationResultStoreGroup": RestApiPaginationResultStoreGroup,
    "RestApiPaginationResultStoreGroupExtended": RestApiPaginationResultStoreGroupExtended,
    "RestApiPaginationResultStoreHeader": RestApiPaginationResultStoreHeader,
    "RestApiPaginationResultStoreValidationConfig": RestApiPaginationResultStoreValidationConfig,
    "RestApiPaginationResultVoucherSummary": RestApiPaginationResultVoucherSummary,
    "RestApiPaginationResultWebhookLog": RestApiPaginationResultWebhookLog,
    "RestApiPaginationResultWebhookSubscription": RestApiPaginationResultWebhookSubscription,
    "RestApiResultAccountDetail": RestApiResultAccountDetail,
    "RestApiResultAccountFieldsDefinitions": RestApiResultAccountFieldsDefinitions,
    "RestApiResultAddressFormResponse": RestApiResultAddressFormResponse,
    "RestApiResultApmStatistics": RestApiResultApmStatistics,
    "RestApiResultApmStatus": RestApiResultApmStatus,
    "RestApiResultApp": RestApiResultApp,
    "RestApiResultAppChannelAssignment": RestApiResultAppChannelAssignment,
    "RestApiResultAppCompliance": RestApiResultAppCompliance,
    "RestApiResultAppStoreApp": RestApiResultAppStoreApp,
    "RestApiResultAppStoreAppConfiguration": RestApiResultAppStoreAppConfiguration,
    "RestApiResultAssignedBankAccount": RestApiResultAssignedBankAccount,
    "RestApiResultBankAccountDetail": RestApiResultBankAccountDetail,
    "RestApiResultBluetoothTerminalStatus": RestApiResultBluetoothTerminalStatus,
    "RestApiResultBusinessHoursOverride": RestApiResultBusinessHoursOverride,
    "RestApiResultBusinessHoursPeriod": RestApiResultBusinessHoursPeriod,
    "RestApiResultCardReader": RestApiResultCardReader,
    "RestApiResultCatalogGroup": RestApiResultCatalogGroup,
    "RestApiResultCatalogItem": RestApiResultCatalogItem,
    "RestApiResultChannel": RestApiResultChannel,
    "RestApiResultCoordinates": RestApiResultCoordinates,
    "RestApiResultCreatedMenuSectionItems": RestApiResultCreatedMenuSectionItems,
    "RestApiResultCustomer": RestApiResultCustomer,
    "RestApiResultDeliveryZone": RestApiResultDeliveryZone,
    "RestApiResultDnsRecordInformation": RestApiResultDnsRecordInformation,
    "RestApiResultDriver": RestApiResultDriver,
    "RestApiResultHomeStatistics": RestApiResultHomeStatistics,
    "RestApiResultHydraConfig": RestApiResultHydraConfig,
    "RestApiResultHydraDeviceDetails": RestApiResultHydraDeviceDetails,
    "RestApiResultHydraStatus": RestApiResultHydraStatus,
    "RestApiResultIndexPage": RestApiResultIndexPage,
    "RestApiResultIndexPageBase": RestApiResultIndexPageBase,
    "RestApiResultJobResponse": RestApiResultJobResponse,
    "RestApiResultKioskCashSetting": RestApiResultKioskCashSetting,
    "RestApiResultKioskIotConnectionParameters": RestApiResultKioskIotConnectionParameters,
    "RestApiResultKioskStoreSettings": RestApiResultKioskStoreSettings,
    "RestApiResultLightspeedSettings": RestApiResultLightspeedSettings,
    "RestApiResultLocationArea": RestApiResultLocationArea,
    "RestApiResultLocationAreaLocation": RestApiResultLocationAreaLocation,
    "RestApiResultLocationAreaWithLocations": RestApiResultLocationAreaWithLocations,
    "RestApiResultLoyaltyCampaign": RestApiResultLoyaltyCampaign,
    "RestApiResultMappedLocation": RestApiResultMappedLocation,
    "RestApiResultMenu": RestApiResultMenu,
    "RestApiResultMenuItemOptionSet": RestApiResultMenuItemOptionSet,
    "RestApiResultMenuItemOptionSetItem": RestApiResultMenuItemOptionSetItem,
    "RestApiResultMenuSection": RestApiResultMenuSection,
    "RestApiResultMenuSectionAvailability": RestApiResultMenuSectionAvailability,
    "RestApiResultMenuSectionItem": RestApiResultMenuSectionItem,
    "RestApiResultMetadata": RestApiResultMetadata,
    "RestApiResultMetafieldDefinition": RestApiResultMetafieldDefinition,
    "RestApiResultOAuthApp": RestApiResultOAuthApp,
    "RestApiResultOauthClientRedirectUri": RestApiResultOauthClientRedirectUri,
    "RestApiResultOrder": RestApiResultOrder,
    "RestApiResultOrderDeliveryInformation": RestApiResultOrderDeliveryInformation,
    "RestApiResultOrderIngestSubmitOrderResponse": RestApiResultOrderIngestSubmitOrderResponse,
    "RestApiResultOrderPaymentInformation": RestApiResultOrderPaymentInformation,
    "RestApiResultPaymentIntent": RestApiResultPaymentIntent,
    "RestApiResultPaymentTerminalDetails": RestApiResultPaymentTerminalDetails,
    "RestApiResultPaymentTerminalTransactionDetails": RestApiResultPaymentTerminalTransactionDetails,
    "RestApiResultPreOrderConfig": RestApiResultPreOrderConfig,
    "RestApiResultProcessingFeeConfig": RestApiResultProcessingFeeConfig,
    "RestApiResultProduct": RestApiResultProduct,
    "RestApiResultPushNotificationResponse": RestApiResultPushNotificationResponse,
    "RestApiResultRedeemInvitationResult": RestApiResultRedeemInvitationResult,
    "RestApiResultRetentionCampaign": RestApiResultRetentionCampaign,
    "RestApiResultServiceCharge": RestApiResultServiceCharge,
    "RestApiResultStore": RestApiResultStore,
    "RestApiResultStoreAddress": RestApiResultStoreAddress,
    "RestApiResultStoreChannelAssignment": RestApiResultStoreChannelAssignment,
    "RestApiResultStoreEndOfDayReport": RestApiResultStoreEndOfDayReport,
    "RestApiResultStoreGroup": RestApiResultStoreGroup,
    "RestApiResultStoreGroupBase": RestApiResultStoreGroupBase,
    "RestApiResultStoreKioskSettings": RestApiResultStoreKioskSettings,
    "RestApiResultStoreOrderCapacityConfig": RestApiResultStoreOrderCapacityConfig,
    "RestApiResultStripeConnectedAccount": RestApiResultStripeConnectedAccount,
    "RestApiResultStripeTerminalConnectionToken": RestApiResultStripeTerminalConnectionToken,
    "RestApiResultStripeTerminalLocation": RestApiResultStripeTerminalLocation,
    "RestApiResultStripeTerminalPrivateKey": RestApiResultStripeTerminalPrivateKey,
    "RestApiResultStuartSettings": RestApiResultStuartSettings,
    "RestApiResultTeammate": RestApiResultTeammate,
    "RestApiResultTelemetrySeriesResult": RestApiResultTelemetrySeriesResult,
    "RestApiResultTipConfiguration": RestApiResultTipConfiguration,
    "RestApiResultVoucherWithStats": RestApiResultVoucherWithStats,
    "RestApiResultWebsiteImage": RestApiResultWebsiteImage,
    "RestApiResultWebsiteTestimonial": RestApiResultWebsiteTestimonial,
    "RestApiStringArrayResult": RestApiStringArrayResult,
    "RestApiStringResult": RestApiStringResult,
    "RestApiUnauthorizedResult": RestApiUnauthorizedResult,
    "RetentionCampaign": RetentionCampaign,
    "RetentionCampaignBase": RetentionCampaignBase,
    "RetentionCampaignCreatedEvent": RetentionCampaignCreatedEvent,
    "RetentionCampaignDeletedEvent": RetentionCampaignDeletedEvent,
    "RetentionCampaignUpdatedEvent": RetentionCampaignUpdatedEvent,
    "RevenueAdjustmentsDetails": RevenueAdjustmentsDetails,
    "RevenueDetail": RevenueDetail,
    "SearchCriteria": SearchCriteria,
    "ServiceCharge": ServiceCharge,
    "SetPasswordWithPinModel": SetPasswordWithPinModel,
    "Setting": Setting,
    "SignupStep": SignupStep,
    "SmsInfo": SmsInfo,
    "SmsReceivedEvent": SmsReceivedEvent,
    "StatisticsCurrencyDataPoint": StatisticsCurrencyDataPoint,
    "Store": Store,
    "StoreAddress": StoreAddress,
    "StoreAddressBase": StoreAddressBase,
    "StoreAddressForm": StoreAddressForm,
    "StoreAddressUpdatedEvent": StoreAddressUpdatedEvent,
    "StoreArchivedEvent": StoreArchivedEvent,
    "StoreBase": StoreBase,
    "StoreBusinessHoursOverrideCreatedEvent": StoreBusinessHoursOverrideCreatedEvent,
    "StoreBusinessHoursOverrideDeletedEvent": StoreBusinessHoursOverrideDeletedEvent,
    "StoreCampaignStartTime": StoreCampaignStartTime,
    "StoreChannelAssignment": StoreChannelAssignment,
    "StoreChannelStoreMapping": StoreChannelStoreMapping,
    "StoreCloneSettings": StoreCloneSettings,
    "StoreConfig": StoreConfig,
    "StoreCreateBase": StoreCreateBase,
    "StoreCreatedEvent": StoreCreatedEvent,
    "StoreDataPoint": StoreDataPoint,
    "StoreDeletedEvent": StoreDeletedEvent,
    "StoreEndOfDayReport": StoreEndOfDayReport,
    "StoreGroup": StoreGroup,
    "StoreGroupBase": StoreGroupBase,
    "StoreGroupCreatedEvent": StoreGroupCreatedEvent,
    "StoreGroupDeletedEvent": StoreGroupDeletedEvent,
    "StoreGroupExtended": StoreGroupExtended,
    "StoreGroupUpdatedEvent": StoreGroupUpdatedEvent,
    "StoreHeader": StoreHeader,
    "StoreItemHeader": StoreItemHeader,
    "StoreKioskSetting": StoreKioskSetting,
    "StoreKioskSettingModel": StoreKioskSettingModel,
    "StoreKioskSettingUpdatedEvent": StoreKioskSettingUpdatedEvent,
    "StoreKioskSettings": StoreKioskSettings,
    "StoreListItem": StoreListItem,
    "StoreLogoCreatedEvent": StoreLogoCreatedEvent,
    "StoreLogoDeletedEvent": StoreLogoDeletedEvent,
    "StoreLogoUpdatedEvent": StoreLogoUpdatedEvent,
    "StoreMenuAssignedEvent": StoreMenuAssignedEvent,
    "StoreNote": StoreNote,
    "StoreOpeningHoursUpdatedEvent": StoreOpeningHoursUpdatedEvent,
    "StoreOrderCapacityConfig": StoreOrderCapacityConfig,
    "StoreOrderCapacityConfigEditModel": StoreOrderCapacityConfigEditModel,
    "StoreOrderCapacityPeriod": StoreOrderCapacityPeriod,
    "StorePreOrderConfigUpdatedEvent": StorePreOrderConfigUpdatedEvent,
    "StorePublishedEvent": StorePublishedEvent,
    "StoreServiceChargeUpdatedEvent": StoreServiceChargeUpdatedEvent,
    "StoreStatistics": StoreStatistics,
    "StoreSummary": StoreSummary,
    "StoreTipUpdatedEvent": StoreTipUpdatedEvent,
    "StoreUnarchivedEvent": StoreUnarchivedEvent,
    "StoreUnpublishedEvent": StoreUnpublishedEvent,
    "StoreUpdatedEvent": StoreUpdatedEvent,
    "StoreValidationConfig": StoreValidationConfig,
    "StripeAccountLinkRequest": StripeAccountLinkRequest,
    "StripeConnectedAccount": StripeConnectedAccount,
    "StripeConnectedAccountInfo": StripeConnectedAccountInfo,
    "StripeTerminalConnectionToken": StripeTerminalConnectionToken,
    "StripeTerminalLocation": StripeTerminalLocation,
    "StripeTerminalPrivateKey": StripeTerminalPrivateKey,
    "StuartSettings": StuartSettings,
    "StuartSettingsTransportPrices": StuartSettingsTransportPrices,
    "SupportedCountry": SupportedCountry,
    "Teammate": Teammate,
    "TeammateBase": TeammateBase,
    "TeammateDeletedEvent": TeammateDeletedEvent,
    "TeammateInviteAcceptedEvent": TeammateInviteAcceptedEvent,
    "TeammateInviteSentEvent": TeammateInviteSentEvent,
    "TeammateUpdatedEvent": TeammateUpdatedEvent,
    "TelemetrySeriesProperty": TelemetrySeriesProperty,
    "TelemetrySeriesQueryParameters": TelemetrySeriesQueryParameters,
    "TelemetrySeriesResult": TelemetrySeriesResult,
    "TipConfiguration": TipConfiguration,
    "UnRegisterCardReaderRequest": UnRegisterCardReaderRequest,
    "UpdateAppStoreApp": UpdateAppStoreApp,
    "UpdateAppStoreAppConfiguration": UpdateAppStoreAppConfiguration,
    "UpdateAppStoreAppConfigurationWebhookDTO": UpdateAppStoreAppConfigurationWebhookDTO,
    "UpdateCatalogGroup": UpdateCatalogGroup,
    "UpdateCatalogGroupReference": UpdateCatalogGroupReference,
    "UpdateCatalogItem": UpdateCatalogItem,
    "UpdateCatalogItemReference": UpdateCatalogItemReference,
    "UpdateDriverNotificationToken": UpdateDriverNotificationToken,
    "UpdateDriverProfileModel": UpdateDriverProfileModel,
    "UpdateGroupReference": UpdateGroupReference,
    "UpdateLocationArea": UpdateLocationArea,
    "UpdateMetafieldDefinition": UpdateMetafieldDefinition,
    "UpdateProduct": UpdateProduct,
    "UpdateTipConfiguration": UpdateTipConfiguration,
    "UserAnsweredSignupQuestionsEvent": UserAnsweredSignupQuestionsEvent,
    "UserCreatedEvent": UserCreatedEvent,
    "UserDeletedEvent": UserDeletedEvent,
    "UserEventInfo": UserEventInfo,
    "UserLoginEvent": UserLoginEvent,
    "UserPasswordCreatedEvent": UserPasswordCreatedEvent,
    "UserUpdatedEvent": UserUpdatedEvent,
    "ValidValue": ValidValue,
    "ValidationErrorResult": ValidationErrorResult,
    "Voucher": Voucher,
    "VoucherBase": VoucherBase,
    "VoucherCreatedEvent": VoucherCreatedEvent,
    "VoucherDataPoint": VoucherDataPoint,
    "VoucherDeletedEvent": VoucherDeletedEvent,
    "VoucherSummary": VoucherSummary,
    "VoucherUpdatedEvent": VoucherUpdatedEvent,
    "VoucherWithStats": VoucherWithStats,
    "WebhookEventSample": WebhookEventSample,
    "WebhookLog": WebhookLog,
    "WebhookSubscription": WebhookSubscription,
    "WebhookSubscriptionCreatedEvent": WebhookSubscriptionCreatedEvent,
    "WebhookSubscriptionDeletedEvent": WebhookSubscriptionDeletedEvent,
    "WebhookSubscriptionEventInfo": WebhookSubscriptionEventInfo,
    "WebhookSubscriptionUpdatedEvent": WebhookSubscriptionUpdatedEvent,
    "WebsiteImage": WebsiteImage,
    "WebsiteTestimonial": WebsiteTestimonial,
    "WebsiteTestimonialBase": WebsiteTestimonialBase,
    "WebsiteUpdatedEvent": WebsiteUpdatedEvent,
    "WebsiteVanityUrlUpdatedEvent": WebsiteVanityUrlUpdatedEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Answer a signup question
     * @param signupStepAction Signup step action
     * @param answerId Identifier of the answer
     * @param {*} [options] Override http request options.
     */
    public answerSignUpQuestion (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', answerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerId, "number")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePassword (changePasswordModel: ChangePasswordModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "ChangePasswordModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePasswordWithPin (changePasswordModel: SetPasswordWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "SetPasswordWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create account with email address and store name
     * @param createAccountModel Create account model
     * @param {*} [options] Override http request options.
     */
    public createAccount (createAccountModel: CreateAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAccountModel, "CreateAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current account detail
     * @param {*} [options] Override http request options.
     */
    public getAccountDetails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get timezones localised to users language
     * @param {*} [options] Override http request options.
     */
    public getLocalisedTimeZones (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocalisedTimeZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public login (loginModel: LoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public loginWithPin (loginModel: LoginWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log out. It removes Flipdish authorization Cookie.
     * @param {*} [options] Override http request options.
     */
    public logout (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset password with token.
     * @param passwordResetModel Password reset model
     * @param {*} [options] Override http request options.
     */
    public passwordResetWithToken (passwordResetModel: PasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordResetModel, "PasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request login PIN. The server sends the PIN to the email address.
     * @param requestLoginPinRequest Request login PIN request
     * @param {*} [options] Override http request options.
     */
    public requestLoginPin (requestLoginPinRequest: RequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestLoginPinRequest, "RequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestLoginPinResposne");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request password reset. Flipdish system will send a token via email.
     * @param requestPasswordResetModel Request password reset model
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (requestPasswordResetModel: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetModel, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request Password Reset PIN. The server sends the PIN to the email address.
     * @param requestPasswordResetRequest 
     * @param {*} [options] Override http request options.
     */
    public sendPinForPasswordReset (requestPasswordResetRequest: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestPasswordResetPinResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/resetpin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetRequest' is not null or undefined
        if (requestPasswordResetRequest === null || requestPasswordResetRequest === undefined) {
            throw new Error('Required parameter requestPasswordResetRequest was null or undefined when calling sendPinForPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetRequest, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestPasswordResetPinResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestPasswordResetPinResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Skip a signup question
     * @param signupStepAction Signup step action
     * @param {*} [options] Override http request options.
     */
    public skipSignupStep (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update account with name and language
     * @param updateAccountModel Update account model
     * @param {*} [options] Override http request options.
     */
    public updateAccount (updateAccountModel: AccountDetailBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAccountModel, "AccountDetailBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddressApiApiKeys {
}

export class AddressApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddressApiApiKeys, value: string) {
        (this.authentications as any)[AddressApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Provides a dyamic form definition based for the country of the given appId, with labels localized using the provided language.
     * @param appId Application (WhiteLabel) Id (WhiteLabelId or AppNameId).
     * @param language (Optional) ISO culture info code, e.g.: en-IE, the default is en-US.
     * @param {*} [options] Override http request options.
     */
    public formByApp (appId: string, language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/app/{appId}/address/form'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling formByApp.');
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Provides a dyamic form definition for the given country code, with labels localized using the provided language.
     * @param countryCode The 2 letter ISO country code, e.g.: IE.
     * @param language (Optional) ISO culture info code, e.g.: en-IE, the default is en-US.
     * @param {*} [options] Override http request options.
     */
    public formByCountry (countryCode: string, language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/address/country/{countryCode}/form'
            .replace('{' + 'countryCode' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling formByCountry.');
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Maps a Google Address Object to the values of the dynamic form associated with the address country and returns the dynamic form.
     * @param googleAddress A Google address object, as it is retuned from the maps API.
     * @param {*} [options] Override http request options.
     */
    public formatGoogleAddress (googleAddress: GoogleAddress, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/address/google';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'googleAddress' is not null or undefined
        if (googleAddress === null || googleAddress === undefined) {
            throw new Error('Required parameter googleAddress was null or undefined when calling formatGoogleAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(googleAddress, "GoogleAddress")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        (this.authentications as any)[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Returns true if APM is enabled on at least one store in an application
     * @param appId App Id
     * @param {*} [options] Override http request options.
     */
    public getApmStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApmStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Basic Statistics
     * @param appId App Id
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calendar statistics
     * @param appId App Id
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmHourlyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calls Statistics
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCallsStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Order Statistics (Value of Orders)
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getOrderStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmCurrencyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get paginated APM call list
     * @param appId App Id
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPhoneCall");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreApiApiKeys {
}

export class AppStoreApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * App store app must be verified or you are the owner [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get App store app
     * @param appStoreAppId App store app id
     * @param {*} [options] Override http request options.
     */
    public getAppStoreApp (appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppStoreApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/appstore/apps/{appStoreAppId}'
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppStoreApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppStoreApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only returns verified applications [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get list of App store app summaries
     * @param search Query App store app name
     * @param page Requested page index
     * @param limit Requested page limit
     * @param excludeNotOwned Exclude App store apps that user is not the owner off
     * @param {*} [options] Override http request options.
     */
    public getAppStoreApps (search: string, page?: number, limit?: number, excludeNotOwned?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultAppStoreAppSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/appstore/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getAppStoreApps.');
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (excludeNotOwned !== undefined) {
            localVarQueryParameters['excludeNotOwned'] = ObjectSerializer.serialize(excludeNotOwned, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultAppStoreAppSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultAppStoreAppSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreConfigurationsApiApiKeys {
}

export class AppStoreConfigurationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreConfigurationsApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreConfigurationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system] This adds an Application to a Whitelabel that can later be configured to specific stores
     * @summary Create App store app configuration
     * @param appId App id
     * @param appStoreAppId App store app id
     * @param {*} [options] Override http request options.
     */
    public createAppStoreConfig (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling createAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreAppConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Delete App store app configuration
     * @param appId App id
     * @param appStoreAppId App store app id
     * @param configId App store app configuration id
     * @param {*} [options] Override http request options.
     */
    public deleteAppStoreConfig (appId: string, appStoreAppId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling deleteAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling deleteAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get App store app configuration
     * @param appId App id
     * @param appStoreAppId App store app id
     * @param configId App store app configuration id
     * @param {*} [options] Override http request options.
     */
    public getAppStoreConfig (appId: string, appStoreAppId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppStoreAppConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling getAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppStoreAppConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppStoreAppConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [ALPHA - this endpoint is not ready to be consumed]
     * @summary Get list of App store app configurations for one App store app
     * @param appId App id
     * @param appStoreAppId App store app id
     * @param {*} [options] Override http request options.
     */
    public getConfiguredAppSingleApp (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getConfiguredAppSingleApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getConfiguredAppSingleApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAppStoreAppConfigurationSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [ALPHA - this endpoint is not ready to be consumed]
     * @summary Get list of App store apps which have been configured
     * @param appId App id
     * @param {*} [options] Override http request options.
     */
    public getConfiguredApps (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getConfiguredApps.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAppStoreAppConfigurationHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update App store app configuration
     * @param appId App id
     * @param appStoreAppId App store app id
     * @param configId App store app configuration id
     * @param updateAppStoreAppConfiguration Update App store app configuration
     * @param {*} [options] Override http request options.
     */
    public updateAppStoreConfig (appId: string, appStoreAppId: string, configId: string, updateAppStoreAppConfiguration: UpdateAppStoreAppConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'updateAppStoreAppConfiguration' is not null or undefined
        if (updateAppStoreAppConfiguration === null || updateAppStoreAppConfiguration === undefined) {
            throw new Error('Required parameter updateAppStoreAppConfiguration was null or undefined when calling updateAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAppStoreAppConfiguration, "UpdateAppStoreAppConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreDeveloperApiApiKeys {
}

export class AppStoreDeveloperApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreDeveloperApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreDeveloperApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system][Note: Only Flipdish staff can verify apps]
     * @summary Update App store app verification
     * @param oauthAppId OAuth App identifier
     * @param appStoreAppId App store app id
     * @param verificationStatus New verification status
     * @param {*} [options] Override http request options.
     */
    public appVerificationUpdate (oauthAppId: string, appStoreAppId: string, verificationStatus: 'Draft' | 'Submitted' | 'Verified', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/verification'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling appVerificationUpdate.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling appVerificationUpdate.');
        }

        // verify required parameter 'verificationStatus' is not null or undefined
        if (verificationStatus === null || verificationStatus === undefined) {
            throw new Error('Required parameter verificationStatus was null or undefined when calling appVerificationUpdate.');
        }

        if (verificationStatus !== undefined) {
            localVarQueryParameters['verificationStatus'] = ObjectSerializer.serialize(verificationStatus, "'Draft' | 'Submitted' | 'Verified'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create App store app
     * @param oauthAppId OAuth App identifier
     * @param createAppStoreApp App store app
     * @param {*} [options] Override http request options.
     */
    public createAppStoreApp (oauthAppId: string, createAppStoreApp: CreateAppStoreApp, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createAppStoreApp.');
        }

        // verify required parameter 'createAppStoreApp' is not null or undefined
        if (createAppStoreApp === null || createAppStoreApp === undefined) {
            throw new Error('Required parameter createAppStoreApp was null or undefined when calling createAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAppStoreApp, "CreateAppStoreApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Delete App store app
     * @param oauthAppId OAuth App identifier
     * @param appStoreAppId App store app id
     * @param {*} [options] Override http request options.
     */
    public deleteAppStoreApp (oauthAppId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteAppStoreApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling deleteAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update App store app
     * @param oauthAppId OAuth App identifier
     * @param appStoreAppId App store app id
     * @param appStoreApp Update App store app
     * @param {*} [options] Override http request options.
     */
    public updateAppStoreApp (oauthAppId: string, appStoreAppId: string, appStoreApp: UpdateAppStoreApp, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateAppStoreApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateAppStoreApp.');
        }

        // verify required parameter 'appStoreApp' is not null or undefined
        if (appStoreApp === null || appStoreApp === undefined) {
            throw new Error('Required parameter appStoreApp was null or undefined when calling updateAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appStoreApp, "UpdateAppStoreApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload the App store app logo \\ icon
     * @param oauthAppId OAuth App identifier
     * @param appStoreAppId App store app id
     * @param Image App Store App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppStoreAppLogo (oauthAppId: string, appStoreAppId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/logo'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling uploadAppStoreAppLogo.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling uploadAppStoreAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppStoreAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        (this.authentications as any)[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get the application configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A domain might be ready but still need 10 minutes to work properly because of HAProxy.
     * @summary Get the application hostname DNS delegation states for A and CNAME records.
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getAppHostnameStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostnamestatus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppHostnameStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDnsRecordInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Apps
     * @param nameFilter 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getApps (nameFilter?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (nameFilter !== undefined) {
            localVarQueryParameters['nameFilter'] = ObjectSerializer.serialize(nameFilter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the application compliance configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getCompliance (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCompliance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get panacea vanity url. This sets the URL which the Panacea website is available at. ie. my.flipdish.com/[vanityurl]
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getPanaceaVanityUrl (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPanaceaVanityUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all supported countries.
     * @param {*} [options] Override http request options.
     */
    public getSupportedCountries (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/supportedcountries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultSupportedCountry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Is panacea vanity url available
     * @param vanityUrl Vanity url to check
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public isPanaceaVanityUrlAvailable (vanityUrl: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url/available'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application configuration
     * @param appId Application identifier
     * @param appConfigUpdate Changes to the configuration
     * @param {*} [options] Override http request options.
     */
    public setAppConfig (appId: string, appConfigUpdate: AppConfigUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppConfig.');
        }

        // verify required parameter 'appConfigUpdate' is not null or undefined
        if (appConfigUpdate === null || appConfigUpdate === undefined) {
            throw new Error('Required parameter appConfigUpdate was null or undefined when calling setAppConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appConfigUpdate, "AppConfigUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no subdomain is specified in {hostname} 'www' will be prepended.
     * @summary Set the application hostname.
     * @param appId Application identifier.
     * @param hostname The new Hostname.
     * @param isEmbed Will the website be embedded
     * @param {*} [options] Override http request options.
     */
    public setAppHostname (appId: string, hostname: string, isEmbed?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostname'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppHostname.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling setAppHostname.');
        }

        if (hostname !== undefined) {
            localVarQueryParameters['hostname'] = ObjectSerializer.serialize(hostname, "string");
        }

        if (isEmbed !== undefined) {
            localVarQueryParameters['isEmbed'] = ObjectSerializer.serialize(isEmbed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application languages
     * @param appId Application identifier
     * @param languages New list of languages
     * @param {*} [options] Override http request options.
     */
    public setAppLanguages (appId: string, languages: Array<Language>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config/languages'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppLanguages.');
        }

        // verify required parameter 'languages' is not null or undefined
        if (languages === null || languages === undefined) {
            throw new Error('Required parameter languages was null or undefined when calling setAppLanguages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(languages, "Array<Language>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application compliance configuration
     * @param appId Application identifier
     * @param complianceType Compliance type
     * @param {*} [options] Override http request options.
     */
    public setCompliance (appId: string, complianceType: 'Default' | 'GdprCompliance', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setCompliance.');
        }

        // verify required parameter 'complianceType' is not null or undefined
        if (complianceType === null || complianceType === undefined) {
            throw new Error('Required parameter complianceType was null or undefined when calling setCompliance.');
        }

        if (complianceType !== undefined) {
            localVarQueryParameters['complianceType'] = ObjectSerializer.serialize(complianceType, "'Default' | 'GdprCompliance'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Set panacea vanity url
     * @param appId Application identifier.
     * @param vanityUrl Vanity url
     * @param {*} [options] Override http request options.
     */
    public setPanaceaVanityUrl (appId: string, vanityUrl: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setPanaceaVanityUrl.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling setPanaceaVanityUrl.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application logo \\ icon
     * @param appId Application identifier
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppLogo (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/logo'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get authorization tokens
     * @param oauthAppId Client identifier
     * @param appId 
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOAuthTokenModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke token
     * @param key Token identifier key
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public revokeToken (key: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Attach Bank Account to Store
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param storeId Store to be attached to Bank account
     * @param {*} [options] Override http request options.
     */
    public attachBankAccountToStore (appId: string, bankAccountId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Bank Account and attach to this App
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete BankAccount
     * @param appId App Name
     * @param bankAccountId Id of account to be marked as deleted
     * @param {*} [options] Override http request options.
     */
    public deleteBankAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling deleteBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get BankAccount Detail by Id
     * @param bankAccountId Id of account
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccountById (bankAccountId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getBankAccountById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get List of BankAccounts for WL
     * @param appId App Name
     * @param {*} [options] Override http request options.
     */
    public getBankAccounts (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBankAccountSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get bank account fields definitions
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCountriesWithFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/countries-field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCountriesWithFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultCountryWithAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get bank account fields definitions
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update BankAccount
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param account Details to update account with
     * @param {*} [options] Override http request options.
     */
    public updateBankAccount (appId: string, bankAccountId: number, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update State of Bank Account
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param state New state
     * @param reason Reason for state change, Mandatory for rejections
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountState (appId: string, bankAccountId: number, state: string, reason: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/state/{state}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling updateBankAccountState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reason, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates loyalty campaign
     * @param appId App Name Id
     * @param campaign Loyalty campaign details
     * @param {*} [options] Override http request options.
     */
    public createLoyaltyCampaign (appId: string, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates retention campaign
     * @param appId App Name Id
     * @param campaign Retention campaign details
     * @param {*} [options] Override http request options.
     */
    public createRetentionCampaign (appId: string, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets loyalty campaigns for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets loyalty campaigns for store
     * @param appId App Name Id
     * @param storeId Store Id
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets retention campaigns for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets retention campaigns for store
     * @param appId App Name Id
     * @param storeId Store Id
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets list of stores for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getStoreList (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreListItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a campaign
     * @param appId App Name Id
     * @param campaignId Campaign Id
     * @param {*} [options] Override http request options.
     */
    public removeCampaign (appId: string, campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates loyalty campaign
     * @param appId App Name Id
     * @param campaignId Loyalty campaign Id
     * @param campaign Loyalty campaign details
     * @param {*} [options] Override http request options.
     */
    public updateLoyaltyCampaign (appId: string, campaignId: number, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates retention campaign
     * @param appId App Name Id
     * @param campaignId Retention campaign Id
     * @param campaign Retention campaign details
     * @param {*} [options] Override http request options.
     */
    public updateRetentionCampaign (appId: string, campaignId: number, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardReadersApiApiKeys {
}

export class CardReadersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardReadersApiApiKeys, value: string) {
        (this.authentications as any)[CardReadersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Authorization Key for Stripe Terminal
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public authorizeStripeTerminal (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/authorize'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling authorizeStripeTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalPrivateKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Cancel currently initiated install update for bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public cancelCurrentlyInitiatedBluetoothDeviceUpdate (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/cancelUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Can only be called by Kiosk
     * @summary Cancel terminals action
     * @param readerId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelReaderAction (readerId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/{readerId}/cancel_action'
            .replace('{' + 'readerId' + '}', encodeURIComponent(String(readerId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'readerId' is not null or undefined
        if (readerId === null || readerId === undefined) {
            throw new Error('Required parameter readerId was null or undefined when calling cancelReaderAction.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelReaderAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Location ID for Stripe Terminal
     * @param geoPointRequest 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public generateStripeTerminalLocation (geoPointRequest: GeoPointRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/location'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'geoPointRequest' is not null or undefined
        if (geoPointRequest === null || geoPointRequest === undefined) {
            throw new Error('Required parameter geoPointRequest was null or undefined when calling generateStripeTerminalLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling generateStripeTerminalLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(geoPointRequest, "GeoPointRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the status of the bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getBluetoothTerminalStatus (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBluetoothTerminalStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Can only be called by Kiosk
     * @summary Get Connection Token For a Stripe Terminal
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getStripeConnectionToken (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalConnectionToken;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/connectiontoken'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStripeConnectionToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalConnectionToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalConnectionToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Trigger check for Bluetooth device update on Kiosk
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateBluetoothTerminalDeviceUpdateCheck (appId: string, deviceId: string, terminalType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/checkForUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Initiate stripe terminal pairing mode
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothPairingMode (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/pair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Initiate Kiosk Update Install for bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothUpdateInstall (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/installUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public registerStripeTerminal (request: CardReaderRegistrationRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/register'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling registerStripeTerminal.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling registerStripeTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CardReaderRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Can only be called by Kiosk
     * @summary Un-register terminal by deleting it from stripe
     * @param request 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public unRegisterTerminal (request: UnRegisterCardReaderRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/unregister'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling unRegisterTerminal.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unRegisterTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UnRegisterCardReaderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Unpair the currently paired stripe terminal
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unpairCurrentlyPairedBluetoothDevice (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/unpair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogChangesApiApiKeys {
}

export class CatalogChangesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogChangesApiApiKeys, value: string) {
        (this.authentications as any)[CatalogChangesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get menu pending changes from Catalog groups and items
     * @param appId 
     * @param menuId 
     * @param catalogElementId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPendingMenuChanges (appId: string, menuId?: number, catalogElementId?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPendingMenuChanges;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/catalog-changes'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPendingMenuChanges.');
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (catalogElementId !== undefined) {
            localVarQueryParameters['catalogElementId'] = ObjectSerializer.serialize(catalogElementId, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPendingMenuChanges;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPendingMenuChanges");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update menus with the pending changes from Catalog groups and items
     * @param appId 
     * @param publishMenuChanges 
     * @param {*} [options] Override http request options.
     */
    public publishPendingMenuChanges (appId: string, publishMenuChanges: PublishMenuChanges, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/catalog-changes/publish'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling publishPendingMenuChanges.');
        }

        // verify required parameter 'publishMenuChanges' is not null or undefined
        if (publishMenuChanges === null || publishMenuChanges === undefined) {
            throw new Error('Required parameter publishMenuChanges was null or undefined when calling publishPendingMenuChanges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(publishMenuChanges, "PublishMenuChanges")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogGroupsApiApiKeys {
}

export class CatalogGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogGroupsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveGroup (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Catalog Group
     * @param appId 
     * @param createCatalogGroup 
     * @param {*} [options] Override http request options.
     */
    public createCatalogGroup (appId: string, createCatalogGroup: CreateCatalogGroup, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createCatalogGroup.');
        }

        // verify required parameter 'createCatalogGroup' is not null or undefined
        if (createCatalogGroup === null || createCatalogGroup === undefined) {
            throw new Error('Required parameter createCatalogGroup was null or undefined when calling createCatalogGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createCatalogGroup, "CreateCatalogGroup")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCatalogGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateGroup (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get group by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getGroupById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CatalogGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getGroupById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getGroupById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CatalogGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated groups by app name id filtered by types
     * @param appId 
     * @param groupTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getGroups (appId: string, groupTypes: Array<'ModifierGroup'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getGroups.');
        }

        // verify required parameter 'groupTypes' is not null or undefined
        if (groupTypes === null || groupTypes === undefined) {
            throw new Error('Required parameter groupTypes was null or undefined when calling getGroups.');
        }

        if (groupTypes !== undefined) {
            localVarQueryParameters['groupTypes'] = ObjectSerializer.serialize(groupTypes, "Array<'ModifierGroup'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultCatalogGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param updateCatalogGroup 
     * @param {*} [options] Override http request options.
     */
    public updateGroup (appId: string, catalogItemId: string, updateCatalogGroup: UpdateCatalogGroup, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'updateCatalogGroup' is not null or undefined
        if (updateCatalogGroup === null || updateCatalogGroup === undefined) {
            throw new Error('Required parameter updateCatalogGroup was null or undefined when calling updateGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCatalogGroup, "UpdateCatalogGroup")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogImagesApiApiKeys {
}

export class CatalogImagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogImagesApiApiKeys, value: string) {
        (this.authentications as any)[CatalogImagesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Upload a Catalog Image
     * @param appId 
     * @param Image Catalog image
     * @param {*} [options] Override http request options.
     */
    public uploadCatalogImage (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CatalogImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/images'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadCatalogImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadCatalogImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CatalogImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogItemsApiApiKeys {
}

export class CatalogItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogItemsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveCatalogItem (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Catalog Item
     * @param appId 
     * @param createCatalogItem 
     * @param {*} [options] Override http request options.
     */
    public createCatalogItem (appId: string, createCatalogItem: CreateCatalogItem, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createCatalogItem.');
        }

        // verify required parameter 'createCatalogItem' is not null or undefined
        if (createCatalogItem === null || createCatalogItem === undefined) {
            throw new Error('Required parameter createCatalogItem was null or undefined when calling createCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createCatalogItem, "CreateCatalogItem")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateCatalogItem (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get item by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getCatalogItemById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCatalogItemById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getCatalogItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated items by app name id filtered by types
     * @param appId 
     * @param itemTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getItems (appId: string, itemTypes: Array<'Product' | 'Modifier'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getItems.');
        }

        // verify required parameter 'itemTypes' is not null or undefined
        if (itemTypes === null || itemTypes === undefined) {
            throw new Error('Required parameter itemTypes was null or undefined when calling getItems.');
        }

        if (itemTypes !== undefined) {
            localVarQueryParameters['itemTypes'] = ObjectSerializer.serialize(itemTypes, "Array<'Product' | 'Modifier'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultCatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param updateCatalogItem 
     * @param {*} [options] Override http request options.
     */
    public updateCatalogItem (appId: string, catalogItemId: string, updateCatalogItem: UpdateCatalogItem, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateCatalogItem.');
        }

        // verify required parameter 'updateCatalogItem' is not null or undefined
        if (updateCatalogItem === null || updateCatalogItem === undefined) {
            throw new Error('Required parameter updateCatalogItem was null or undefined when calling updateCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCatalogItem, "UpdateCatalogItem")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogProductsApiApiKeys {
}

export class CatalogProductsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogProductsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogProductsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Product
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveProduct (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Product
     * @param appId 
     * @param createProduct 
     * @param {*} [options] Override http request options.
     */
    public createProduct (appId: string, createProduct: CreateProduct, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProduct;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createProduct.');
        }

        // verify required parameter 'createProduct' is not null or undefined
        if (createProduct === null || createProduct === undefined) {
            throw new Error('Required parameter createProduct was null or undefined when calling createProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createProduct, "CreateProduct")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProduct;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProduct");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Product
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateProduct (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Product by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getProductById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Product;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getProductById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getProductById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Product;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Product");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated products by app name id filtered by types
     * @param appId 
     * @param productTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getProducts (appId: string, productTypes: Array<'Product' | 'Modifier'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultProduct;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getProducts.');
        }

        // verify required parameter 'productTypes' is not null or undefined
        if (productTypes === null || productTypes === undefined) {
            throw new Error('Required parameter productTypes was null or undefined when calling getProducts.');
        }

        if (productTypes !== undefined) {
            localVarQueryParameters['productTypes'] = ObjectSerializer.serialize(productTypes, "Array<'Product' | 'Modifier'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultProduct;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultProduct");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Product
     * @param appId 
     * @param catalogItemId 
     * @param updateProduct 
     * @param {*} [options] Override http request options.
     */
    public updateProduct (appId: string, catalogItemId: string, updateProduct: UpdateProduct, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateProduct.');
        }

        // verify required parameter 'updateProduct' is not null or undefined
        if (updateProduct === null || updateProduct === undefined) {
            throw new Error('Required parameter updateProduct was null or undefined when calling updateProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateProduct, "UpdateProduct")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelsApiApiKeys {
}

export class ChannelsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChannelsApiApiKeys, value: string) {
        (this.authentications as any)[ChannelsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Assign a given AppId to a Sales Channel
     * @param appId Application Id (AppNameIdxxx)
     * @param channelId Channel Id (123, 456)
     * @param {*} [options] Override http request options.
     */
    public assignAppIdToSalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/assign-appId'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignAppIdToSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling assignAppIdToSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign a Store to a Sales Channel
     * @param storeId Store Id (123, 456)
     * @param appId AppId (AppNameIdxxx)
     * @param channelId Channel Id (123, 456)
     * @param {*} [options] Override http request options.
     */
    public assignStoreToChannel (storeId: number, appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/assign-store'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignStoreToChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignStoreToChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling assignStoreToChannel.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Attachs the specified store to the given sales channel.
     * @param appId Application Id (AppNameId)
     * @param channelId Type of sales channel (Android, IOS, Web, etc.)
     * @param storeId Store Id (Phyisical Restaurant) to attach.
     * @param {*} [options] Override http request options.
     */
    public attachStoreToSalesChannel (appId: string, channelId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling attachStoreToSalesChannel.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Detaches all the stores from the given sales channel.
     * @param appId Application Id (AppNameId)
     * @param channelId Type of sales channel (Android, IOS, Web, etc.)
     * @param {*} [options] Override http request options.
     */
    public detachAllStoresFromSalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachAllStoresFromSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling detachAllStoresFromSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Detaches the specified store from the given sales channel.
     * @param appId Application Id (AppNameId)
     * @param channelId Type of sales channel (Android, IOS, Web, etc.)
     * @param storeId Store Id (Phyisical Restaurant) to detach.
     * @param {*} [options] Override http request options.
     */
    public detachStoreFromSalesChannel (appId: string, channelId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of sales channels that are assigned to a given AppId
     * @param appId Application Id (AppNameIdxxx)
     * @param {*} [options] Override http request options.
     */
    public getAssignedChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/assigned-channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAssignedChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of sales channels that are not yet assigned to a given AppId
     * @param appId Application Id (AppNameIdxxx)
     * @param {*} [options] Override http request options.
     */
    public getAvailableChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/available-channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAvailableChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a Sales Channel by Id.
     * @param id ChannelId
     * @param appId AppId
     * @param {*} [options] Override http request options.
     */
    public getChannel (id: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of enabled Channels
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of stores of an AppId that are assigned to a given Sales Channel
     * @param appId Application Id (AppNameId)
     * @param channelId Sales channel (Android, IOS, Web, etc.)
     * @param {*} [options] Override http request options.
     */
    public getStoresAssignedToChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelAssignment;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/assigned-stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresAssignedToChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling getStoresAssignedToChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelAssignment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelAssignment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of store ids attached to the given channel type for the specified app.
     * @param appId Application Id (AppNameId)
     * @param channelId Type of sales channel (Android, IOS, Web, etc.)
     * @param {*} [options] Override http request options.
     */
    public getStoresBySalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Response;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresBySalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling getStoresBySalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unassign a Store from a Sales Channel
     * @param storeId Store Id (123, 456)
     * @param appId AppId (AppNameIdxxx)
     * @param channelId Channel Id (123, 456)
     * @param {*} [options] Override http request options.
     */
    public unassignStoreFromChannel (storeId: number, appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/unassign-store'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unassignStoreFromChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignStoreFromChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling unassignStoreFromChannel.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelsStoreMappingApiApiKeys {
}

export class ChannelsStoreMappingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChannelsStoreMappingApiApiKeys, value: string) {
        (this.authentications as any)[ChannelsStoreMappingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public channelsGetStoreChannelStoreMapping (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/storemappings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling channelsGetStoreChannelStoreMapping.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling channelsGetStoreChannelStoreMapping.');
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelStoreMapping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public channelsSetStoreChannelStoreMapping (appId: string, channelId: number, stores: Array<ChannelStoreMapping>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/storemappings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        // verify required parameter 'stores' is not null or undefined
        if (stores === null || stores === undefined) {
            throw new Error('Required parameter stores was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stores, "Array<ChannelStoreMapping>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelStoreMapping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentSecurityPolicyApiApiKeys {
}

export class ContentSecurityPolicyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentSecurityPolicyApiApiKeys, value: string) {
        (this.authentications as any)[ContentSecurityPolicyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public contentSecurityPolicyReport (request: CspReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/csp/report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling contentSecurityPolicyReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CspReportRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomersApiApiKeys {
}

export class CustomersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomersApiApiKeys, value: string) {
        (this.authentications as any)[CustomersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer of an app by Id
     * @param appId App Name Id
     * @param customerId Customer Id
     * @param {*} [options] Override http request options.
     */
    public getCustomerById (appId: string, customerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update customer of an app by Id
     * @param appId App Name Id
     * @param customerId Customer Id
     * @param updateCustomer Updated customer information
     * @param {*} [options] Override http request options.
     */
    public updateCustomerById (appId: string, customerId: number, updateCustomer: CustomerUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'updateCustomer' is not null or undefined
        if (updateCustomer === null || updateCustomer === undefined) {
            throw new Error('Required parameter updateCustomer was null or undefined when calling updateCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCustomer, "CustomerUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryTrackingApiApiKeys {
}

export class DeliveryTrackingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryTrackingApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryTrackingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Assign driver to order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrder (appId: string, orderId: number, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders/{orderId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign driver to multiple orders
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param orderIdAndSequenceNumbers Array of object containing OrderId and Sequence
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrders (appId: string, driverId: number, orderIdAndSequenceNumbers: Array<OrderIdAndSequenceNumber>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'orderIdAndSequenceNumbers' is not null or undefined
        if (orderIdAndSequenceNumbers === null || orderIdAndSequenceNumbers === undefined) {
            throw new Error('Required parameter orderIdAndSequenceNumbers was null or undefined when calling assignDriverToOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderIdAndSequenceNumbers, "Array<OrderIdAndSequenceNumber>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Get drivers by App
     * @param appId Application identifier
     * @param name Driver&#39;s username
     * @param phoneNumber Driver&#39;s phone number
     * @param storeId Store Id
     * @param presence Offline/Online
     * @param {*} [options] Override http request options.
     */
    public getDrivers (appId: string, name?: string, phoneNumber?: string, storeId?: number, presence?: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getDrivers.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (presence !== undefined) {
            localVarQueryParameters['presence'] = ObjectSerializer.serialize(presence, "'Offline' | 'Online'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Invite driver
     * @param appId Application identifier
     * @param driverInvitation Driver invitation model
     * @param {*} [options] Override http request options.
     */
    public inviteDriverToApp (appId: string, driverInvitation: DriverInvitation, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling inviteDriverToApp.');
        }

        // verify required parameter 'driverInvitation' is not null or undefined
        if (driverInvitation === null || driverInvitation === undefined) {
            throw new Error('Required parameter driverInvitation was null or undefined when calling inviteDriverToApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverInvitation, "DriverInvitation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from app
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public removeDriverFromApp (appId: string, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeDriverFromApp.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling removeDriverFromApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param {*} [options] Override http request options.
     */
    public unassignDriverFromOrder (appId: string, orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/{orderId}/driver'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignDriverFromOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling unassignDriverFromOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a delivery zone to the store id
     * @param storeId Store Id to which the delivery zone will be added
     * @param deliveryZoneBase Optional delivery zone, if not supplied will create a default zone
     * @param {*} [options] Override http request options.
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZoneBase, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the delivery zones associated with a store
     * @param storeId Store Id to which the delivery zones are associated
     * @param {*} [options] Override http request options.
     */
    public getDeliveryZones (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be removed
     * @param {*} [options] Override http request options.
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be updated
     * @param deliveryZone Delta of delivery zone parameters that need to be changed
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZone, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DriversApiApiKeys {
}

export class DriversApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DriversApiApiKeys, value: string) {
        (this.authentications as any)[DriversApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add driver token
     * @param updateDriverToken 
     * @param {*} [options] Override http request options.
     */
    public addDriverNotificationToken (updateDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverToken' is not null or undefined
        if (updateDriverToken === null || updateDriverToken === undefined) {
            throw new Error('Required parameter updateDriverToken was null or undefined when calling addDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver profile image
     * @param {*} [options] Override http request options.
     */
    public deleteDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Login with phone number and pin
     * @param driverLoginModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverLogin (driverLoginModel: DriverLoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverLoginModel' is not null or undefined
        if (driverLoginModel === null || driverLoginModel === undefined) {
            throw new Error('Required parameter driverLoginModel was null or undefined when calling driverLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverLoginModel, "DriverLoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Request an SMS to be sent to the driver with their login code
     * @param driverRequestLoginPinModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverRequestLoginCodeSms (driverRequestLoginPinModel: DriverRequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverRequestLoginPinModel' is not null or undefined
        if (driverRequestLoginPinModel === null || driverRequestLoginPinModel === undefined) {
            throw new Error('Required parameter driverRequestLoginPinModel was null or undefined when calling driverRequestLoginCodeSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverRequestLoginPinModel, "DriverRequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get driver profile
     * @param {*} [options] Override http request options.
     */
    public getDriverProfile (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores for driver
     * @param {*} [options] Override http request options.
     */
    public getStoresForDriver (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/assignedstores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDriverStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver token
     * @param removeDriverToken 
     * @param {*} [options] Override http request options.
     */
    public removeDriverNotificationToken (removeDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'removeDriverToken' is not null or undefined
        if (removeDriverToken === null || removeDriverToken === undefined) {
            throw new Error('Required parameter removeDriverToken was null or undefined when calling removeDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param presence 
     * @param {*} [options] Override http request options.
     */
    public setDriverPresenceForStore (storeId: number, presence: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/stores/{storeId}/presence/{presence}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'presence' + '}', encodeURIComponent(String(presence)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setDriverPresenceForStore.');
        }

        // verify required parameter 'presence' is not null or undefined
        if (presence === null || presence === undefined) {
            throw new Error('Required parameter presence was null or undefined when calling setDriverPresenceForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set driver profile image and returns it's url
     * @param {*} [options] Override http request options.
     */
    public setDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ...
     * @summary Change delivery tracking status and return the updated status.
     * @param orderId Order identifier
     * @param deliveryTrackingStatus 
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryTrackingStatus (orderId: number, deliveryTrackingStatus: 'Unassigned' | 'Unaccepted' | 'Accepted' | 'Carrying' | 'OnTheWay' | 'ArrivedAtLocation' | 'Delivered' | 'CannotDeliver', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/tracking/{deliveryTrackingStatus}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'deliveryTrackingStatus' + '}', encodeURIComponent(String(deliveryTrackingStatus)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        // verify required parameter 'deliveryTrackingStatus' is not null or undefined
        if (deliveryTrackingStatus === null || deliveryTrackingStatus === undefined) {
            throw new Error('Required parameter deliveryTrackingStatus was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update driver profile
     * @param updateDriverProfile Update the driver profile (i.e Name)
     * @param {*} [options] Override http request options.
     */
    public updateDriverProfile (updateDriverProfile: UpdateDriverProfileModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverProfile' is not null or undefined
        if (updateDriverProfile === null || updateDriverProfile === undefined) {
            throw new Error('Required parameter updateDriverProfile was null or undefined when calling updateDriverProfile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverProfile, "UpdateDriverProfileModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer events  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events  For technical reasons, the number of records returned is limited to 100.
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getEvents (whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event by Id  For technical reasons, the number of records returned is limited to 100.
     * @param eventId Event identifier (Guid)
     * @param {*} [options] Override http request options.
     */
    public getEventsById (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu events  For technical reasons, the number of records returned is limited to 100.
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events  For technical reasons, the number of records returned is limited to 100.
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId2 !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId2, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events by customer  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store events  For technical reasons, the number of records returned is limited to 100.
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user events  For technical reasons, the number of records returned is limited to 100.
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId2?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId2 !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId2, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get WhiteLabel events  For technical reasons, the number of records returned is limited to 100.
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FilesApiApiKeys {
}

export class FilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FilesApiApiKeys, value: string) {
        (this.authentications as any)[FilesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get file from storage
     * @param appId 
     * @param fileId 
     * @param {*} [options] Override http request options.
     */
    public downloadFile (appId: string, fileId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/files/download/{fileId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling downloadFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling downloadFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        (this.authentications as any)[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headHostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headPing (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public hostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        (this.authentications as any)[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param appId App Name Id
     * @param homeActionId Id of the action
     * @param isDismissed 
     * @param {*} [options] Override http request options.
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'homeActionId' + '}', encodeURIComponent(String(homeActionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            localVarQueryParameters['isDismissed'] = ObjectSerializer.serialize(isDismissed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param {*} [options] Override http request options.
     */
    public dismissOldPortalAction (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/home/dismissoldportalaction';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Actions
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeActions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultHomeAction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Statistics
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeStatistics (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHomeStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get API interaction logs
     * @param start Start date time
     * @param end End date time
     * @param appId 
     * @param filterByUserId User id (optional)
     * @param guid Id of the log
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, guid?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHttpRequestAndResponseLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        (this.authentications as any)[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Assign an EMV terminal to a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param emvTerminalId 
     * @param {*} [options] Override http request options.
     */
    public assignEmv (appId: string, hydraConfigId: number, emvTerminalId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/assign/{hydraConfigId}/{emvTerminalId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)))
            .replace('{' + 'emvTerminalId' + '}', encodeURIComponent(String(emvTerminalId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'emvTerminalId' is not null or undefined
        if (emvTerminalId === null || emvTerminalId === undefined) {
            throw new Error('Required parameter emvTerminalId was null or undefined when calling assignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param storeId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToKiosk (appId: string, storeId: number, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/AttachStoreToKiosk/{deviceId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToKiosk.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToKiosk.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToKiosk.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/attach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelEmvPayment (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/cancelemvpayment/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelEmvPayment.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelEmvPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public detachStoreFromTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/detach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceType 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevice (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevice.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getAttachedDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraDeviceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraDeviceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceType 
     * @param pageIndex 
     * @param pageSize 
     * @param storeId 
     * @param deviceName 
     * @param deviceSerial 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevices (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', pageIndex?: number, pageSize?: number, storeId?: number, deviceName?: string, deviceSerial?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/list'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevices.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevices.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (deviceName !== undefined) {
            localVarQueryParameters['deviceName'] = ObjectSerializer.serialize(deviceName, "string");
        }

        if (deviceSerial !== undefined) {
            localVarQueryParameters['deviceSerial'] = ObjectSerializer.serialize(deviceSerial, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHydraDeviceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEMVTerminalDetails (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEMVTerminalDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEmvOrderState (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvorderstate/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmvOrderState.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEmvOrderState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalTransactionDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the status of Cash Payment Methon on Kisok
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getKioskCashPaymentSettings (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskcashsettings/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultKioskCashPaymentSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRegistration (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param {*} [options] Override http request options.
     */
    public getSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param emv 
     * @param {*} [options] Override http request options.
     */
    public hydraCreateEmv (appId: string, emv: EmvTerminal, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraCreateEmv.');
        }

        // verify required parameter 'emv' is not null or undefined
        if (emv === null || emv === undefined) {
            throw new Error('Required parameter emv was null or undefined when calling hydraCreateEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emv, "EmvTerminal")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public hydraDeleteEmv (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDeleteEmv.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hydraDeleteEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param storeId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public hydraDetachStoreFromKiosk (appId: string, storeId: number, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/DetachStoreFromKiosk/{deviceId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List EMV terminals belonging to the given AppNameId
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public hydraGetEmvsForAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraGetEmvsForAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultEmvTerminalWithAssignments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param deviceId 
     * @param hydraUserType 
     * @param serialNumber 
     * @param {*} [options] Override http request options.
     */
    public loginWithDeviceId (deviceId: string, hydraUserType?: 'Kiosk' | 'Terminal' | 'LegacyPrinter', serialNumber?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling loginWithDeviceId.');
        }

        if (hydraUserType !== undefined) {
            localVarQueryParameters['hydraUserType'] = ObjectSerializer.serialize(hydraUserType, "'Kiosk' | 'Terminal' | 'LegacyPrinter'");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serialNumber'] = ObjectSerializer.serialize(serialNumber, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param hydraRegistration 
     * @param {*} [options] Override http request options.
     */
    public register (appId: string, hydraRegistration: HydraRegistrationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling register.');
        }

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hydraRegistration, "HydraRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unAssign (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unAssign.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unAssign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unassign the currently assigned EMV terminal from a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param {*} [options] Override http request options.
     */
    public unassignEmv (appId: string, hydraConfigId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/unassign/{hydraConfigId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling unassignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update the Cash Payment Methon Visiability on Kisok
     * @param appId 
     * @param deviceId 
     * @param isCashEnabled 
     * @param {*} [options] Override http request options.
     */
    public updateKioskCashVisibilitySettings (appId: string, deviceId: string, isCashEnabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskupdatecashsettings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'isCashEnabled' is not null or undefined
        if (isCashEnabled === null || isCashEnabled === undefined) {
            throw new Error('Required parameter isCashEnabled was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (isCashEnabled !== undefined) {
            localVarQueryParameters['isCashEnabled'] = ObjectSerializer.serialize(isCashEnabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KioskIotApiApiKeys {
}

export class KioskIotApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KioskIotApiApiKeys, value: string) {
        (this.authentications as any)[KioskIotApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the IoT connection parameters for telemetry and commands  No input parameters since authenticated hydra user defines context
     * @param {*} [options] Override http request options.
     */
    public getKioskIotConnection (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }> {
        const localVarPath = this.basePath + '/api/v1.0/kioskiot/connect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskIotConnectionParameters");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the IoT time series values for a given Kiosk Id, properties and time range
     * @param appId 
     * @param queryParams 
     * @param {*} [options] Override http request options.
     */
    public queryTelemetrySeries (appId: string, queryParams: TelemetrySeriesQueryParameters, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTelemetrySeriesResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskiot/timeseries/query'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling queryTelemetrySeries.');
        }

        // verify required parameter 'queryParams' is not null or undefined
        if (queryParams === null || queryParams === undefined) {
            throw new Error('Required parameter queryParams was null or undefined when calling queryTelemetrySeries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(queryParams, "TelemetrySeriesQueryParameters")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTelemetrySeriesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTelemetrySeriesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KioskStoreSettingsApiApiKeys {
}

export class KioskStoreSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KioskStoreSettingsApiApiKeys, value: string) {
        (this.authentications as any)[KioskStoreSettingsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get all kiosk settings associated with a store
     * @param storeId Store identifier
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getAllKioskSettingsForStore (storeId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreKioskSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kiosksettings/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllKioskSettingsForStore.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAllKioskSettingsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreKioskSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreKioskSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [For Kiosk use only] Get all stores connected to a Kiosk
     * @param {*} [options] Override http request options.
     */
    public getAllStoreSettingsForKioskHydra (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskStoreSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/kioskstoresettings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskStoreSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskStoreSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param isCashEnabled 
     * @param {*} [options] Override http request options.
     */
    public updateCashSettingForKiosk (appId: string, deviceId: string, isCashEnabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskCashSetting;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kiosksettings/cash'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCashSettingForKiosk.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateCashSettingForKiosk.');
        }

        // verify required parameter 'isCashEnabled' is not null or undefined
        if (isCashEnabled === null || isCashEnabled === undefined) {
            throw new Error('Required parameter isCashEnabled was null or undefined when calling updateCashSettingForKiosk.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (isCashEnabled !== undefined) {
            localVarQueryParameters['isCashEnabled'] = ObjectSerializer.serialize(isCashEnabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskCashSetting;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskCashSetting");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        (this.authentications as any)[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGenerateMenu (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGetStoreSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param lightspeedSettings 
     * @param {*} [options] Override http request options.
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: LightspeedSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lightspeedSettings, "LightspeedSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationApiApiKeys {
}

export class LocationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationApiApiKeys, value: string) {
        (this.authentications as any)[LocationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a Location i.e: Table, Hotel Room, Car park space
     * @param createLocationInput Input data for creating the Location
     * @param locationAreaId Id of the Location area where the Location belongs
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public createLocation (createLocationInput: Array<CreateLocation>, locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createLocationInput' is not null or undefined
        if (createLocationInput === null || createLocationInput === undefined) {
            throw new Error('Required parameter createLocationInput was null or undefined when calling createLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createLocationInput, "Array<CreateLocation>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set a Location as deleted
     * @param locationId Id of the Location that will be moved
     * @param locationAreaId Id of the Location Area that the Location belong
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public deleteLocation (locationId: number, locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/delete'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set or unset External Location Id on a Location
     * @param locationId Id of the Location that will be mapped
     * @param locationAreaId Id of the Location Area that the Location belong
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param externalLocationId External Id to be mapped to the location
     * @param {*} [options] Override http request options.
     */
    public mapLocationToExternalId (locationId: number, locationAreaId: number, appId: string, storeId: number, externalLocationId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMappedLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/map-external'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling mapLocationToExternalId.');
        }

        if (externalLocationId !== undefined) {
            localVarQueryParameters['externalLocationId'] = ObjectSerializer.serialize(externalLocationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMappedLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMappedLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Move a Location to a different location Area
     * @param locationId Id of the Location that will be moved
     * @param locationAreaId Id of the new Location area that it should be moved to
     * @param newLocationAreaId Id of the new Location area that it should be moved to
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public moveLocation (locationId: number, locationAreaId: number, newLocationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/move'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'newLocationAreaId' is not null or undefined
        if (newLocationAreaId === null || newLocationAreaId === undefined) {
            throw new Error('Required parameter newLocationAreaId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling moveLocation.');
        }

        if (newLocationAreaId !== undefined) {
            localVarQueryParameters['newLocationAreaId'] = ObjectSerializer.serialize(newLocationAreaId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a Location i.e: Table, Hotel Room, Car park space
     * @param updateLocationInput Input data for updating the Location
     * @param locationAreaId Id of the Location area where the Location belongs
     * @param locationId Id of the Location to be updated
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public updateLocation (updateLocationInput: CreateLocation, locationAreaId: number, locationId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/update'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateLocationInput' is not null or undefined
        if (updateLocationInput === null || updateLocationInput === undefined) {
            throw new Error('Required parameter updateLocationInput was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateLocationInput, "CreateLocation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationAreaLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationAreasApiApiKeys {
}

export class LocationAreasApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationAreasApiApiKeys, value: string) {
        (this.authentications as any)[LocationAreasApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a Location Area, i.e: Room, Floor, Parking lot
     * @param locationAreaInput Input data for creating the Location Area
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public createLocationArea (locationAreaInput: CreateLocationArea, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaInput' is not null or undefined
        if (locationAreaInput === null || locationAreaInput === undefined) {
            throw new Error('Required parameter locationAreaInput was null or undefined when calling createLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locationAreaInput, "CreateLocationArea")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a Location Area
     * @param locationAreaId Id of the Location Area
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public getLocationArea (locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaWithLocations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling getLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaWithLocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationAreaWithLocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve all Location Areas for a Store
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param {*} [options] Override http request options.
     */
    public getLocationAreasForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocationAreaWithLocations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLocationAreasForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLocationAreasForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocationAreaWithLocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocationAreaWithLocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a Location Area, i.e: Room, Floor, Car park space
     * @param locationAreaInput Input data for updating the Location Area
     * @param appId AppId i.e: (fd1234)
     * @param storeId Id of the Store
     * @param locationAreaId 
     * @param {*} [options] Override http request options.
     */
    public updateLocationArea (locationAreaInput: UpdateLocationArea, appId: string, storeId: number, locationAreaId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationArea;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/update'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaInput' is not null or undefined
        if (locationAreaInput === null || locationAreaInput === undefined) {
            throw new Error('Required parameter locationAreaInput was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling updateLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locationAreaInput, "UpdateLocationArea")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationArea;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationArea");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookerDashboardApiApiKeys {
}

export class LookerDashboardApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookerDashboardApiApiKeys, value: string) {
        (this.authentications as any)[LookerDashboardApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get all dashboards
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public lookerDashboardGetAll (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/looker/dashboards'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling lookerDashboardGetAll.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookerSingleSignOnApiApiKeys {
}

export class LookerSingleSignOnApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookerSingleSignOnApiApiKeys, value: string) {
        (this.authentications as any)[LookerSingleSignOnApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param embedPath 
     * @param {*} [options] Override http request options.
     */
    public getLookerCustomerReportingEmbedUrl (appId: string, embedPath: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/looker/sso/CustomerReporting'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLookerCustomerReportingEmbedUrl.');
        }

        // verify required parameter 'embedPath' is not null or undefined
        if (embedPath === null || embedPath === undefined) {
            throw new Error('Required parameter embedPath was null or undefined when calling getLookerCustomerReportingEmbedUrl.');
        }

        if (embedPath !== undefined) {
            localVarQueryParameters['embedPath'] = ObjectSerializer.serialize(embedPath, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DashboardEmbed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the single sign on embed URL for PerformanceSummary Dashboard
     * @param appId AppNameId
     * @param embedPath Embed URL of the dashboard
     * @param {*} [options] Override http request options.
     */
    public getSSOEndpoint (appId: string, embedPath: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/looker/sso'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSSOEndpoint.');
        }

        // verify required parameter 'embedPath' is not null or undefined
        if (embedPath === null || embedPath === undefined) {
            throw new Error('Required parameter embedPath was null or undefined when calling getSSOEndpoint.');
        }

        if (embedPath !== undefined) {
            localVarQueryParameters['embedPath'] = ObjectSerializer.serialize(embedPath, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DashboardEmbed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     * @param {*} [options] Override http request options.
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private API] Set Tax Rate on OptionSetItem
     * @param menuId Menu identifier
     * @param menuSectionId 
     * @param menuSectionItemId 
     * @param optionSetId 
     * @param menuItemOptionSetItemId Option set item identifier
     * @param taxRateId Tax Rate to use
     * @param {*} [options] Override http request options.
     */
    public setOptionSetItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setOptionSetItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     * @param {*} [options] Override http request options.
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Create menu section items from a list of Catalog Items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param createFromCatalogItems Information to create the new MenuSectionItems
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItemFromCatalogItems (menuId: number, menuSectionId: number, createFromCatalogItems: CreateMenuSectionItemFromCatalogItems, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/add-catalogitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        // verify required parameter 'createFromCatalogItems' is not null or undefined
        if (createFromCatalogItems === null || createFromCatalogItems === undefined) {
            throw new Error('Required parameter createFromCatalogItems was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFromCatalogItems, "CreateMenuSectionItemFromCatalogItems")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItems (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param destinationDisplayOrder New Display Order of item
     * @param {*} [options] Override http request options.
     */
    public moveMenuItem (menuId: number, menuSectionId: number, menuSectionItemId: number, destinationDisplayOrder: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/setorder/{destinationDisplayOrder}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'destinationDisplayOrder' + '}', encodeURIComponent(String(destinationDisplayOrder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'destinationDisplayOrder' is not null or undefined
        if (destinationDisplayOrder === null || destinationDisplayOrder === undefined) {
            throw new Error('Required parameter destinationDisplayOrder was null or undefined when calling moveMenuItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param taxRateId tax rate to be set against item
     * @param {*} [options] Override http request options.
     */
    public setSectionItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setSectionItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set/update menu section availability hours.
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek Day of the  week
     * @param businessHoursPeriod Menu section active hours, note: DayOfWeek property will be overriden by the path parameter.
     * @param {*} [options] Override http request options.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'dayOfWeek' + '}', encodeURIComponent(String(dayOfWeek)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     * @param {*} [options] Override http request options.
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu availability type
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability DisplayAlways, DisplayBasedOnTimes, DisplayAlwaysStartCollapsed, DisplayAlwaysStartCollapsedBasedOnTimes
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: MenuSectionAvailabilityBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionAvailability, "MenuSectionAvailabilityBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSectionById (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSections (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Re-arrange Items within a Section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param displayOrders Item Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menuSectionsSetItemDisplayOrders (menuId: number, menuSectionId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitemdisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API]Clone a menu, (without attaching stores)
     * @param menuId Menu identifier
     * @param newName Name of the new Menu
     * @param {*} [options] Override http request options.
     */
    public createDraftMenuFromExistingMenu (menuId: number, newName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone/{newName}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'newName' + '}', encodeURIComponent(String(newName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        // verify required parameter 'newName' is not null or undefined
        if (newName === null || newName === undefined) {
            throw new Error('Required parameter newName was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu. If request body is empty, the system will create a menu with default items.
     * @param appId App identifier
     * @param menu Menu
     * @param {*} [options] Override http request options.
     */
    public createNewMenuForApp (appId: string, menu: CreateFullMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "CreateFullMenu")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Mark a Menu as Deleted
     * @param menuId Menu Identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuImage (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all menu metadata by menu ID and store ID
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getAllMenuMetadataByMenuIdAndStoreId (menuId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAllMetadataResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuById (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get Menus Name
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuName (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus store names
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuStoreNames (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuStoreNames");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus tax details
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuTaxDetails (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuTaxDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuTaxDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus by appId
     * @param appId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public getMenusByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get a Menus Checkpoints
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenusCheckpoints (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuCheckpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Remove a Menus Tax Rate, can only remove a tax rate that does not have items/optionSetItems attached
     * @param menuId Menu identifier
     * @param taxId Id of Menu Tax to be removed
     * @param {*} [options] Override http request options.
     */
    public menusDeleteTaxRate (menuId: number, taxId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/{taxId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusDeleteTaxRate.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling menusDeleteTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param menuId 
     * @param isAvailable 
     * @param {*} [options] Override http request options.
     */
    public menusGetMenuBulkShowHide (menuId: number, isAvailable: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide/list'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set if tax shows for a Menu
     * @param menuId Menu identifier
     * @param show Boolean show or dont show tax (Exclusive tax type can only ever be TRUE)
     * @param {*} [options] Override http request options.
     */
    public menusSetDisplayOnMenuTax (menuId: number, show: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/show/{show}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'show' + '}', encodeURIComponent(String(show)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        // verify required parameter 'show' is not null or undefined
        if (show === null || show === undefined) {
            throw new Error('Required parameter show was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Re-arrange Sections within a Menu
     * @param menuId Menu identifier
     * @param displayOrders Section Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menusSetItemDisplayOrders (menuId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sectiondisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menusSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param menuId 
     * @param menuElements 
     * @param isAvailable 
     * @param {*} [options] Override http request options.
     */
    public menusShowHideBulkItems (menuId: number, menuElements: Array<MenuElementHide>, isAvailable: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'menuElements' is not null or undefined
        if (menuElements === null || menuElements === undefined) {
            throw new Error('Required parameter menuElements was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusShowHideBulkItems.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuElements, "Array<MenuElementHide>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementEditResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set the type of Tax on a Menu
     * @param menuId Menu identifier
     * @param type Type of Tax
     * @param {*} [options] Override http request options.
     */
    public menusUpdateTaxType (menuId: number, type: 'IncludedInBasePrice' | 'ExcludedFromBasePrice', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/type/{type}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpdateTaxType.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling menusUpdateTaxType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Add/Update a Tax Rate
     * @param menuId Menu identifier
     * @param taxRate Tax Rate to Add/Update
     * @param {*} [options] Override http request options.
     */
    public menusUpsertTaxRate (menuId: number, taxRate: MenuTaxRate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/taxrate'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpsertTaxRate.');
        }

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling menusUpsertTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxRate, "MenuTaxRate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MenuTaxRate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Restore a Menu to a checkpoint
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     * @param {*} [options] Override http request options.
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'checkpointId' + '}', encodeURIComponent(String(checkpointId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Lock/Unlock a Menu for Editing
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     * @param {*} [options] Override http request options.
     */
    public setMenuLock (menuId: number, locked: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locked, "boolean")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set Menus Name
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     * @param {*} [options] Override http request options.
     */
    public setMenuName (menuId: number, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenu (menuId: number, menu: MenuBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "MenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuImage (menuId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu from xlsx file.
     * @param appId App identifier
     * @param Menu Uploaded xlsx menu
     * @param {*} [options] Override http request options.
     */
    public uploadNewMenuForApp (appId: string, Menu: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/xlsx'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadNewMenuForApp.');
        }

        // verify required parameter 'Menu' is not null or undefined
        if (Menu === null || Menu === undefined) {
            throw new Error('Required parameter Menu was null or undefined when calling uploadNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Menu !== undefined) {
            localVarFormParams['Menu'] = Menu;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MetafieldDefinitionsApiApiKeys {
}

export class MetafieldDefinitionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MetafieldDefinitionsApiApiKeys, value: string) {
        (this.authentications as any)[MetafieldDefinitionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Metafield Definition
     * @param appId 
     * @param ownerEntity 
     * @param createMetafieldDefinition 
     * @param {*} [options] Override http request options.
     */
    public createMetafieldDefinition (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', createMetafieldDefinition: CreateMetafieldDefinition, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createMetafieldDefinition.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling createMetafieldDefinition.');
        }

        // verify required parameter 'createMetafieldDefinition' is not null or undefined
        if (createMetafieldDefinition === null || createMetafieldDefinition === undefined) {
            throw new Error('Required parameter createMetafieldDefinition was null or undefined when calling createMetafieldDefinition.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createMetafieldDefinition, "CreateMetafieldDefinition")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get a Metafield Definition for the specified owner entity and key.
     * @param appId 
     * @param ownerEntity 
     * @param key 
     * @param {*} [options] Override http request options.
     */
    public getMetafieldDefinitionByKey (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}/{key}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Metafield Definitions for the specified owner entity.
     * @param appId 
     * @param ownerEntity 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getMetafieldDefinitions (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMetafieldDefinitions.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getMetafieldDefinitions.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get OwnerEntity Configurations which contain information to manage Metafield Definitions
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOwnerEntityConfigurations (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OwnerEntityConfigurations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOwnerEntityConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OwnerEntityConfigurations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OwnerEntityConfigurations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get OwnerEntity Definition Recommendations
     * @param appId 
     * @param ownerEntity 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getOwnerEntityRecommendations (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinitionRecommendation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/recommendations/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOwnerEntityRecommendations.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getOwnerEntityRecommendations.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinitionRecommendation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultMetafieldDefinitionRecommendation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update a Metafield Definition
     * @param appId 
     * @param ownerEntity 
     * @param key 
     * @param updateMetafieldDefinition 
     * @param {*} [options] Override http request options.
     */
    public updateMetafieldDefinition (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', key: string, updateMetafieldDefinition: UpdateMetafieldDefinition, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}/{key}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'updateMetafieldDefinition' is not null or undefined
        if (updateMetafieldDefinition === null || updateMetafieldDefinition === undefined) {
            throw new Error('Required parameter updateMetafieldDefinition was null or undefined when calling updateMetafieldDefinition.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateMetafieldDefinition, "UpdateMetafieldDefinition")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uri Redirect uri
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OAuth App
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createOAuthApp (oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteOAuthApp (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all OAuth Apps
     * @param appId 
     * @param oauthAppName 
     * @param {*} [options] Override http request options.
     */
    public getOAuthApps (appId: string, oauthAppName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            localVarQueryParameters['oauthAppName'] = ObjectSerializer.serialize(oauthAppName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App by identifier
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App secret key
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth access token for App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOauthAccessToken (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App redirect uris
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRedirectUris (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public oAuthClientsGetApplications (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uriId Redirect uri identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OAuth App
     * @param oauthAppId OAuth App identifier
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateOAuthApp (oauthAppId: string, oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OnboardingApiApiKeys {
}

export class OnboardingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OnboardingApiApiKeys, value: string) {
        (this.authentications as any)[OnboardingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public onboardingGetOnboardingItems (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingGetOnboardingItems.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling onboardingGetOnboardingItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param onboardingItemId 
     * @param itemUpdate 
     * @param {*} [options] Override http request options.
     */
    public onboardingUpdateOnboardingItem (appId: string, storeId: number, onboardingItemId: number, itemUpdate: OnboardingItemUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores/{storeId}/items/{onboardingItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'onboardingItemId' + '}', encodeURIComponent(String(onboardingItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'onboardingItemId' is not null or undefined
        if (onboardingItemId === null || onboardingItemId === undefined) {
            throw new Error('Required parameter onboardingItemId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'itemUpdate' is not null or undefined
        if (itemUpdate === null || itemUpdate === undefined) {
            throw new Error('Required parameter itemUpdate was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemUpdate, "OnboardingItemUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderIngestApiApiKeys {
}

export class OrderIngestApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrderIngestApiApiKeys, value: string) {
        (this.authentications as any)[OrderIngestApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [ALPHA - this endpoint is under internal development, it is not available just yet to use in your production system]
     * @summary Provides an ability to ingest a 3rd party order into Flipdish ecosystem
     * @param order 
     * @param appNameId 
     * @param {*} [options] Override http request options.
     */
    public orderIngestSubmitNewOrder (order: OrderIngestSubmitOrderRequest, appNameId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderIngestSubmitOrderResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/order-ingest/submit'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling orderIngestSubmitNewOrder.');
        }

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling orderIngestSubmitNewOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "OrderIngestSubmitOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderIngestSubmitOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderIngestSubmitOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * To accept an order, you create an `accept` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Accept order
     * @param id Order identifier
     * @param acceptObject Order accept parameters (eg: EstimatedMinutesForDelivery)
     * @param {*} [options] Override http request options.
     */
    public acceptOrder (id: number, acceptObject: Accept, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "Accept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To dispatch an order send a POST request with `Id` path parameter which identifies the order.
     * @summary Dispatch order
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public dispatchOrder (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns an orders delivery information. This would be used to display the latest known delivery information on a screen.
     * @summary Get order delivery information
     * @param orderId Flipdish Order Id
     * @param {*} [options] Override http request options.
     */
    public getDeliveryInformation (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderDeliveryInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/deliveryinfo'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getDeliveryInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderDeliveryInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderDeliveryInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order by ID
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderById (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orders by filter
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param from Order has been placed after this parameter value
     * @param to Order has been placed before this parameter value
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, from?: Date, to?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get summary of orders by filter
     * @param appId App Name Id
     * @param searchQuery Query string
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param orderByRequestedForTime 
     * @param channels 
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, orderByRequestedForTime?: boolean, channels?: Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderByRequestedForTime !== undefined) {
            localVarQueryParameters['orderByRequestedForTime'] = ObjectSerializer.serialize(orderByRequestedForTime, "boolean");
        }

        if (channels !== undefined) {
            localVarQueryParameters['channels'] = ObjectSerializer.serialize(channels, "Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrderSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To refund an order, you create a `refund` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Refund order
     * @param id Order identifier
     * @param refundObject 
     * @param {*} [options] Override http request options.
     */
    public refundOrder (id: number, refundObject: Refund, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "Refund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To reject an order, you create a `reject` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Reject order
     * @param id Order identifier
     * @param rejectObject 
     * @param {*} [options] Override http request options.
     */
    public rejectOrder (id: number, rejectObject: Reject, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "Reject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns an order's delivery information. This would be used to display the latest known delivery information on a screen.
     * @summary Add/update delivery-related information to an order
     * @param orderId Flipdish Order Id
     * @param deliveryInformation Delivery Information
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryInformation (orderId: number, deliveryInformation: OrderDeliveryInformationBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/deliveryinfo'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryInformation.');
        }

        // verify required parameter 'deliveryInformation' is not null or undefined
        if (deliveryInformation === null || deliveryInformation === undefined) {
            throw new Error('Required parameter deliveryInformation was null or undefined when calling updateDeliveryInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryInformation, "OrderDeliveryInformationBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentIntentsApiApiKeys {
}

export class PaymentIntentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentIntentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentIntentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns stripe payment intent for a given id
     * @param paymentIntentId Stripes payment intent indentifier
     * @param {*} [options] Override http request options.
     */
    public getPaymentIntent (paymentIntentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentIntent;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payment_intents/{paymentIntentId}'
            .replace('{' + 'paymentIntentId' + '}', encodeURIComponent(String(paymentIntentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentIntentId' is not null or undefined
        if (paymentIntentId === null || paymentIntentId === undefined) {
            throw new Error('Required parameter paymentIntentId was null or undefined when calling getPaymentIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentIntent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentIntent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns payment refund information related to the order with the order id
     * @param orderId Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderPaymentInformation (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payments/payment/{orderId}/refundable'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderPaymentInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderPaymentInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsApiApiKeys {
}

export class PayoutsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get Payout details broken down by Store
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param {*} [options] Override http request options.
     */
    public getPayout (appId: string, bankAccountId: number, payoutId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PayoutDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's chargebacks
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutChargebacks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutChargeback");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's orders
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOrders (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOrders.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's other charges
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOtherCharges.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOtherCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's refunds
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutRefunds.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutRefund");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Get list of payout summaries
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public getPayoutSummaries (appId: string, startDate?: Date, endDate?: Date, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutSummaries.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPayoutSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Get list of payouts
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param page 
     * @param limit 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public getPayouts (appId: string, startDate?: Date, endDate?: Date, page?: number, limit?: number, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayouts.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayout");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsExportApiApiKeys {
}

export class PayoutsExportApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsExportApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsExportApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Export a list of payout's chargebacks as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutChargebacks.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's orders as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOrders (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOrders.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's other charges as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOtherCharges.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's refunds as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutRefunds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export payout's details as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutStores (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutStores.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export payouts as CSV
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public exportPayouts (appId: string, startDate?: Date, endDate?: Date, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayouts.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        (this.authentications as any)[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get processing fee configs by store identifiers
     * @param storeIds Store identifiers
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PushNotificationsApiApiKeys {
}

export class PushNotificationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PushNotificationsApiApiKeys, value: string) {
        (this.authentications as any)[PushNotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param scheduledPushNotificationId ID of Scheduled push notifiaction to delete
     * @param {*} [options] Override http request options.
     */
    public deletePushNotification (appId: string, scheduledPushNotificationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling deletePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPushNotifications (appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPushNotifications.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId Application Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public schedulePushNotification (appId: string, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling schedulePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling schedulePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Update the push notification
     * @param appId Application Id
     * @param scheduledPushNotificationId Notification Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public updatePushNotification (appId: string, scheduledPushNotificationId: number, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updatePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        (this.authentications as any)[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a Store Group  It will be attached to an existing App
     * @param appNameId App Name Id
     * @param storeGroup Store group definition
     * @param {*} [options] Override http request options.
     */
    public createStoreGroup (appNameId: string, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a Store Groups
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a paginated list of Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Returns a paginated list of Extended Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param groupingRadius 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (groupingRadius !== undefined) {
            localVarQueryParameters['groupingRadius'] = ObjectSerializer.serialize(groupingRadius, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroupExtended");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a Store Group  Can only remove a store group if there is no stores attached to the group
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public removeStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Store Group
     * @param storeGroupId Store Group Id
     * @param storeGroup Store Group Delta
     * @param {*} [options] Override http request options.
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroupBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreOrderCapacityApiApiKeys {
}

export class StoreOrderCapacityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreOrderCapacityApiApiKeys, value: string) {
        (this.authentications as any)[StoreOrderCapacityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get store's order capacity configuration
     * @param appId App Name Id
     * @param storeId Store Id
     * @param deliveryType Delivery / Pickup
     * @param {*} [options] Override http request options.
     */
    public getStoreOrderCapacity (appId: string, storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}/{deliveryType}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getStoreOrderCapacity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreOrderCapacityConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a store's order capacity configuration
     * @param storeId Store identifier
     * @param deliveryType Delivery / Pickup
     * @param newOrderCapacityConfig new order capacity configuration
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateStoreOrderCapacityConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', newOrderCapacityConfig: StoreOrderCapacityConfigEditModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'newOrderCapacityConfig' is not null or undefined
        if (newOrderCapacityConfig === null || newOrderCapacityConfig === undefined) {
            throw new Error('Required parameter newOrderCapacityConfig was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        if (deliveryType !== undefined) {
            localVarQueryParameters['deliveryType'] = ObjectSerializer.serialize(deliveryType, "'Delivery' | 'Pickup'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newOrderCapacityConfig, "StoreOrderCapacityConfigEditModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Archive store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public archiveStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/archive'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling archiveStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign Menu to Store
     * @param storeId Store identifier
     * @param menuId Id of Menu to assign to store
     * @param {*} [options] Override http request options.
     */
    public assignMenu (storeId: number, menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/menu/{menuId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling assignMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone store with store clone settings
     * @param storeId Store identifier
     * @param settings Settings for cloning the store
     * @param {*} [options] Override http request options.
     */
    public cloneStore (storeId: number, settings: StoreCloneSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "StoreCloneSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Configure Store Service Charge; Idempotent Operation
     * @param storeId Store identifier
     * @param serviceCharge Service charge
     * @param {*} [options] Override http request options.
     */
    public configureStoreServiceCharge (storeId: number, serviceCharge: ServiceCharge, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultServiceCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/servicecharge'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling configureStoreServiceCharge.');
        }

        // verify required parameter 'serviceCharge' is not null or undefined
        if (serviceCharge === null || serviceCharge === undefined) {
            throw new Error('Required parameter serviceCharge was null or undefined when calling configureStoreServiceCharge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(serviceCharge, "ServiceCharge")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultServiceCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultServiceCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create Business Hours Override for a store
     * @param storeId Store identifier
     * @param businessHoursOverride Business Hours Override
     * @param {*} [options] Override http request options.
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: BusinessHoursOverrideBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursOverride, "BusinessHoursOverrideBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create store with Store Group identifier
     * @param storeGroupId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public createStore (storeGroupId: number, store: StoreCreateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreCreateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Business Hours Override for a store
     * @param storeId 
     * @param businessHoursOverrideId 
     * @param {*} [options] Override http request options.
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'businessHoursOverrideId' + '}', encodeURIComponent(String(businessHoursOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Stores Bank Account Id
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getBankAccountForStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAssignedBankAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param {*} [options] Override http request options.
     */
    public getBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get business hours overrides by store identifier
     * @param storeId Store identifier
     * @param after Return results that ended after this datetime. Default value is the current datetime.
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store end of day report
     * @param storeId Store identifier
     * @param date Store identifier
     * @param {*} [options] Override http request options.
     */
    public getEndOfDayReport (storeId: number, date?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/endofdayreport'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getEndOfDayReport.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreEndOfDayReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param {*} [options] Override http request options.
     */
    public getPreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPreOrderConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the Preview times of the pre-order configuration
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig_leadTimeMinutes Lead Time in Minutes
     * @param preOrderConfig_intervalMinutes Interval in minutes
     * @param preOrderConfig_maxOrderAheadDays Max Days to order ahead
     * @param preOrderConfig_includeAsap Show ASAP as option
     * @param preOrderConfig_includeMoreGranularInitialTime Granual Init&#39; Time
     * @param preOrderConfig_cutOffTimePreviousDayBasic Cut off time previous day
     * @param preOrderConfig_cutOffTimeCurrentDayBasic Cut off time current day
     * @param preOrderConfig_preOrderTimeDisplayType Type of time displayed.
     * @param preOrderConfig_alwaysAppearOpen Specifies whether a customer can pre-order outside the store opening hours or not.
     * @param preOrderConfig_requireExplicitSelectAlways Force customer to select collection time.
     * @param {*} [options] Override http request options.
     */
    public getPreOrderPreview (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig_leadTimeMinutes?: number, preOrderConfig_intervalMinutes?: number, preOrderConfig_maxOrderAheadDays?: number, preOrderConfig_includeAsap?: boolean, preOrderConfig_includeMoreGranularInitialTime?: boolean, preOrderConfig_cutOffTimePreviousDayBasic?: string, preOrderConfig_cutOffTimeCurrentDayBasic?: string, preOrderConfig_preOrderTimeDisplayType?: 'SingleTime' | 'StartAndEndTime' | 'DayOnly', preOrderConfig_alwaysAppearOpen?: boolean, preOrderConfig_requireExplicitSelectAlways?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/preview'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderPreview.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderPreview.');
        }

        if (preOrderConfig_leadTimeMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.leadTimeMinutes'] = ObjectSerializer.serialize(preOrderConfig_leadTimeMinutes, "number");
        }

        if (preOrderConfig_intervalMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.intervalMinutes'] = ObjectSerializer.serialize(preOrderConfig_intervalMinutes, "number");
        }

        if (preOrderConfig_maxOrderAheadDays !== undefined) {
            localVarQueryParameters['preOrderConfig.maxOrderAheadDays'] = ObjectSerializer.serialize(preOrderConfig_maxOrderAheadDays, "number");
        }

        if (preOrderConfig_includeAsap !== undefined) {
            localVarQueryParameters['preOrderConfig.includeAsap'] = ObjectSerializer.serialize(preOrderConfig_includeAsap, "boolean");
        }

        if (preOrderConfig_includeMoreGranularInitialTime !== undefined) {
            localVarQueryParameters['preOrderConfig.includeMoreGranularInitialTime'] = ObjectSerializer.serialize(preOrderConfig_includeMoreGranularInitialTime, "boolean");
        }

        if (preOrderConfig_cutOffTimePreviousDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimePreviousDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimePreviousDayBasic, "string");
        }

        if (preOrderConfig_cutOffTimeCurrentDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimeCurrentDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimeCurrentDayBasic, "string");
        }

        if (preOrderConfig_preOrderTimeDisplayType !== undefined) {
            localVarQueryParameters['preOrderConfig.preOrderTimeDisplayType'] = ObjectSerializer.serialize(preOrderConfig_preOrderTimeDisplayType, "'SingleTime' | 'StartAndEndTime' | 'DayOnly'");
        }

        if (preOrderConfig_alwaysAppearOpen !== undefined) {
            localVarQueryParameters['preOrderConfig.alwaysAppearOpen'] = ObjectSerializer.serialize(preOrderConfig_alwaysAppearOpen, "boolean");
        }

        if (preOrderConfig_requireExplicitSelectAlways !== undefined) {
            localVarQueryParameters['preOrderConfig.requireExplicitSelectAlways'] = ObjectSerializer.serialize(preOrderConfig_requireExplicitSelectAlways, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPreOrderTime");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param paymentAccountType 
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: 'Card' | 'Cash' | 'Ideal' | 'Bancontact' | 'Giropay' | 'Eps' | 'Emv' | 'PayPal', appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'paymentAccountType' + '}', encodeURIComponent(String(paymentAccountType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store by identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getStoreById (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param storeNameQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoreHeadersByAppId (appId: string, storeNameQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/header'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreHeadersByAppId.');
        }

        if (storeNameQuery !== undefined) {
            localVarQueryParameters['storeNameQuery'] = ObjectSerializer.serialize(storeNameQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores statistics by app name id and storeIds
     * @param appId App Name Id
     * @param storeId Store Ids
     * @param {*} [options] Override http request options.
     */
    public getStoreNetSales (appId: string, storeId: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve Store Service Charge
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getStoreServiceCharge (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ServiceCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/servicecharge'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreServiceCharge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ServiceCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServiceCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores, excluding archived ones
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store validation by storeIds
     * @param storeId Store identifier
     * @param appId 
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoresByStoreIdWithValidations (storeId: Array<number>, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreValidationConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storevalidation/kiosk'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoresByStoreIdWithValidations.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByStoreIdWithValidations.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreValidationConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreValidationConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public publishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/publish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling publishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param businessHoursPeriod Business Hours Period
     * @param {*} [options] Override http request options.
     */
    public setBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param enabled Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public setPreOrdeEnabled (storeId: number, deliveryType: 'Delivery' | 'Pickup', enabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/enabled'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'enabled' is not null or undefined
        if (enabled === null || enabled === undefined) {
            throw new Error('Required parameter enabled was null or undefined when calling setPreOrdeEnabled.');
        }

        if (enabled !== undefined) {
            localVarQueryParameters['enabled'] = ObjectSerializer.serialize(enabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unpublish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public unpublishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/unpublish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unpublishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public updatePreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig: PreOrderConfig, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'preOrderConfig' is not null or undefined
        if (preOrderConfig === null || preOrderConfig === undefined) {
            throw new Error('Required parameter preOrderConfig was null or undefined when calling updatePreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(preOrderConfig, "PreOrderConfig")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store by identifier
     * @param storeId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public updateStore (storeId: number, store: StoreBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address
     * @param storeId Store identifier
     * @param storeAddress Store address
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddress (storeId: number, storeAddress: StoreAddressBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeAddress, "StoreAddressBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreAddress");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address coordinates
     * @param storeId Store identifier
     * @param coordinates Store address coordinates
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: Coordinates, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coordinates, "Coordinates")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCoordinates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address
     * @param storeId Store identifier
     * @param address Store address
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressForm (storeId: number, address: StoreAddressForm, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/addressform'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressForm.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling updateStoreAddressForm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(address, "StoreAddressForm")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectApiApiKeys {
}

export class StripeCustomConnectApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeCustomConnectApiApiKeys, value: string) {
        (this.authentications as any)[StripeCustomConnectApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new Bank Account and Stripe connected account
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccountAndConnectedAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a Stripe connected account associated with the bank account of bankAccountId
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/create-update-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling createStripeConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single-use Stripe URL for the given account
     * @param appId App Name
     * @param stripeConnectedAccountId Stripe Connected Account Id
     * @param stripeAccountLinkRequest 
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccountLink (appId: string, stripeConnectedAccountId: string, stripeAccountLinkRequest: StripeAccountLinkRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{stripeConnectedAccountId}/create-account-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'stripeConnectedAccountId' + '}', encodeURIComponent(String(stripeConnectedAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeAccountLinkRequest' is not null or undefined
        if (stripeAccountLinkRequest === null || stripeAccountLinkRequest === undefined) {
            throw new Error('Required parameter stripeAccountLinkRequest was null or undefined when calling createStripeConnectedAccountLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stripeAccountLinkRequest, "StripeAccountLinkRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current verification status of the given connected account
     * @param appId 
     * @param stripeConnectedAccountId 
     * @param {*} [options] Override http request options.
     */
    public getVerificationStatus (appId: string, stripeConnectedAccountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/verification-status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVerificationStatus.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling getVerificationStatus.');
        }

        if (stripeConnectedAccountId !== undefined) {
            localVarQueryParameters['stripeConnectedAccountId'] = ObjectSerializer.serialize(stripeConnectedAccountId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account's BusinessType and create a Stripe Connected Account
     * @param appId App Name
     * @param bankAccountId Bank Account Id
     * @param businessType Bank Account business type
     * @param {*} [options] Override http request options.
     */
    public setBankAccountBusinessType (appId: string, bankAccountId: number, businessType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account/{bankAccountId}/businesstype'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'businessType' is not null or undefined
        if (businessType === null || businessType === undefined) {
            throw new Error('Required parameter businessType was null or undefined when calling setBankAccountBusinessType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessType, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param linkRequestId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public stripeCustomConnectRefresh (linkRequestId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/refresh-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'linkRequestId' is not null or undefined
        if (linkRequestId === null || linkRequestId === undefined) {
            throw new Error('Required parameter linkRequestId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        if (linkRequestId !== undefined) {
            localVarQueryParameters['linkRequestId'] = ObjectSerializer.serialize(linkRequestId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account details
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     * @param updateRequest fields to be updated
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountDetails (appId: string, bankAccountId: number, updateRequest: BankAccountDetailsUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/update-bank-account-details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'updateRequest' is not null or undefined
        if (updateRequest === null || updateRequest === undefined) {
            throw new Error('Required parameter updateRequest was null or undefined when calling updateBankAccountDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateRequest, "BankAccountDetailsUpdateRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectAdminApiApiKeys {
}

export class StripeCustomConnectAdminApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeCustomConnectAdminApiApiKeys, value: string) {
        (this.authentications as any)[StripeCustomConnectAdminApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new Bank Account and Stripe connected account
     * @param accounts Accounts to be initialized in stripe
     * @param {*} [options] Override http request options.
     */
    public initializeBankAccountConnectedAccount (accounts: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/customconnect/initialize-bank-account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accounts' is not null or undefined
        if (accounts === null || accounts === undefined) {
            throw new Error('Required parameter accounts was null or undefined when calling initializeBankAccountConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accounts, "Array<number>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        (this.authentications as any)[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Cancel a stuart job
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartCancelJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get start job details
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultJobResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stuart settings for a store
     * @param storeId Store Identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetStuartSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStuartSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set stuart settings for a store
     * @param storeId Store Identifier
     * @param stuartSettings Stuart settings model
     * @param {*} [options] Override http request options.
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: StuartSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stuartSettings, "StuartSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        (this.authentications as any)[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create teammate and send an invite.
     * @param appId Application identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public createTeammate (appId: string, teammate: CreateTeammate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "CreateTeammate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete teammate
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteTeammate (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a teammates by email address
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all teammates
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getTeammatesByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeem one-time code from invitation
     * @param otc 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public redeemInvitation (otc: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', encodeURIComponent(String(otc)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRedeemInvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update teammates (this method does not support Deltas!)
     * @param appId Application identifier
     * @param id teammate identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public updateTeammate (appId: string, id: string, teammate: TeammateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "TeammateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TipsApiApiKeys {
}

export class TipsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TipsApiApiKeys, value: string) {
        (this.authentications as any)[TipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns current tip configuration for a store
     * @param storeId Store Id
     * @param {*} [options] Override http request options.
     */
    public tipConfigGet (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/tipconfig'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling tipConfigGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTipConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update or insert current tip configuration for a store
     * @param storeId Store Id
     * @param updateConfig Update Configuration
     * @param {*} [options] Override http request options.
     */
    public tipConfigUpsert (storeId: number, updateConfig: UpdateTipConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/tipconfig'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling tipConfigUpsert.');
        }

        // verify required parameter 'updateConfig' is not null or undefined
        if (updateConfig === null || updateConfig === undefined) {
            throw new Error('Required parameter updateConfig was null or undefined when calling tipConfigUpsert.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateConfig, "UpdateTipConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTipConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param userId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getPreviousOrderCountForStore (userId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/{userId}/previousordercount/{storeId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get role names
     * @param {*} [options] Override http request options.
     */
    public getRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Create voucher
     * @param appId App Name Id
     * @param voucher Voucher Details
     * @param {*} [options] Override http request options.
     */
    public createVoucher (appId: string, voucher: CreateVoucher, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "CreateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher by identifier
     * @param voucherId Id of the voucher
     * @param {*} [options] Override http request options.
     */
    public getVoucherById (voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher stats by identifier
     * @param voucherId Id of the voucher
     * @param aggregateDataBy Aggregate data by day \\ week \\ month
     * @param dataPointLimit Amount of data points per request
     * @param {*} [options] Override http request options.
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            localVarQueryParameters['aggregateDataBy'] = ObjectSerializer.serialize(aggregateDataBy, "'Daily' | 'Weekly' | 'Monthly'");
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultVoucherDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get vouchers summaries for App Id
     * @param appId Application Id
     * @param pageIndex Page Number
     * @param pageSize Page Size
     * @param searchCodes Search by Voucher Code\\s
     * @param statusSearch Search by Status
     * @param typeSearch Search by Type
     * @param subTypeSearch Search by Sub Type
     * @param storeIds Search by Store Ids
     * @param {*} [options] Override http request options.
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>, typeSearch?: Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>, subTypeSearch?: Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchCodes !== undefined) {
            localVarQueryParameters['searchCodes'] = ObjectSerializer.serialize(searchCodes, "Array<string>");
        }

        if (statusSearch !== undefined) {
            localVarQueryParameters['statusSearch'] = ObjectSerializer.serialize(statusSearch, "Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>");
        }

        if (typeSearch !== undefined) {
            localVarQueryParameters['typeSearch'] = ObjectSerializer.serialize(typeSearch, "Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>");
        }

        if (subTypeSearch !== undefined) {
            localVarQueryParameters['subTypeSearch'] = ObjectSerializer.serialize(subTypeSearch, "Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultVoucherSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Updates voucher
     * @param voucherId Id of the voucher
     * @param voucher Updated details for the voucher
     * @param storeId 
     * @param percentValue Percent voucher value (can have 1 of 3)
     * @param lumpValue Lump voucher value (can have 1 of 3)
     * @param freeItemId Free Item Id (can have 1 of 3)
     * @param {*} [options] Override http request options.
     */
    public updateVoucher (voucherId: number, voucher: VoucherBase, storeId?: Array<number>, percentValue?: number, lumpValue?: number, freeItemId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (percentValue !== undefined) {
            localVarQueryParameters['percentValue'] = ObjectSerializer.serialize(percentValue, "number");
        }

        if (lumpValue !== undefined) {
            localVarQueryParameters['lumpValue'] = ObjectSerializer.serialize(lumpValue, "number");
        }

        if (freeItemId !== undefined) {
            localVarQueryParameters['freeItemId'] = ObjectSerializer.serialize(freeItemId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "VoucherBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a webhook subscription for you Oauth App
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public craeteWebhookSubscription (oauthAppId: string, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling craeteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete you webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscription event names
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNames (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your webhook subscriptions selected event names
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a sample event from a webhook subscription
     * @param eventName 
     * @param appId 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param version 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventSample (eventName: string, appId: string, oauthAppId: string, webhookSubscriptionId: string, version?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}/test'
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventSample.');
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookEventSample");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs for your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param appId 
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscriptions by your Oauth App id
     * @param oauthAppId Oauth App identifier
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook subscription object
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebsiteApiApiKeys {
}

export class WebsiteApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebsiteApiApiKeys, value: string) {
        (this.authentications as any)[WebsiteApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a testimonial
     * @param appId Application identifier
     * @param testimonial Testimonial to be added
     * @param {*} [options] Override http request options.
     */
    public addTestimonial (appId: string, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling addTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to delete
     * @param {*} [options] Override http request options.
     */
    public deleteTestimonial (appId: string, testimonialId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling deleteTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Website Image
     * @param appId Application identifier
     * @param imageId Id of the image
     * @param {*} [options] Override http request options.
     */
    public deleteWebsiteImage (appId: string, imageId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebsiteImage.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling deleteWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to edit
     * @param testimonial New values of the testimonial
     * @param {*} [options] Override http request options.
     */
    public editTestimonial (appId: string, testimonialId: number, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling editTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Index Configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getIndexConfiguration (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Index Configuration
     * @param appId Application identifier
     * @param indexPage New index page definition
     * @param {*} [options] Override http request options.
     */
    public setIndexConfiguration (appId: string, indexPage: IndexPageBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setIndexConfiguration.');
        }

        // verify required parameter 'indexPage' is not null or undefined
        if (indexPage === null || indexPage === undefined) {
            throw new Error('Required parameter indexPage was null or undefined when calling setIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(indexPage, "IndexPageBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPageBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload Website Image
     * @param appId Application identifier
     * @param imageLocation Section for which to upload the image
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadWebsiteImage (appId: string, imageLocation: 'IndexHeader' | 'IndexAboutSectionLeft' | 'IndexAboutSectionRight' | 'IndexGallery' | 'IndexOpeningHoursHeader' | 'IndexTestimonialsHeader', Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageLocation}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageLocation' + '}', encodeURIComponent(String(imageLocation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'imageLocation' is not null or undefined
        if (imageLocation === null || imageLocation === undefined) {
            throw new Error('Required parameter imageLocation was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Triggers a Check DNS Process
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public websiteCheckNow (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/dnscheck'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling websiteCheckNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
