/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Accept
*/
export class Accept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Accept.attributeTypeMap;
    }
}

/**
* Account details
*/
export class AccountDetail {
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Signup steps
    */
    'SignupSteps'?: Array<SignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified'?: boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser'?: boolean;
    /**
    * Accounts Id
    */
    'AccountId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SignupSteps",
            "baseName": "SignupSteps",
            "type": "Array<SignupStep>"
        },
        {
            "name": "IsVerified",
            "baseName": "IsVerified",
            "type": "boolean"
        },
        {
            "name": "IsSelfServeUser",
            "baseName": "IsSelfServeUser",
            "type": "boolean"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetail.attributeTypeMap;
    }
}

/**
* Account Details Base
*/
export class AccountDetailBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetailBase.attributeTypeMap;
    }
}

/**
* Represents the format of a bank account field
*/
export class AccountFieldDefinition {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldDefinition.KeyEnum;
    /**
    * Display name of the field
    */
    'DisplayName'?: string;
    /**
    * There are some fields that are of type known to the frontend (IBAN, Swift) -- for those frontend should use its own validation library, e.g. ibantools
    */
    'Type'?: AccountFieldDefinition.TypeEnum;
    /**
    * Minimum length of the field
    */
    'MinLength'?: number;
    /**
    * Maximum length of the field
    */
    'MaxLength'?: number;
    /**
    * Is the field digits (numeric) only
    */
    'DigitsOnly'?: boolean;
    /**
    * Regex for validating the field (if specified)
    */
    'Regex'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldDefinition.KeyEnum"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "AccountFieldDefinition.TypeEnum"
        },
        {
            "name": "MinLength",
            "baseName": "MinLength",
            "type": "number"
        },
        {
            "name": "MaxLength",
            "baseName": "MaxLength",
            "type": "number"
        },
        {
            "name": "DigitsOnly",
            "baseName": "DigitsOnly",
            "type": "boolean"
        },
        {
            "name": "Regex",
            "baseName": "Regex",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldDefinition.attributeTypeMap;
    }
}

export namespace AccountFieldDefinition {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
    export enum TypeEnum {
        None = <any> 'None',
        Iban = <any> 'Iban'
    }
}
/**
* Represents one populated account field (its key and value)
*/
export class AccountFieldKeyValuePair {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldKeyValuePair.KeyEnum;
    /**
    * The value of the field
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldKeyValuePair.KeyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldKeyValuePair.attributeTypeMap;
    }
}

export namespace AccountFieldKeyValuePair {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
}
/**
* List of field definitions per country
*/
export class AccountFieldsDefinitions {
    /**
    * List of field definitions per country
    */
    'DefinitionsPerCountry'?: { [key: string]: Array<AccountFieldDefinition>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DefinitionsPerCountry",
            "baseName": "DefinitionsPerCountry",
            "type": "{ [key: string]: Array<AccountFieldDefinition>; }"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Add item details
*/
export class AddItemDetails {
    /**
    * Promotional Item Id
    */
    'PromotionalItemId'?: number;
    /**
    * Promotional Item Name
    */
    'PromotionalItemName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionalItemId",
            "baseName": "PromotionalItemId",
            "type": "number"
        },
        {
            "name": "PromotionalItemName",
            "baseName": "PromotionalItemName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddItemDetails.attributeTypeMap;
    }
}

/**
* 
*/
export class AllMetadataResult {
    /**
    * Menu item metadata
    */
    'MenuItemMetadata'?: Array<Metadata>;
    /**
    * Menu item optionset item metadata
    */
    'MenuItemOptionSetItemMetadata'?: Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemMetadata",
            "baseName": "MenuItemMetadata",
            "type": "Array<Metadata>"
        },
        {
            "name": "MenuItemOptionSetItemMetadata",
            "baseName": "MenuItemOptionSetItemMetadata",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return AllMetadataResult.attributeTypeMap;
    }
}

/**
* Client Analytics event
*/
export class AnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Type of the event
    */
    'EventType'?: string;
    /**
    * Type of the app the event is coming from
    */
    'AppType'?: string;
    /**
    * JSON Metadata
    */
    'Metadata'?: string;
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * Latitude of the event
    */
    'Latitude'?: number;
    /**
    * Longitude of the event
    */
    'Longitude'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalyticsClientEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The values of this data point
    */
    'CurrencyData'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return ApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmDataPoint.attributeTypeMap;
    }
}

/**
* Provides an average value for a single hour of day of the week
*/
export class ApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day'?: ApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour'?: number;
    /**
    * Total Value
    */
    'TotalValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "ApmHourlyDataPoint.DayEnum"
        },
        {
            "name": "Hour",
            "baseName": "Hour",
            "type": "number"
        },
        {
            "name": "TotalValue",
            "baseName": "TotalValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmHourlyDataPoint.attributeTypeMap;
    }
}

export namespace ApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class ApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved'?: number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved'?: number;
    /**
    * Currency based data
    */
    'CurrencyData'?: Array<StatisticsCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesSaved",
            "baseName": "EstimatedMinutesSaved",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesCouldSaved",
            "baseName": "EstimatedMinutesCouldSaved",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<StatisticsCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatistics.attributeTypeMap;
    }
}

/**
* APM status
*/
export class ApmStatus {
    /**
    * Indicates if APM is active or otherwise
    */
    'IsApmEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsApmEnabled",
            "baseName": "IsApmEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatus.attributeTypeMap;
    }
}

/**
* App
*/
export class App {
    /**
    * App Identifier
    */
    'AppId'?: string;
    /**
    * Has iOS app in Apple App Store. This is readonly.
    */
    'HasIosApp'?: boolean;
    /**
    * Has Android app in Google Play Store. This is readonly.
    */
    'HasAndroidApp'?: boolean;
    /**
    * Country identifier in ISO 3166-1 alpha-2 format.   This code is set automatically based on the locations of the Stores in the App.     The App Country is used    - to determine how to parse mobile phone numbers that are entered in their local numbering format   - to determine if country specific payment methods should be offered   - in various fraud checks
    */
    'CountryId'?: string;
    /**
    * Application Logo.
    */
    'LogoImageUrl'?: string;
    /**
    * Languages that have been selected to be available to customers.
    */
    'Languages'?: Array<Language>;
    /**
    * Lists all languages that are supported by Flipdish.
    */
    'AvailableAppLanguages'?: Array<Language>;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel'?: App.AppAccessLevelEnum;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet'?: Array<App.AppResourceSetEnum>;
    /**
    * Feature flags. These cannot be set by 3rd parties.
    */
    'Features'?: Array<string>;
    /**
    * Center of the map coordinates. This is used to center the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapCenter'?: Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapNorthEast'?: Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapSouthWest'?: Coordinates;
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: App.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "HasIosApp",
            "baseName": "HasIosApp",
            "type": "boolean"
        },
        {
            "name": "HasAndroidApp",
            "baseName": "HasAndroidApp",
            "type": "boolean"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "LogoImageUrl",
            "baseName": "LogoImageUrl",
            "type": "string"
        },
        {
            "name": "Languages",
            "baseName": "Languages",
            "type": "Array<Language>"
        },
        {
            "name": "AvailableAppLanguages",
            "baseName": "AvailableAppLanguages",
            "type": "Array<Language>"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "App.AppAccessLevelEnum"
        },
        {
            "name": "AppResourceSet",
            "baseName": "AppResourceSet",
            "type": "Array<App.AppResourceSetEnum>"
        },
        {
            "name": "Features",
            "baseName": "Features",
            "type": "Array<string>"
        },
        {
            "name": "MapCenter",
            "baseName": "MapCenter",
            "type": "Coordinates"
        },
        {
            "name": "MapNorthEast",
            "baseName": "MapNorthEast",
            "type": "Coordinates"
        },
        {
            "name": "MapSouthWest",
            "baseName": "MapSouthWest",
            "type": "Coordinates"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "App.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return App.attributeTypeMap;
    }
}

export namespace App {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum AppResourceSetEnum {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        EditAppAssets = <any> 'EditAppAssets',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        DeleteCampaignsConfigurations = <any> 'DeleteCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        EditStoreKioskSettings = <any> 'EditStoreKioskSettings',
        EditStoreOrderCapacity = <any> 'EditStoreOrderCapacity',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        UpdateVouchersExtendDisable = <any> 'UpdateVouchersExtendDisable',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewWebsiteDnsVerified = <any> 'ViewWebsiteDnsVerified',
        ViewWebsiteCertificateCreated = <any> 'ViewWebsiteCertificateCreated',
        ViewWebsiteCertificateRenewed = <any> 'ViewWebsiteCertificateRenewed',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        VerifyBankAccounts = <any> 'VerifyBankAccounts',
        ViewFeesConfigurations = <any> 'ViewFeesConfigurations',
        EditFeesConfigurations = <any> 'EditFeesConfigurations',
        ViewHydraConfig = <any> 'ViewHydraConfig',
        UpdateHydraConfigManage = <any> 'UpdateHydraConfigManage',
        InitiateBluetoothPairingMode = <any> 'InitiateBluetoothPairingMode',
        ViewCustomers = <any> 'ViewCustomers',
        EditCustomers = <any> 'EditCustomers',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        DownloadCustomerCsvExport = <any> 'DownloadCustomerCsvExport',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        ViewHydraAuditLogs = <any> 'ViewHydraAuditLogs',
        ViewPushNotificationAuditLogs = <any> 'ViewPushNotificationAuditLogs',
        ViewStripeCustomConnectedAccountAuditLogs = <any> 'ViewStripeCustomConnectedAccountAuditLogs',
        ViewKioskBluetoothDeviceAuditLogs = <any> 'ViewKioskBluetoothDeviceAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer',
        InviteDriverToApp = <any> 'InviteDriverToApp',
        GetDriverForApp = <any> 'GetDriverForApp',
        RemoveDriverFromApp = <any> 'RemoveDriverFromApp',
        AssignDriverToOrder = <any> 'AssignDriverToOrder',
        UnassignDriverFromOrder = <any> 'UnassignDriverFromOrder',
        UpdateOrdersDeliveryTrackingStatus = <any> 'UpdateOrdersDeliveryTrackingStatus',
        ViewPayouts = <any> 'ViewPayouts'
    }
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application compliance model
*/
export class AppCompliance {
    /**
    * App ID
    */
    'AppId'?: string;
    /**
    * Type of compliance.  This controls if the Flipdish websites and apps display cookie consent banners and adjust cookies to be inline with various regulations.   You should set this correctly based on your region.
    */
    'ComplianceType'?: AppCompliance.ComplianceTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "ComplianceType",
            "baseName": "ComplianceType",
            "type": "AppCompliance.ComplianceTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return AppCompliance.attributeTypeMap;
    }
}

export namespace AppCompliance {
    export enum ComplianceTypeEnum {
        Default = <any> 'Default',
        GdprCompliance = <any> 'GdprCompliance'
    }
}
/**
* Application configuration
*/
export class AppConfigUpdateModel {
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: AppConfigUpdateModel.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "AppConfigUpdateModel.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AppConfigUpdateModel.attributeTypeMap;
    }
}

export namespace AppConfigUpdateModel {
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application created event
*/
export class AppCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppCreatedEvent.attributeTypeMap;
    }
}

/**
* Application updated event
*/
export class AppUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * A summary of changes made
    */
    'Changes'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Changes",
            "baseName": "Changes",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppUpdatedEvent.attributeTypeMap;
    }
}

/**
* Assigned to Store Bank Account
*/
export class AssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id'?: number;
    /**
    * Name of Bank Account
    */
    'BankAccountName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "BankAccountName",
            "baseName": "BankAccountName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssignedBankAccount.attributeTypeMap;
    }
}

/**
* Period opening and closing balance
*/
export class BalanceDetails {
    'OpeningBalance'?: number;
    'ClosingBalance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BalanceDetails.attributeTypeMap;
    }
}

/**
* BANK ACCOUNT
*/
export class BankAccount {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields should be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccount.AccountStateEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccount.attributeTypeMap;
    }
}

export namespace BankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountCreate.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountCreate.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountCreate.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountCreate.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreate.attributeTypeMap;
    }
}

export namespace BankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDetail {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountDetail.AccountStateEnum;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountDetail.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetail.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountDetail.AccountStateEnum"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountDetail.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetail.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetail.attributeTypeMap;
    }
}

export namespace BankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* Represents a request to update bank account information details
*/
export class BankAccountDetailsUpdateRequest {
    /**
    * Address of the bank account
    */
    'BankAddress'?: string;
    /**
    * Address of the payee
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetailsUpdateRequest.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetailsUpdateRequest.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetailsUpdateRequest.attributeTypeMap;
    }
}

export namespace BankAccountDetailsUpdateRequest {
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountSummary {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: string;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountSummary.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountSummary.AccountStateEnum"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountSummary.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountSummary.attributeTypeMap;
    }
}

export namespace BankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountUpdatedEvent.attributeTypeMap;
    }
}

/**
* Status of the bluetooth terminal
*/
export class BluetoothTerminalStatus {
    /**
    * Serial Number
    */
    'SerialNumber'?: string;
    /**
    * Software Version
    */
    'SoftwareVersion'?: string;
    /**
    * Device Type
    */
    'DeviceType'?: BluetoothTerminalStatus.DeviceTypeEnum;
    /**
    * Device Status
    */
    'Status'?: BluetoothTerminalStatus.StatusEnum;
    /**
    * Indication of the battery level from 0 to 1
    */
    'BatteryLevel'?: number;
    /**
    * Last time the status was updated
    */
    'UpdateTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "SoftwareVersion",
            "baseName": "SoftwareVersion",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "BluetoothTerminalStatus.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "BluetoothTerminalStatus.StatusEnum"
        },
        {
            "name": "BatteryLevel",
            "baseName": "BatteryLevel",
            "type": "number"
        },
        {
            "name": "UpdateTime",
            "baseName": "UpdateTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BluetoothTerminalStatus.attributeTypeMap;
    }
}

export namespace BluetoothTerminalStatus {
    export enum DeviceTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
    export enum StatusEnum {
        NotConnected = <any> 'Not_Connected',
        Connecting = <any> 'Connecting',
        Connected = <any> 'Connected'
    }
}
/**
* 
*/
export class BusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId'?: number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverride.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BusinessHoursOverrideId",
            "baseName": "BusinessHoursOverrideId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverride.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverride.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverride.attributeTypeMap;
    }
}

export namespace BusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class BusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverrideBase.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverrideBase.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverrideBase.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverrideBase.attributeTypeMap;
    }
}

export namespace BusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriod {
    /**
    * Early
    */
    'Early'?: Range;
    /**
    * Late
    */
    'Late'?: Range;
    /**
    * Ranges
    */
    'Ranges'?: Array<Range>;
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Early",
            "baseName": "Early",
            "type": "Range"
        },
        {
            "name": "Late",
            "baseName": "Late",
            "type": "Range"
        },
        {
            "name": "Ranges",
            "baseName": "Ranges",
            "type": "Array<Range>"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriodBase.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriodBase.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Campaign statistics
*/
export class CampaignStatistics {
    /**
    * Number of issued vouchers
    */
    'VouchersIssued'?: number;
    /**
    * Number of redeemed vouchers
    */
    'VouchersRedeemed'?: number;
    /**
    * Conversion percentage of campaign (VouchersIssued / VouchersRedeemed)
    */
    'Conversion'?: number;
    /**
    * Sales generated by campaign (TotalAmount - FeeChargedToCustomer ie. the discounted sale value)
    */
    'SalesGenerated'?: number;
    /**
    * Return of investment percentage of campaign (TotalAmount / DiscountAmount)
    */
    'ReturnOfInvestment'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VouchersIssued",
            "baseName": "VouchersIssued",
            "type": "number"
        },
        {
            "name": "VouchersRedeemed",
            "baseName": "VouchersRedeemed",
            "type": "number"
        },
        {
            "name": "Conversion",
            "baseName": "Conversion",
            "type": "number"
        },
        {
            "name": "SalesGenerated",
            "baseName": "SalesGenerated",
            "type": "number"
        },
        {
            "name": "ReturnOfInvestment",
            "baseName": "ReturnOfInvestment",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignStatistics.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateCreatedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateCreatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateRenewedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateRenewedEvent.attributeTypeMap;
    }
}

/**
* Change password model
*/
export class ChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordModel.attributeTypeMap;
    }
}

/**
* Chargebacks breakdown
*/
export class ChargebackDetails {
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Chargeback refunded feeds
    */
    'ChargebackRefundedFees'?: number;
    /**
    * Number of chargebacks
    */
    'ChargebacksCount'?: number;
    /**
    * Total amount
    */
    'TotalChargebackCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "ChargebackRefundedFees",
            "baseName": "ChargebackRefundedFees",
            "type": "number"
        },
        {
            "name": "ChargebacksCount",
            "baseName": "ChargebacksCount",
            "type": "number"
        },
        {
            "name": "TotalChargebackCost",
            "baseName": "TotalChargebackCost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDetails.attributeTypeMap;
    }
}

/**
* Coordinates
*/
export class Coordinates {
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

/**
* List of field definitions per country
*/
export class CountryWithAccountFieldsDefinitions {
    /**
    * Country 2-letter ISO code
    */
    'CountryCode'?: string;
    /**
    * Display name of the country
    */
    'DisplayName'?: string;
    /**
    * Country support type (supported-by-stripe-cc, supported-by-flipdish,not-supported)
    */
    'SupportType'?: string;
    /**
    * Bank Account field definitions
    */
    'FieldDefinitions'?: Array<AccountFieldDefinition>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "SupportType",
            "baseName": "SupportType",
            "type": "string"
        },
        {
            "name": "FieldDefinitions",
            "baseName": "FieldDefinitions",
            "type": "Array<AccountFieldDefinition>"
        }    ];

    static getAttributeTypeMap() {
        return CountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Create account model
*/
export class CreateAccountModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;
    /**
    * Referral ID
    */
    'Rid'?: number;
    /**
    * Campaign ID
    */
    'Cid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "Rid",
            "baseName": "Rid",
            "type": "number"
        },
        {
            "name": "Cid",
            "baseName": "Cid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAccountModel.attributeTypeMap;
    }
}

/**
* Create menu object
*/
export class CreateFullMenu {
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<CreateFullMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<CreateMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: CreateFullMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: CreateFullMenu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<CreateFullMenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<CreateMenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "CreateFullMenu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "CreateFullMenu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenu.attributeTypeMap;
    }
}

export namespace CreateFullMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Create menu item option set
*/
export class CreateFullMenuItemOptionSet {
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<CreateFullMenuItemOptionSetItem>;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<CreateFullMenuItemOptionSetItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSet.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu item option set item
*/
export class CreateFullMenuItemOptionSetItem {
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu section
*/
export class CreateFullMenuSection {
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Menu items
    */
    'MenuItems'?: Array<CreateFullMenuSectionItem>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<CreateFullMenuSectionItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSection.attributeTypeMap;
    }
}

/**
* Create menu section item
*/
export class CreateFullMenuSectionItem {
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<CreateFullMenuItemOptionSet>;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: CreateFullMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<CreateFullMenuItemOptionSet>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "CreateFullMenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSectionItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class CreateMenuTaxRate {
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateMenuTaxRate.attributeTypeMap;
    }
}

/**
* Create metadata
*/
export class CreateMetadata {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateMetadata.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateTeammate {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: CreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "CreateTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeammate.attributeTypeMap;
    }
}

export namespace CreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* Voucher
*/
export class CreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType'?: CreateVoucher.VoucherTypeEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "CreateVoucher.VoucherTypeEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CreateVoucher.attributeTypeMap;
    }
}

export namespace CreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
}
/**
* Credit note details
*/
export class CreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RemainingCredit",
            "baseName": "RemainingCredit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreditNoteDetails.attributeTypeMap;
    }
}

export class CspReport {
    'Document_uri'?: string;
    'Referrer'?: string;
    'Violated_directive'?: string;
    'Effective_directive'?: string;
    'Original_policy'?: string;
    'Blocked_uri'?: string;
    'Status_code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Document_uri",
            "baseName": "Document-uri",
            "type": "string"
        },
        {
            "name": "Referrer",
            "baseName": "Referrer",
            "type": "string"
        },
        {
            "name": "Violated_directive",
            "baseName": "Violated-directive",
            "type": "string"
        },
        {
            "name": "Effective_directive",
            "baseName": "Effective-directive",
            "type": "string"
        },
        {
            "name": "Original_policy",
            "baseName": "Original-policy",
            "type": "string"
        },
        {
            "name": "Blocked_uri",
            "baseName": "Blocked-uri",
            "type": "string"
        },
        {
            "name": "Status_code",
            "baseName": "Status-code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CspReport.attributeTypeMap;
    }
}

export class CspReportRequest {
    'Csp_report'?: CspReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Csp_report",
            "baseName": "Csp-report",
            "type": "CspReport"
        }    ];

    static getAttributeTypeMap() {
        return CspReportRequest.attributeTypeMap;
    }
}

/**
* A single currency data piece, with no date
*/
export class CurrencyData {
    /**
    * Currency
    */
    'Currency'?: CurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CurrencyData.CurrencyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CurrencyData.attributeTypeMap;
    }
}

export namespace CurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines a customer
*/
export class Customer {
    /**
    * Id of the customer
    */
    'CustomerId'?: number;
    /**
    * Customer registration date
    */
    'RegistrationDate'?: Date;
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "RegistrationDate",
            "baseName": "RegistrationDate",
            "type": "Date"
        },
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

/**
* Customer consent updated
*/
export class CustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

/**
* Customer created event
*/
export class CustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreatedEvent.attributeTypeMap;
    }
}

/**
* Defines the order data required for customer driver tracking
*/
export class CustomerDeliveryTrackingOrder {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Pretified address string in country format
    */
    'Address'?: string;
    /**
    * Delivery Notes
    */
    'DeliveryNotes'?: string;
    /**
    * Phone number of the store
    */
    'StorePhoneNumber'?: string;
    /**
    * App Icon of the store
    */
    'AppIconUrl'?: string;
    /**
    * Order Tracking Code
    */
    'OrderTrackingCode'?: string;
    /**
    * Payment method description i.e Cash/Card/iDeal/Paypal
    */
    'PaymentMethodDescription'?: string;
    /**
    * Last 4 digits of the card if applicable otherwise null
    */
    'LastFourDigits'?: string;
    /**
    * Order lines of the order
    */
    'OrderLines'?: Array<CustomerDeliveryTrackingOrderLine>;
    /**
    * Total amount for the order including tax
    */
    'TotalAmount'?: number;
    /**
    * Currency
    */
    'Currency'?: CustomerDeliveryTrackingOrder.CurrencyEnum;
    /**
    * Customer Location Latitude
    */
    'Latitude'?: number;
    /**
    * Customer Location Longitude
    */
    'Longitude'?: number;
    /**
    * Order placed time
    */
    'Placed'?: Date;
    /**
    * Order requested for
    */
    'RequestedFor'?: Date;
    /**
    * Driver Id
    */
    'DriverId'?: number;
    /**
    * Driver Name
    */
    'DriverName'?: string;
    /**
    * Driver Image
    */
    'DriverImage'?: string;
    /**
    * 
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "DeliveryNotes",
            "baseName": "DeliveryNotes",
            "type": "string"
        },
        {
            "name": "StorePhoneNumber",
            "baseName": "StorePhoneNumber",
            "type": "string"
        },
        {
            "name": "AppIconUrl",
            "baseName": "AppIconUrl",
            "type": "string"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        },
        {
            "name": "PaymentMethodDescription",
            "baseName": "PaymentMethodDescription",
            "type": "string"
        },
        {
            "name": "LastFourDigits",
            "baseName": "LastFourDigits",
            "type": "string"
        },
        {
            "name": "OrderLines",
            "baseName": "OrderLines",
            "type": "Array<CustomerDeliveryTrackingOrderLine>"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CustomerDeliveryTrackingOrder.CurrencyEnum"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Placed",
            "baseName": "Placed",
            "type": "Date"
        },
        {
            "name": "RequestedFor",
            "baseName": "RequestedFor",
            "type": "Date"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "DriverName",
            "baseName": "DriverName",
            "type": "string"
        },
        {
            "name": "DriverImage",
            "baseName": "DriverImage",
            "type": "string"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrder.attributeTypeMap;
    }
}

export namespace CustomerDeliveryTrackingOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines an order line for driver tracking
*/
export class CustomerDeliveryTrackingOrderLine {
    /**
    * Item name from the order
    */
    'ItemName'?: string;
    /**
    * Selected option names
    */
    'SelectedOptions'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "SelectedOptions",
            "baseName": "SelectedOptions",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrderLine.attributeTypeMap;
    }
}

/**
* Customer summary
*/
export class CustomerSummary {
    /**
    * Customer identifier
    */
    'Id'?: number;
    /**
    * Customer name
    */
    'Name'?: string;
    /**
    * Customer email address
    */
    'EmailAddress'?: string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat'?: string;
    /**
    * Customer phone number
    */
    'PhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "PhoneNumberLocalFormat",
            "baseName": "PhoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSummary.attributeTypeMap;
    }
}

/**
* Defines a customer update model
*/
export class CustomerUpdateModel {
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdateModel.attributeTypeMap;
    }
}

/**
* Customer updated event
*/
export class CustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdatedEvent.attributeTypeMap;
    }
}

/**
* Delivery location
*/
export class DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Building
    */
    'Building'?: string;
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Town
    */
    'Town'?: string;
    /**
    * Post code
    */
    'PostCode'?: string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions'?: string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Building",
            "baseName": "Building",
            "type": "string"
        },
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Town",
            "baseName": "Town",
            "type": "string"
        },
        {
            "name": "PostCode",
            "baseName": "PostCode",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "PrettyAddressString",
            "baseName": "PrettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryLocation.attributeTypeMap;
    }
}

/**
* Delivery Zone
*/
export class DeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id'?: number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZone.attributeTypeMap;
    }
}

/**
* Delivery Zone Base
*/
export class DeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneBase.attributeTypeMap;
    }
}

/**
* Delivery Zone Created Event
*/
export class DeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneCreatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Deleted Event
*/
export class DeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneDeletedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Updated Event
*/
export class DeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

/**
* Device settings for Hydra
*/
export class DeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Volume",
            "baseName": "Volume",
            "type": "number"
        },
        {
            "name": "FontSize",
            "baseName": "FontSize",
            "type": "number"
        },
        {
            "name": "Brightness",
            "baseName": "Brightness",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceSettings.attributeTypeMap;
    }
}

/**
* Holds the information for the A and CNAME Records of a domain.
*/
export class DnsRecordInformation {
    /**
    * indicates whether the CNAME record is ready or not.
    */
    'IsCNameReady'?: boolean;
    /**
    * indicates whether the A record is ready or not.
    */
    'IsAReady'?: boolean;
    /**
    * indicates whether the API CNAME record is ready or not.
    */
    'IsApiCNameReady'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCNameReady",
            "baseName": "IsCNameReady",
            "type": "boolean"
        },
        {
            "name": "IsAReady",
            "baseName": "IsAReady",
            "type": "boolean"
        },
        {
            "name": "IsApiCNameReady",
            "baseName": "IsApiCNameReady",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DnsRecordInformation.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class DnsVerifiedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DnsVerifiedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class Driver {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * 
    */
    'Stores'?: Array<DriverStore>;
    /**
    * Profile image url
    */
    'ProfileImageUrl'?: string;
    /**
    * Driver Key
    */
    'DriverKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<DriverStore>"
        },
        {
            "name": "ProfileImageUrl",
            "baseName": "ProfileImageUrl",
            "type": "string"
        },
        {
            "name": "DriverKey",
            "baseName": "DriverKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Driver.attributeTypeMap;
    }
}

/**
* 
*/
export class DriverInvitation {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * Driver's name
    */
    'Name'?: string;
    /**
    * Assigned store IDs
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return DriverInvitation.attributeTypeMap;
    }
}

/**
* Driver Login model
*/
export class DriverLoginModel {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Code
    */
    'Code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverLoginModel.attributeTypeMap;
    }
}

/**
* Driver Request Login Pin model
*/
export class DriverRequestLoginPinModel {
    /**
    * Email address
    */
    'PhoneNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverRequestLoginPinModel.attributeTypeMap;
    }
}

/**
* 
*/
export class DriverStore {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Presence
    */
    'Presence'?: DriverStore.PresenceEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Presence",
            "baseName": "Presence",
            "type": "DriverStore.PresenceEnum"
        }    ];

    static getAttributeTypeMap() {
        return DriverStore.attributeTypeMap;
    }
}

export namespace DriverStore {
    export enum PresenceEnum {
        Offline = <any> 'Offline',
        Online = <any> 'Online'
    }
}
/**
* Order Terminal Notification
*/
export class EmvNotificationEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Notification Sent
    */
    'Notification'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * TerminalId
    */
    'TerminalId'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Expirey Date
    */
    'ExpDate'?: string;
    /**
    * Card Type
    */
    'CardType'?: string;
    /**
    * Payment Method
    */
    'PaymentMethod'?: string;
    /**
    * Masked Account Number
    */
    'AccountNumber'?: string;
    /**
    * Auth Code
    */
    'AuthCode'?: string;
    /**
    * Payment Provider Message
    */
    'ProviderMessage'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Notification",
            "baseName": "Notification",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ExpDate",
            "baseName": "ExpDate",
            "type": "string"
        },
        {
            "name": "CardType",
            "baseName": "CardType",
            "type": "string"
        },
        {
            "name": "PaymentMethod",
            "baseName": "PaymentMethod",
            "type": "string"
        },
        {
            "name": "AccountNumber",
            "baseName": "AccountNumber",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "ProviderMessage",
            "baseName": "ProviderMessage",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvNotificationEvent.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminal {
    /**
    * Flipdish Identifier of Terminal
    */
    'EmvTerminalId'?: number;
    /**
    * External Identifier of Terminal
    */
    'TerminalId'?: string;
    /**
    * URL at which terminal can be accessed
    */
    'Url'?: string;
    /**
    * TOKEN required to access terminal
    */
    'Token'?: string;
    /**
    * Identifies us to Provider
    */
    'SoftwareHouseId'?: string;
    /**
    * Identifies installer of terminal
    */
    'InstallerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "number"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "SoftwareHouseId",
            "baseName": "SoftwareHouseId",
            "type": "string"
        },
        {
            "name": "InstallerId",
            "baseName": "InstallerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminal.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminalWithAssignments {
    /**
    * Flipdish Internal identifier of the Terminal
    */
    'EmvTerminalId'?: string;
    /**
    * External Identifier of the Terminal
    */
    'TerminalId'?: string;
    /**
    * true if the terminal is assigned to a hydra device (e.g. a kiosk)
    */
    'IsAssignedToHydraDevice'?: boolean;
    /**
    * hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraConfigId'?: number;
    /**
    * external hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraDeviceId'?: string;
    /**
    * hydra device name (null if the terminal is not assigned to any hydra device)
    */
    'HydraName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "string"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "IsAssignedToHydraDevice",
            "baseName": "IsAssignedToHydraDevice",
            "type": "boolean"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "HydraDeviceId",
            "baseName": "HydraDeviceId",
            "type": "string"
        },
        {
            "name": "HydraName",
            "baseName": "HydraName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* 
*/
export class EventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent'?: Array<AppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent'?: Array<AppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent'?: Array<AnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent'?: Array<OrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent'?: Array<OrderDispatchedEvent>;
    /**
    * Order delivery tracking created events
    */
    'OrderCustomerTrackingCreatedEvent'?: Array<OrderCustomerTrackingCreatedEvent>;
    /**
    * Order delivery tracking updated events
    */
    'OrderDeliveryTrackingStatusUpdatedEvent'?: Array<OrderDeliveryTrackingStatusUpdatedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent'?: Array<OrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent'?: Array<OrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent'?: Array<OrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent'?: Array<OrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent'?: Array<OrderTipUpdatedEvent>;
    /**
    * Order Terminal Notification events
    */
    'OrderTerminalNotifications'?: Array<EmvNotificationEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent'?: Array<StoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent'?: Array<StoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent'?: Array<StoreAddressUpdatedEvent>;
    /**
    * Store kiosk setting updated events
    */
    'StoreKioskSettingUpdatedEvent'?: Array<StoreKioskSettingUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent'?: Array<DeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent'?: Array<DeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent'?: Array<DeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent'?: Array<StoreOpeningHoursUpdatedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreMenuAssignedEvent'?: Array<StoreMenuAssignedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent'?: Array<StoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent'?: Array<StoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store archived events
    */
    'StoreArchivedEvent'?: Array<StoreArchivedEvent>;
    /**
    * Store unarchived events
    */
    'StoreUnarchivedEvent'?: Array<StoreUnarchivedEvent>;
    /**
    * Store published events
    */
    'StorePublishedEvent'?: Array<StorePublishedEvent>;
    /**
    * Store unpublished events
    */
    'StoreUnpublishedEvent'?: Array<StoreUnpublishedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent'?: Array<StoreUpdatedEvent>;
    /**
    * Store updated events
    */
    'StorePreOrderConfigUpdatedEvent'?: Array<StorePreOrderConfigUpdatedEvent>;
    /**
    * Store logo created events
    */
    'StoreLogoCreatedEvent'?: Array<StoreLogoCreatedEvent>;
    /**
    * Store logo updated events
    */
    'StoreLogoUpdatedEvent'?: Array<StoreLogoUpdatedEvent>;
    /**
    * Store logo deleted events
    */
    'StoreLogoDeletedEvent'?: Array<StoreLogoDeletedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent'?: Array<MenuCreatedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent'?: Array<MenuUpdatedEvent>;
    /**
    * Menu uploaded events
    */
    'MenuUploadedEvent'?: Array<MenuUploadedEvent>;
    /**
    * Menu bulk events
    */
    'MenuBulkEditEvent'?: Array<MenuBulkEditEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent'?: Array<MenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent'?: Array<MenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent'?: Array<MenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent'?: Array<MenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent'?: Array<MenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent'?: Array<MenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent'?: Array<MenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent'?: Array<MenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent'?: Array<MenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent'?: Array<MenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent'?: Array<MenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent'?: Array<MenuItemOptionSetItemDeletedEvent>;
    /**
    * Menu checkpoint created event
    */
    'MenuCheckpointCreatedEvent'?: Array<MenuCheckpointCreatedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent'?: Array<StoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent'?: Array<StoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent'?: Array<StoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent'?: Array<CustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent'?: Array<CustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent'?: Array<CustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent'?: Array<WebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent'?: Array<WebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent'?: Array<WebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent'?: Array<PrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent'?: Array<PrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent'?: Array<PrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent'?: Array<PrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent'?: Array<PhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent'?: Array<PhoneCallEndedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent'?: Array<LoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent'?: Array<LoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent'?: Array<LoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent'?: Array<RetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent'?: Array<RetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent'?: Array<RetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent'?: Array<SmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent'?: Array<UserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent'?: Array<UserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent'?: Array<UserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent'?: Array<UserDeletedEvent>;
    /**
    * User password created event
    */
    'UserCreatedPasswordEvent'?: Array<UserPasswordCreatedEvent>;
    /**
    * User answered signup questions event
    */
    'UserAnsweredSignupQuestionsEvent'?: Array<UserAnsweredSignupQuestionsEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent'?: Array<VoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent'?: Array<VoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent'?: Array<VoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent'?: Array<TeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent'?: Array<TeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent'?: Array<TeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent'?: Array<TeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent'?: Array<BankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent'?: Array<BankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent'?: Array<BankAccountDeletedEvent>;
    /**
    * Hydra assigned event
    */
    'HydraAssignedEvent'?: Array<HydraAssignedEvent>;
    /**
    * Hydra reset requested event
    */
    'HydraRequestResetEvent'?: Array<HydraRequestResetEvent>;
    /**
    * Hydra store assigned event
    */
    'HydraStoreAssignedEvent'?: Array<HydraStoreAssignedEvent>;
    /**
    * Hydra store unassigned
    */
    'HydraStoreUnassignedEvent'?: Array<HydraStoreUnassignedEvent>;
    /**
    * Hydra settings changed event
    */
    'HydraSettingChangedEvent'?: Array<HydraSettingChangedEvent>;
    /**
    * Hydra un-assigned event
    */
    'HydraUnAssignedEvent'?: Array<HydraUnAssignedEvent>;
    /**
    * Hydra connection state change
    */
    'HydraConnectionStatusChangedEvent'?: Array<HydraConnectionStatusChangedEvent>;
    /**
    * Bluetooth Pairing Mode initiated
    */
    'KioskBluetoothPairingModeEvent'?: Array<KioskBluetoothPairingModeEvent>;
    /**
    * Bluetooth Unpairing Mode initiated
    */
    'KioskBluetoothUnpairingModeEvent'?: Array<KioskBluetoothUnpairingModeEvent>;
    /**
    * Bluetooth Terminal Updated
    */
    'KioskBluetoothTerminalUpdatedEvent'?: Array<KioskBluetoothTerminalUpdatedEvent>;
    /**
    * Trigger bluetooth payment terminal update checker
    */
    'KioskBluetoothTerminalInitiateUpdateCheckEvent'?: Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>;
    /**
    * Bluetooth Terminal Initiate Update
    */
    'KioskBluetoothInstallUpdateInitiateEvent'?: Array<KioskBluetoothInstallUpdateInitiateEvent>;
    /**
    * Bluetooth Terminal Cancel Update Install
    */
    'KioskBluetoothTerminalCancelUpdateEvent'?: Array<KioskBluetoothTerminalCancelUpdateEvent>;
    /**
    * Bluetooth Payment Terminal Firmware Version Status Info
    */
    'KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent'?: Array<KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent>;
    /**
    * Bluetooth Terminal Update Installation Status
    */
    'KioskBluetoothTerminalInstallationStatusEvent'?: Array<KioskBluetoothTerminalInstallationStatusEvent>;
    /**
    * Push notification scheduled event
    */
    'PushNotificationScheduledEvent'?: Array<PushNotificationScheduledEvent>;
    /**
    * Push notification sent event
    */
    'PushNotificationSentEvent'?: Array<PushNotificationSentEvent>;
    /**
    * Push notification deleted event
    */
    'PushNotificationDeletedEvent'?: Array<PushNotificationDeletedEvent>;
    /**
    * DNS Verified
    */
    'DnsVerifiedEvent'?: Array<DnsVerifiedEvent>;
    /**
    * Certificate created
    */
    'CertificateCreatedEvent'?: Array<CertificateCreatedEvent>;
    /**
    * Certificate renewed
    */
    'CertificateRenewedEvent'?: Array<CertificateRenewedEvent>;
    /**
    * Panacea vanity url updated
    */
    'WebsiteVanityUrlUpdatedEvent'?: Array<WebsiteVanityUrlUpdatedEvent>;
    /**
    * Website updated
    */
    'WebsiteUpdatedEvent'?: Array<WebsiteUpdatedEvent>;
    /**
    * Order capacity config updated
    */
    'OrderCapacityUpdatedEvent'?: Array<OrderCapacityConfigUpdatedEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppCreatedEvent",
            "baseName": "AppCreatedEvent",
            "type": "Array<AppCreatedEvent>"
        },
        {
            "name": "AppUpdatedEvent",
            "baseName": "AppUpdatedEvent",
            "type": "Array<AppUpdatedEvent>"
        },
        {
            "name": "AnalyticsClientEvent",
            "baseName": "AnalyticsClientEvent",
            "type": "Array<AnalyticsClientEvent>"
        },
        {
            "name": "OrderAcceptedEvent",
            "baseName": "OrderAcceptedEvent",
            "type": "Array<OrderAcceptedEvent>"
        },
        {
            "name": "OrderDispatchedEvent",
            "baseName": "OrderDispatchedEvent",
            "type": "Array<OrderDispatchedEvent>"
        },
        {
            "name": "OrderCustomerTrackingCreatedEvent",
            "baseName": "OrderCustomerTrackingCreatedEvent",
            "type": "Array<OrderCustomerTrackingCreatedEvent>"
        },
        {
            "name": "OrderDeliveryTrackingStatusUpdatedEvent",
            "baseName": "OrderDeliveryTrackingStatusUpdatedEvent",
            "type": "Array<OrderDeliveryTrackingStatusUpdatedEvent>"
        },
        {
            "name": "OrderCreatedEvent",
            "baseName": "OrderCreatedEvent",
            "type": "Array<OrderCreatedEvent>"
        },
        {
            "name": "OrderRatingUpdatedEvent",
            "baseName": "OrderRatingUpdatedEvent",
            "type": "Array<OrderRatingUpdatedEvent>"
        },
        {
            "name": "OrderRefundedEvent",
            "baseName": "OrderRefundedEvent",
            "type": "Array<OrderRefundedEvent>"
        },
        {
            "name": "OrderRejectedEvent",
            "baseName": "OrderRejectedEvent",
            "type": "Array<OrderRejectedEvent>"
        },
        {
            "name": "OrderTipUpdatedEvent",
            "baseName": "OrderTipUpdatedEvent",
            "type": "Array<OrderTipUpdatedEvent>"
        },
        {
            "name": "OrderTerminalNotifications",
            "baseName": "OrderTerminalNotifications",
            "type": "Array<EmvNotificationEvent>"
        },
        {
            "name": "StoreCreatedEvent",
            "baseName": "StoreCreatedEvent",
            "type": "Array<StoreCreatedEvent>"
        },
        {
            "name": "StoreDeletedEvent",
            "baseName": "StoreDeletedEvent",
            "type": "Array<StoreDeletedEvent>"
        },
        {
            "name": "StoreAddressUpdatedEvent",
            "baseName": "StoreAddressUpdatedEvent",
            "type": "Array<StoreAddressUpdatedEvent>"
        },
        {
            "name": "StoreKioskSettingUpdatedEvent",
            "baseName": "StoreKioskSettingUpdatedEvent",
            "type": "Array<StoreKioskSettingUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneCreatedEvent",
            "baseName": "DeliveryZoneCreatedEvent",
            "type": "Array<DeliveryZoneCreatedEvent>"
        },
        {
            "name": "DeliveryZoneUpdatedEvent",
            "baseName": "DeliveryZoneUpdatedEvent",
            "type": "Array<DeliveryZoneUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneDeletedEvent",
            "baseName": "DeliveryZoneDeletedEvent",
            "type": "Array<DeliveryZoneDeletedEvent>"
        },
        {
            "name": "StoreOpeningHoursUpdatedEvent",
            "baseName": "StoreOpeningHoursUpdatedEvent",
            "type": "Array<StoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "StoreMenuAssignedEvent",
            "baseName": "StoreMenuAssignedEvent",
            "type": "Array<StoreMenuAssignedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideCreatedEvent",
            "baseName": "StoreBusinessHoursOverrideCreatedEvent",
            "type": "Array<StoreBusinessHoursOverrideCreatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideDeletedEvent",
            "baseName": "StoreBusinessHoursOverrideDeletedEvent",
            "type": "Array<StoreBusinessHoursOverrideDeletedEvent>"
        },
        {
            "name": "StoreArchivedEvent",
            "baseName": "StoreArchivedEvent",
            "type": "Array<StoreArchivedEvent>"
        },
        {
            "name": "StoreUnarchivedEvent",
            "baseName": "StoreUnarchivedEvent",
            "type": "Array<StoreUnarchivedEvent>"
        },
        {
            "name": "StorePublishedEvent",
            "baseName": "StorePublishedEvent",
            "type": "Array<StorePublishedEvent>"
        },
        {
            "name": "StoreUnpublishedEvent",
            "baseName": "StoreUnpublishedEvent",
            "type": "Array<StoreUnpublishedEvent>"
        },
        {
            "name": "StoreUpdatedEvent",
            "baseName": "StoreUpdatedEvent",
            "type": "Array<StoreUpdatedEvent>"
        },
        {
            "name": "StorePreOrderConfigUpdatedEvent",
            "baseName": "StorePreOrderConfigUpdatedEvent",
            "type": "Array<StorePreOrderConfigUpdatedEvent>"
        },
        {
            "name": "StoreLogoCreatedEvent",
            "baseName": "StoreLogoCreatedEvent",
            "type": "Array<StoreLogoCreatedEvent>"
        },
        {
            "name": "StoreLogoUpdatedEvent",
            "baseName": "StoreLogoUpdatedEvent",
            "type": "Array<StoreLogoUpdatedEvent>"
        },
        {
            "name": "StoreLogoDeletedEvent",
            "baseName": "StoreLogoDeletedEvent",
            "type": "Array<StoreLogoDeletedEvent>"
        },
        {
            "name": "MenuCreatedEvent",
            "baseName": "MenuCreatedEvent",
            "type": "Array<MenuCreatedEvent>"
        },
        {
            "name": "MenuUpdatedEvent",
            "baseName": "MenuUpdatedEvent",
            "type": "Array<MenuUpdatedEvent>"
        },
        {
            "name": "MenuUploadedEvent",
            "baseName": "MenuUploadedEvent",
            "type": "Array<MenuUploadedEvent>"
        },
        {
            "name": "MenuBulkEditEvent",
            "baseName": "MenuBulkEditEvent",
            "type": "Array<MenuBulkEditEvent>"
        },
        {
            "name": "MenuSectionCreatedEvent",
            "baseName": "MenuSectionCreatedEvent",
            "type": "Array<MenuSectionCreatedEvent>"
        },
        {
            "name": "MenuSectionUpdatedEvent",
            "baseName": "MenuSectionUpdatedEvent",
            "type": "Array<MenuSectionUpdatedEvent>"
        },
        {
            "name": "MenuSectionDeletedEvent",
            "baseName": "MenuSectionDeletedEvent",
            "type": "Array<MenuSectionDeletedEvent>"
        },
        {
            "name": "MenuSectionItemCreatedEvent",
            "baseName": "MenuSectionItemCreatedEvent",
            "type": "Array<MenuSectionItemCreatedEvent>"
        },
        {
            "name": "MenuSectionItemUpdatedEvent",
            "baseName": "MenuSectionItemUpdatedEvent",
            "type": "Array<MenuSectionItemUpdatedEvent>"
        },
        {
            "name": "MenuSectionItemDeletedEvent",
            "baseName": "MenuSectionItemDeletedEvent",
            "type": "Array<MenuSectionItemDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetCreatedEvent",
            "baseName": "MenuItemOptionSetCreatedEvent",
            "type": "Array<MenuItemOptionSetCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetUpdatedEvent",
            "baseName": "MenuItemOptionSetUpdatedEvent",
            "type": "Array<MenuItemOptionSetUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetDeletedEvent",
            "baseName": "MenuItemOptionSetDeletedEvent",
            "type": "Array<MenuItemOptionSetDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemCreatedEvent",
            "baseName": "MenuItemOptionSetItemCreatedEvent",
            "type": "Array<MenuItemOptionSetItemCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemUpdatedEvent",
            "baseName": "MenuItemOptionSetItemUpdatedEvent",
            "type": "Array<MenuItemOptionSetItemUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemDeletedEvent",
            "baseName": "MenuItemOptionSetItemDeletedEvent",
            "type": "Array<MenuItemOptionSetItemDeletedEvent>"
        },
        {
            "name": "MenuCheckpointCreatedEvent",
            "baseName": "MenuCheckpointCreatedEvent",
            "type": "Array<MenuCheckpointCreatedEvent>"
        },
        {
            "name": "StoreGroupCreatedEvent",
            "baseName": "StoreGroupCreatedEvent",
            "type": "Array<StoreGroupCreatedEvent>"
        },
        {
            "name": "StoreGroupUpdatedEvent",
            "baseName": "StoreGroupUpdatedEvent",
            "type": "Array<StoreGroupUpdatedEvent>"
        },
        {
            "name": "StoreGroupDeletedEvent",
            "baseName": "StoreGroupDeletedEvent",
            "type": "Array<StoreGroupDeletedEvent>"
        },
        {
            "name": "CustomerCreatedEvent",
            "baseName": "CustomerCreatedEvent",
            "type": "Array<CustomerCreatedEvent>"
        },
        {
            "name": "CustomerUpdatedEvent",
            "baseName": "CustomerUpdatedEvent",
            "type": "Array<CustomerUpdatedEvent>"
        },
        {
            "name": "CustomerConsentUpdatedEvent",
            "baseName": "CustomerConsentUpdatedEvent",
            "type": "Array<CustomerConsentUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionCreatedEvent",
            "baseName": "WebhookSubscriptionCreatedEvent",
            "type": "Array<WebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "WebhookSubscriptionUpdatedEvent",
            "baseName": "WebhookSubscriptionUpdatedEvent",
            "type": "Array<WebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionDeletedEvent",
            "baseName": "WebhookSubscriptionDeletedEvent",
            "type": "Array<WebhookSubscriptionDeletedEvent>"
        },
        {
            "name": "PrinterTurnedOnEvent",
            "baseName": "PrinterTurnedOnEvent",
            "type": "Array<PrinterTurnedOnEvent>"
        },
        {
            "name": "PrinterTurnedOffEvent",
            "baseName": "PrinterTurnedOffEvent",
            "type": "Array<PrinterTurnedOffEvent>"
        },
        {
            "name": "PrinterAssignedToStoreEvent",
            "baseName": "PrinterAssignedToStoreEvent",
            "type": "Array<PrinterAssignedToStoreEvent>"
        },
        {
            "name": "PrinterUnassignedFromStoreEvent",
            "baseName": "PrinterUnassignedFromStoreEvent",
            "type": "Array<PrinterUnassignedFromStoreEvent>"
        },
        {
            "name": "PhoneCallStartedEvent",
            "baseName": "PhoneCallStartedEvent",
            "type": "Array<PhoneCallStartedEvent>"
        },
        {
            "name": "PhoneCallEndedEvent",
            "baseName": "PhoneCallEndedEvent",
            "type": "Array<PhoneCallEndedEvent>"
        },
        {
            "name": "LoyaltyCampaignCreatedEvent",
            "baseName": "LoyaltyCampaignCreatedEvent",
            "type": "Array<LoyaltyCampaignCreatedEvent>"
        },
        {
            "name": "LoyaltyCampaignDeletedEvent",
            "baseName": "LoyaltyCampaignDeletedEvent",
            "type": "Array<LoyaltyCampaignDeletedEvent>"
        },
        {
            "name": "LoyaltyCampaignUpdatedEvent",
            "baseName": "LoyaltyCampaignUpdatedEvent",
            "type": "Array<LoyaltyCampaignUpdatedEvent>"
        },
        {
            "name": "RetentionCampaignCreatedEvent",
            "baseName": "RetentionCampaignCreatedEvent",
            "type": "Array<RetentionCampaignCreatedEvent>"
        },
        {
            "name": "RetentionCampaignDeletedEvent",
            "baseName": "RetentionCampaignDeletedEvent",
            "type": "Array<RetentionCampaignDeletedEvent>"
        },
        {
            "name": "RetentionCampaignUpdatedEvent",
            "baseName": "RetentionCampaignUpdatedEvent",
            "type": "Array<RetentionCampaignUpdatedEvent>"
        },
        {
            "name": "SmsReceivedEvent",
            "baseName": "SmsReceivedEvent",
            "type": "Array<SmsReceivedEvent>"
        },
        {
            "name": "UserLoginEvent",
            "baseName": "UserLoginEvent",
            "type": "Array<UserLoginEvent>"
        },
        {
            "name": "UserCreatedEvent",
            "baseName": "UserCreatedEvent",
            "type": "Array<UserCreatedEvent>"
        },
        {
            "name": "UserUpdatedEvent",
            "baseName": "UserUpdatedEvent",
            "type": "Array<UserUpdatedEvent>"
        },
        {
            "name": "UserDeletedEvent",
            "baseName": "UserDeletedEvent",
            "type": "Array<UserDeletedEvent>"
        },
        {
            "name": "UserCreatedPasswordEvent",
            "baseName": "UserCreatedPasswordEvent",
            "type": "Array<UserPasswordCreatedEvent>"
        },
        {
            "name": "UserAnsweredSignupQuestionsEvent",
            "baseName": "UserAnsweredSignupQuestionsEvent",
            "type": "Array<UserAnsweredSignupQuestionsEvent>"
        },
        {
            "name": "VoucherCreatedEvent",
            "baseName": "VoucherCreatedEvent",
            "type": "Array<VoucherCreatedEvent>"
        },
        {
            "name": "VoucherUpdatedEvent",
            "baseName": "VoucherUpdatedEvent",
            "type": "Array<VoucherUpdatedEvent>"
        },
        {
            "name": "VoucherDeletedEvent",
            "baseName": "VoucherDeletedEvent",
            "type": "Array<VoucherDeletedEvent>"
        },
        {
            "name": "TeammateInviteSentEvent",
            "baseName": "TeammateInviteSentEvent",
            "type": "Array<TeammateInviteSentEvent>"
        },
        {
            "name": "TeammateInviteAcceptedEvent",
            "baseName": "TeammateInviteAcceptedEvent",
            "type": "Array<TeammateInviteAcceptedEvent>"
        },
        {
            "name": "TeammateUpdatedEvent",
            "baseName": "TeammateUpdatedEvent",
            "type": "Array<TeammateUpdatedEvent>"
        },
        {
            "name": "TeammateDeletedEvent",
            "baseName": "TeammateDeletedEvent",
            "type": "Array<TeammateDeletedEvent>"
        },
        {
            "name": "BankAccountCreatedEvent",
            "baseName": "BankAccountCreatedEvent",
            "type": "Array<BankAccountCreatedEvent>"
        },
        {
            "name": "BankAccountUpdatedEvent",
            "baseName": "BankAccountUpdatedEvent",
            "type": "Array<BankAccountUpdatedEvent>"
        },
        {
            "name": "BankAccountDeletedEvent",
            "baseName": "BankAccountDeletedEvent",
            "type": "Array<BankAccountDeletedEvent>"
        },
        {
            "name": "HydraAssignedEvent",
            "baseName": "HydraAssignedEvent",
            "type": "Array<HydraAssignedEvent>"
        },
        {
            "name": "HydraRequestResetEvent",
            "baseName": "HydraRequestResetEvent",
            "type": "Array<HydraRequestResetEvent>"
        },
        {
            "name": "HydraStoreAssignedEvent",
            "baseName": "HydraStoreAssignedEvent",
            "type": "Array<HydraStoreAssignedEvent>"
        },
        {
            "name": "HydraStoreUnassignedEvent",
            "baseName": "HydraStoreUnassignedEvent",
            "type": "Array<HydraStoreUnassignedEvent>"
        },
        {
            "name": "HydraSettingChangedEvent",
            "baseName": "HydraSettingChangedEvent",
            "type": "Array<HydraSettingChangedEvent>"
        },
        {
            "name": "HydraUnAssignedEvent",
            "baseName": "HydraUnAssignedEvent",
            "type": "Array<HydraUnAssignedEvent>"
        },
        {
            "name": "HydraConnectionStatusChangedEvent",
            "baseName": "HydraConnectionStatusChangedEvent",
            "type": "Array<HydraConnectionStatusChangedEvent>"
        },
        {
            "name": "KioskBluetoothPairingModeEvent",
            "baseName": "KioskBluetoothPairingModeEvent",
            "type": "Array<KioskBluetoothPairingModeEvent>"
        },
        {
            "name": "KioskBluetoothUnpairingModeEvent",
            "baseName": "KioskBluetoothUnpairingModeEvent",
            "type": "Array<KioskBluetoothUnpairingModeEvent>"
        },
        {
            "name": "KioskBluetoothTerminalUpdatedEvent",
            "baseName": "KioskBluetoothTerminalUpdatedEvent",
            "type": "Array<KioskBluetoothTerminalUpdatedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "baseName": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "type": "Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>"
        },
        {
            "name": "KioskBluetoothInstallUpdateInitiateEvent",
            "baseName": "KioskBluetoothInstallUpdateInitiateEvent",
            "type": "Array<KioskBluetoothInstallUpdateInitiateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalCancelUpdateEvent",
            "baseName": "KioskBluetoothTerminalCancelUpdateEvent",
            "type": "Array<KioskBluetoothTerminalCancelUpdateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent",
            "baseName": "KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent",
            "type": "Array<KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInstallationStatusEvent",
            "baseName": "KioskBluetoothTerminalInstallationStatusEvent",
            "type": "Array<KioskBluetoothTerminalInstallationStatusEvent>"
        },
        {
            "name": "PushNotificationScheduledEvent",
            "baseName": "PushNotificationScheduledEvent",
            "type": "Array<PushNotificationScheduledEvent>"
        },
        {
            "name": "PushNotificationSentEvent",
            "baseName": "PushNotificationSentEvent",
            "type": "Array<PushNotificationSentEvent>"
        },
        {
            "name": "PushNotificationDeletedEvent",
            "baseName": "PushNotificationDeletedEvent",
            "type": "Array<PushNotificationDeletedEvent>"
        },
        {
            "name": "DnsVerifiedEvent",
            "baseName": "DnsVerifiedEvent",
            "type": "Array<DnsVerifiedEvent>"
        },
        {
            "name": "CertificateCreatedEvent",
            "baseName": "CertificateCreatedEvent",
            "type": "Array<CertificateCreatedEvent>"
        },
        {
            "name": "CertificateRenewedEvent",
            "baseName": "CertificateRenewedEvent",
            "type": "Array<CertificateRenewedEvent>"
        },
        {
            "name": "WebsiteVanityUrlUpdatedEvent",
            "baseName": "WebsiteVanityUrlUpdatedEvent",
            "type": "Array<WebsiteVanityUrlUpdatedEvent>"
        },
        {
            "name": "WebsiteUpdatedEvent",
            "baseName": "WebsiteUpdatedEvent",
            "type": "Array<WebsiteUpdatedEvent>"
        },
        {
            "name": "OrderCapacityUpdatedEvent",
            "baseName": "OrderCapacityUpdatedEvent",
            "type": "Array<OrderCapacityConfigUpdatedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return EventSearchResult.attributeTypeMap;
    }
}

/**
* Fee Summary
*/
export class FeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount'?: number;
    /**
    * Percentage rate
    */
    'PercentageRate'?: number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeAmount",
            "baseName": "FeeAmount",
            "type": "number"
        },
        {
            "name": "PercentageRate",
            "baseName": "PercentageRate",
            "type": "number"
        },
        {
            "name": "PerTransactionFee",
            "baseName": "PerTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeeSummary.attributeTypeMap;
    }
}

/**
* Base Event
*/
export class FlipdishEventBase {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishEventBase.attributeTypeMap;
    }
}

/**
* Fees breakdown
*/
export class FlipdishFeesDetails {
    /**
    * Fees on online sales
    */
    'OnlineSalesFees'?: number;
    /**
    * Fees on cash sales
    */
    'CashSalesFees'?: number;
    /**
    * Total online and cash sales
    */
    'TotalSalesFees'?: number;
    /**
    * Fees on refunds for online sales
    */
    'OnlineSalesRefundedFees'?: number;
    /**
    * Fees on refunds for cash sales
    */
    'CashSalesRefundedFees'?: number;
    /**
    * VAT on sales fees
    */
    'SalesFeesVat'?: number;
    /**
    * Total fees
    */
    'TotalFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesFees",
            "baseName": "OnlineSalesFees",
            "type": "number"
        },
        {
            "name": "CashSalesFees",
            "baseName": "CashSalesFees",
            "type": "number"
        },
        {
            "name": "TotalSalesFees",
            "baseName": "TotalSalesFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedFees",
            "baseName": "OnlineSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedFees",
            "baseName": "CashSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "SalesFeesVat",
            "baseName": "SalesFeesVat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishFeesDetails.attributeTypeMap;
    }
}

/**
* Describes coordinates that have a group
*/
export class GroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude'?: number;
    /**
    * Longitude of this coordinate
    */
    'Longitude'?: number;
    /**
    * Count of members in the group
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupedCoordinates.attributeTypeMap;
    }
}

/**
* 
*/
export class HomeAction {
    /**
    * 
    */
    'HomeActionId'?: number;
    /**
    * Type of Action
    */
    'HomeActionType'?: HomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order'?: number;
    /**
    * 
    */
    'TitleKey'?: string;
    /**
    * 
    */
    'ActionKey'?: string;
    /**
    * 
    */
    'DescriptionKey'?: string;
    /**
    * 
    */
    'Action'?: string;
    /**
    * 
    */
    'Dismissible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HomeActionId",
            "baseName": "HomeActionId",
            "type": "number"
        },
        {
            "name": "HomeActionType",
            "baseName": "HomeActionType",
            "type": "HomeAction.HomeActionTypeEnum"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "number"
        },
        {
            "name": "TitleKey",
            "baseName": "TitleKey",
            "type": "string"
        },
        {
            "name": "ActionKey",
            "baseName": "ActionKey",
            "type": "string"
        },
        {
            "name": "DescriptionKey",
            "baseName": "DescriptionKey",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "Dismissible",
            "baseName": "Dismissible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HomeAction.attributeTypeMap;
    }
}

export namespace HomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class HomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalMoneySaved",
            "baseName": "TotalMoneySaved",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return HomeStatistics.attributeTypeMap;
    }
}

/**
* Http Request and Response Log
*/
export class HttpRequestAndResponseLog {
    /**
    * Id of the log
    */
    'Guid'?: string;
    /**
    * Verb associated with the HTTP call.
    */
    'Verb'?: string;
    /**
    * Http request URI.
    */
    'RequestUri'?: string;
    /**
    * Http response status code.
    */
    'StatusCode'?: number;
    /**
    * Http response status line.
    */
    'ReasonPhrase'?: string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds'?: number;
    /**
    * Identity of the caller.
    */
    'UserId'?: string;
    /**
    * Ip address of the caller
    */
    'IpAddress'?: string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime'?: string;
    /**
    * Http request headers.
    */
    'RequestHeaders'?: { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody'?: string;
    /**
    * Http request content-length
    */
    'RequestLength'?: number;
    /**
    * Http response headers.
    */
    'ResponseHeaders'?: { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody'?: string;
    /**
    * Http response content-length
    */
    'ResponseLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Guid",
            "baseName": "Guid",
            "type": "string"
        },
        {
            "name": "Verb",
            "baseName": "Verb",
            "type": "string"
        },
        {
            "name": "RequestUri",
            "baseName": "RequestUri",
            "type": "string"
        },
        {
            "name": "StatusCode",
            "baseName": "StatusCode",
            "type": "number"
        },
        {
            "name": "ReasonPhrase",
            "baseName": "ReasonPhrase",
            "type": "string"
        },
        {
            "name": "CallDurationInMilliseconds",
            "baseName": "CallDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        },
        {
            "name": "CreatedDateTime",
            "baseName": "CreatedDateTime",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "RequestLength",
            "baseName": "RequestLength",
            "type": "number"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "ResponseLength",
            "baseName": "ResponseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Hydra assigned event
*/
export class HydraAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraAssignedEvent.attributeTypeMap;
    }
}

/**
* Hydra configuration
*/
export class HydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': Array<HydraConfig.PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': DeviceSettings;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinimumVersion",
            "baseName": "MinimumVersion",
            "type": "string"
        },
        {
            "name": "PaymentOptions",
            "baseName": "PaymentOptions",
            "type": "Array<HydraConfig.PaymentOptionsEnum>"
        },
        {
            "name": "DeviceSettings",
            "baseName": "DeviceSettings",
            "type": "DeviceSettings"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConfig.attributeTypeMap;
    }
}

export namespace HydraConfig {
    export enum PaymentOptionsEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hydra Connection Status Changed Event
*/
export class HydraConnectionStatusChangedEvent {
    /**
    * Hydra Device Id
    */
    'DeviceId'?: string;
    /**
    * Hydra Device Status
    */
    'HydraDeviceStatus'?: HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum;
    /**
    * Hydra Last Poll Time
    */
    'PollTime'?: Date;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "HydraDeviceStatus",
            "baseName": "HydraDeviceStatus",
            "type": "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum"
        },
        {
            "name": "PollTime",
            "baseName": "PollTime",
            "type": "Date"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConnectionStatusChangedEvent.attributeTypeMap;
    }
}

export namespace HydraConnectionStatusChangedEvent {
    export enum HydraDeviceStatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra device details
*/
export class HydraDeviceDetails {
    /**
    * Flipdish internal device identifier
    */
    'HydraConfigId'?: number;
    /**
    * Device Id or Serial Number
    */
    'DeviceId'?: string;
    /**
    * Type of the device
    */
    'DeviceType'?: HydraDeviceDetails.DeviceTypeEnum;
    /**
    * Status of the device
    */
    'Status'?: HydraDeviceDetails.StatusEnum;
    /**
    * Device Name
    */
    'DeviceName'?: string;
    /**
    * Store Names
    */
    'StoreNames'?: Array<HydraStoreData>;
    /**
    * Last poll time in UTC
    */
    'LastPollUtc'?: Date;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "HydraDeviceDetails.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "HydraDeviceDetails.StatusEnum"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<HydraStoreData>"
        },
        {
            "name": "LastPollUtc",
            "baseName": "LastPollUtc",
            "type": "Date"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraDeviceDetails.attributeTypeMap;
    }
}

export namespace HydraDeviceDetails {
    export enum DeviceTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
    export enum StatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra registration result
*/
export class HydraRegistrationRequest {
    /**
    * Stores to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HydraRegistrationRequest.attributeTypeMap;
    }
}

/**
* Hydra request reset event
*/
export class HydraRequestResetEvent {
    /**
    * User who initiated the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraRequestResetEvent.attributeTypeMap;
    }
}

/**
* Hydra settings changed
*/
export class HydraSettingChangedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Hydra configuration
    */
    'HydraConfig'?: HydraConfig;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraConfig",
            "baseName": "HydraConfig",
            "type": "HydraConfig"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraSettingChangedEvent.attributeTypeMap;
    }
}

/**
* Hydra status
*/
export class HydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreIds'?: Array<number>;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;
    /**
    * Hydra images (covers)
    */
    'Images'?: Array<string>;
    /**
    * Hydra User Type
    */
    'UserType'?: HydraStatus.UserTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "IsRegistered",
            "baseName": "IsRegistered",
            "type": "boolean"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<string>"
        },
        {
            "name": "UserType",
            "baseName": "UserType",
            "type": "HydraStatus.UserTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return HydraStatus.attributeTypeMap;
    }
}

export namespace HydraStatus {
    export enum UserTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
}
/**
* Hydra store\\s assigned event
*/
export class HydraStoreAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to assign hydra to
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreAssignedEvent.attributeTypeMap;
    }
}

/**
* Store Data
*/
export class HydraStoreData {
    /**
    * Id of the store
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreData.attributeTypeMap;
    }
}

/**
* Hydra store\\s unassigned event
*/
export class HydraStoreUnassignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to unassign hydra from
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreUnassignedEvent.attributeTypeMap;
    }
}

/**
* Hydra unassigned event
*/
export class HydraUnAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraUnAssignedEvent.attributeTypeMap;
    }
}

/**
* Index Page
*/
export class IndexPage {
    /**
    * Testimonials
    */
    'Testimonials'?: Array<WebsiteTestimonial>;
    /**
    * Images
    */
    'Images'?: Array<WebsiteImage>;
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Testimonials",
            "baseName": "Testimonials",
            "type": "Array<WebsiteTestimonial>"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<WebsiteImage>"
        },
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPage.attributeTypeMap;
    }
}

/**
* Base of Index Page
*/
export class IndexPageBase {
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPageBase.attributeTypeMap;
    }
}

/**
* Job Address
*/
export class JobAddress {
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country
    */
    'Country'?: string;
    /**
    * Zone
    */
    'Zone'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Country",
            "baseName": "Country",
            "type": "string"
        },
        {
            "name": "Zone",
            "baseName": "Zone",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobAddress.attributeTypeMap;
    }
}

/**
* Job Cancellation
*/
export class JobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy'?: string;
    /**
    * Reason Key
    */
    'ReasonKey'?: string;
    /**
    * Comment
    */
    'Comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanceledBy",
            "baseName": "CanceledBy",
            "type": "string"
        },
        {
            "name": "ReasonKey",
            "baseName": "ReasonKey",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobCancellation.attributeTypeMap;
    }
}

/**
* Job Contact
*/
export class JobContact {
    /**
    * Firstname
    */
    'Firstname'?: string;
    /**
    * Lastname
    */
    'Lastname'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Company
    */
    'Company'?: string;
    /**
    * Company Name
    */
    'CompanyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Firstname",
            "baseName": "Firstname",
            "type": "string"
        },
        {
            "name": "Lastname",
            "baseName": "Lastname",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Company",
            "baseName": "Company",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobContact.attributeTypeMap;
    }
}

/**
* Job Delivery
*/
export class JobDelivery {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Picked At
    */
    'PickedAt'?: string;
    /**
    * Delivered At
    */
    'DeliveredAt'?: string;
    /**
    * Tracking Url
    */
    'TrackingUrl'?: string;
    /**
    * Client Reference
    */
    'ClientReference'?: string;
    /**
    * Package Description
    */
    'PackageDescription'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Pickup
    */
    'Pickup'?: JobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff'?: JobDeliveryDetail;
    /**
    * Eta
    */
    'Eta'?: JobEta;
    /**
    * Cancellation
    */
    'Cancellation'?: JobCancellation;
    /**
    * Proof
    */
    'Proof'?: JobProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PickedAt",
            "baseName": "PickedAt",
            "type": "string"
        },
        {
            "name": "DeliveredAt",
            "baseName": "DeliveredAt",
            "type": "string"
        },
        {
            "name": "TrackingUrl",
            "baseName": "TrackingUrl",
            "type": "string"
        },
        {
            "name": "ClientReference",
            "baseName": "ClientReference",
            "type": "string"
        },
        {
            "name": "PackageDescription",
            "baseName": "PackageDescription",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Eta",
            "baseName": "Eta",
            "type": "JobEta"
        },
        {
            "name": "Cancellation",
            "baseName": "Cancellation",
            "type": "JobCancellation"
        },
        {
            "name": "Proof",
            "baseName": "Proof",
            "type": "JobProof"
        }    ];

    static getAttributeTypeMap() {
        return JobDelivery.attributeTypeMap;
    }
}

/**
* Job Delivery Detail
*/
export class JobDeliveryDetail {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Address
    */
    'Address'?: JobAddress;
    /**
    * Contact
    */
    'Contact'?: JobContact;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "JobAddress"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "JobContact"
        }    ];

    static getAttributeTypeMap() {
        return JobDeliveryDetail.attributeTypeMap;
    }
}

/**
* Job Driver
*/
export class JobDriver {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Display Name
    */
    'DisplayName'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Picture Url
    */
    'PictureUrl'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "PictureUrl",
            "baseName": "PictureUrl",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDriver.attributeTypeMap;
    }
}

/**
* Job Eta
*/
export class JobEta {
    /**
    * Pickup
    */
    'Pickup'?: string;
    /**
    * Dropoff
    */
    'Dropoff'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "string"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobEta.attributeTypeMap;
    }
}

/**
* Job Pricing
*/
export class JobPricing {
    /**
    * Currency
    */
    'Currency'?: string;
    /**
    * Tax Percentage
    */
    'TaxPercentage'?: number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded'?: number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded'?: number;
    /**
    * Tax Amount
    */
    'TaxAmount'?: number;
    /**
    * Invoice Url
    */
    'InvoiceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "TaxPercentage",
            "baseName": "TaxPercentage",
            "type": "number"
        },
        {
            "name": "PriceTaxIncluded",
            "baseName": "PriceTaxIncluded",
            "type": "number"
        },
        {
            "name": "PriceTaxExcluded",
            "baseName": "PriceTaxExcluded",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "InvoiceUrl",
            "baseName": "InvoiceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobPricing.attributeTypeMap;
    }
}

/**
* Job Proof
*/
export class JobProof {
    /**
    * Signature Url
    */
    'SignatureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SignatureUrl",
            "baseName": "SignatureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobProof.attributeTypeMap;
    }
}

/**
* Job Response
*/
export class JobResponse {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Created At
    */
    'CreatedAt'?: Date;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Assignment Code
    */
    'AssignmentCode'?: string;
    /**
    * Pickup At
    */
    'PickupAt'?: string;
    /**
    * Dropoff At
    */
    'DropoffAt'?: string;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Distance
    */
    'Distance'?: number;
    /**
    * Duration
    */
    'Duration'?: number;
    /**
    * Deliveries
    */
    'Deliveries'?: Array<JobDelivery>;
    /**
    * Pricing
    */
    'Pricing'?: JobPricing;
    /**
    * Driver
    */
    'Driver'?: JobDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "CreatedAt",
            "baseName": "CreatedAt",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "AssignmentCode",
            "baseName": "AssignmentCode",
            "type": "string"
        },
        {
            "name": "PickupAt",
            "baseName": "PickupAt",
            "type": "string"
        },
        {
            "name": "DropoffAt",
            "baseName": "DropoffAt",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Distance",
            "baseName": "Distance",
            "type": "number"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "number"
        },
        {
            "name": "Deliveries",
            "baseName": "Deliveries",
            "type": "Array<JobDelivery>"
        },
        {
            "name": "Pricing",
            "baseName": "Pricing",
            "type": "JobPricing"
        },
        {
            "name": "Driver",
            "baseName": "Driver",
            "type": "JobDriver"
        }    ];

    static getAttributeTypeMap() {
        return JobResponse.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth Initiate Install Update Event
*/
export class KioskBluetoothInstallUpdateInitiateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothInstallUpdateInitiateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothInstallUpdateInitiateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk Bluetooth Pairing mode initiated
*/
export class KioskBluetoothPairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothPairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothPairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk bluetooth Cancel Update Install Event
*/
export class KioskBluetoothTerminalCancelUpdateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalCancelUpdateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalCancelUpdateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk Stripe Terminal Update info received event
*/
export class KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Serial Number of the device
    */
    'SerialNumber'?: string;
    /**
    * Indicates if Payment Terminal has Firmware Update
    */
    'HasFirmwareUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Config Update
    */
    'HasConfigUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Key Update
    */
    'HasKeyUpdate'?: boolean;
    /**
    * ETA to install the update
    */
    'UpdateTimeEstimate'?: KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent.UpdateTimeEstimateEnum;
    /**
    * User who made the changes
    */
    'UserEventInfo'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "HasFirmwareUpdate",
            "baseName": "HasFirmwareUpdate",
            "type": "boolean"
        },
        {
            "name": "HasConfigUpdate",
            "baseName": "HasConfigUpdate",
            "type": "boolean"
        },
        {
            "name": "HasKeyUpdate",
            "baseName": "HasKeyUpdate",
            "type": "boolean"
        },
        {
            "name": "UpdateTimeEstimate",
            "baseName": "UpdateTimeEstimate",
            "type": "KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent.UpdateTimeEstimateEnum"
        },
        {
            "name": "UserEventInfo",
            "baseName": "UserEventInfo",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent {
    export enum UpdateTimeEstimateEnum {
        LessThanOneMinute = <any> 'LessThanOneMinute',
        OneToTwoMinutes = <any> 'OneToTwoMinutes',
        TwoToFiveMinutes = <any> 'TwoToFiveMinutes',
        FiveToFifteenMinutes = <any> 'FiveToFifteenMinutes'
    }
}
/**
* Kiosk bluetooth trigger update check event
*/
export class KioskBluetoothTerminalInitiateUpdateCheckEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInitiateUpdateCheckEvent.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth terminal Installation Status
*/
export class KioskBluetoothTerminalInstallationStatusEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Update Install Progress for Card Reader
    */
    'Progress'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Progress",
            "baseName": "Progress",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInstallationStatusEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalInstallationStatusEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk bluetooth terminal unpaired
*/
export class KioskBluetoothTerminalUpdatedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * Status of the connected terminal
    */
    'BluetoothTerminalStatus'?: BluetoothTerminalStatus;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalStatus",
            "baseName": "BluetoothTerminalStatus",
            "type": "BluetoothTerminalStatus"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalUpdatedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalUpdatedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothUnpairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothUnpairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothUnpairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Get Cash Payment Settings for a UserId
*/
export class KioskCashPaymentSettings {
    /**
    * false :disable cash on kiosk  true :enable cash on kiosk
    */
    'IsCashVisibleToCustomer'?: boolean;
    /**
    * HydraUser ID of the Device
    */
    'UserId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCashVisibleToCustomer",
            "baseName": "IsCashVisibleToCustomer",
            "type": "boolean"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Sorted Language
*/
export class Language {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId'?: string;
    /**
    * Display Order
    */
    'DisplayOrder'?: number;
    /**
    * Language Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Language.attributeTypeMap;
    }
}

/**
* Ligthspeed store settings
*/
export class LightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId'?: string;
    /**
    * Use OAuth for authentication
    */
    'UseOAuth'?: boolean;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection'?: number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation'?: string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment'?: boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId'?: string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId'?: string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId'?: string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType'?: LightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId'?: number;
    /**
    * Collection Table ID to send orders
    */
    'CollectionTableId'?: number;
    /**
    * Delivery Table ID to send orders
    */
    'DeliveryTableId'?: number;
    /**
    * Collection Table IDs to send orders to
    */
    'CollectionTableIds'?: { [key: string]: string; };
    /**
    * Delivery Table IDs to send orders to
    */
    'DeliveryTableIds'?: { [key: string]: string; };
    /**
    * Exclude tax
    */
    'UseTaxInclusivePrices'?: boolean;
    /**
    * WARNING: only use this option if the Liteserver is not synchronizing within max 5 minutes with Lightspeed cloud!
    */
    'SkipStatusCheckAndAcceptOrderAfterSending'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CompanyId",
            "baseName": "CompanyId",
            "type": "string"
        },
        {
            "name": "UseOAuth",
            "baseName": "UseOAuth",
            "type": "boolean"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesForCollection",
            "baseName": "EstimatedMinutesForCollection",
            "type": "number"
        },
        {
            "name": "GeographicLocation",
            "baseName": "GeographicLocation",
            "type": "string"
        },
        {
            "name": "Establishment",
            "baseName": "Establishment",
            "type": "boolean"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "string"
        },
        {
            "name": "DeliveryFeeId",
            "baseName": "DeliveryFeeId",
            "type": "string"
        },
        {
            "name": "ProcessingFeeId",
            "baseName": "ProcessingFeeId",
            "type": "string"
        },
        {
            "name": "PriceType",
            "baseName": "PriceType",
            "type": "LightspeedSettings.PriceTypeEnum"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "CollectionTableId",
            "baseName": "CollectionTableId",
            "type": "number"
        },
        {
            "name": "DeliveryTableId",
            "baseName": "DeliveryTableId",
            "type": "number"
        },
        {
            "name": "CollectionTableIds",
            "baseName": "CollectionTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "DeliveryTableIds",
            "baseName": "DeliveryTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UseTaxInclusivePrices",
            "baseName": "UseTaxInclusivePrices",
            "type": "boolean"
        },
        {
            "name": "SkipStatusCheckAndAcceptOrderAfterSending",
            "baseName": "SkipStatusCheckAndAcceptOrderAfterSending",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LightspeedSettings.attributeTypeMap;
    }
}

export namespace LightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Represents a localised time zone
*/
export class LocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId'?: string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId'?: string;
    /**
    * Display name in users language
    */
    'DisplayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TimeZoneId",
            "baseName": "TimeZoneId",
            "type": "string"
        },
        {
            "name": "IanaTimeZoneId",
            "baseName": "IanaTimeZoneId",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Login model
*/
export class LoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoginModel.attributeTypeMap;
    }
}

/**
* Login with PIN model
*/
export class LoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoginWithPinModel.attributeTypeMap;
    }
}

/**
* Loyalty campaign
*/
export class LoyaltyCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Loyalty campaign base
*/
export class LoyaltyCampaignBase {
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignBase.attributeTypeMap;
    }
}

/**
* Loyalty campaign created event
*/
export class LoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign deleted event
*/
export class LoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign updated event
*/
export class LoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Lump discount details
*/
export class LumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DiscountAmount",
            "baseName": "DiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LumpDiscountDetails.attributeTypeMap;
    }
}

/**
* Represents a masked phone number
*/
export class MaskedPhoneNumber {
    /**
    * Defines if the feature is enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Defines the phone number to call
    */
    'PhoneNumber'?: string;
    /**
    * Defines the code to enter
    */
    'Code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MaskedPhoneNumber.attributeTypeMap;
    }
}

/**
* Menu
*/
export class Menu {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<MenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: Menu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: Menu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<MenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "Menu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "Menu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu base
*/
export class MenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: MenuBase.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: MenuBase.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "MenuBase.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuBase.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuBase.attributeTypeMap;
    }
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu bulk event
*/
export class MenuBulkEditEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Product
    */
    'Item'?: string;
    /**
    * Quantity of product
    */
    'InstanceCount'?: number;
    /**
    * Visibility of the item
    */
    'IsAvailable'?: boolean;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Item",
            "baseName": "Item",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuBulkEditEvent.attributeTypeMap;
    }
}

/**
* Menu Checkpoint
*/
export class MenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId'?: number;
    /**
    * Time of creation of checkpoint
    */
    'Time'?: Date;
    /**
    * Name of checkpoint
    */
    'Name'?: string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCheckpointId",
            "baseName": "MenuCheckpointId",
            "type": "number"
        },
        {
            "name": "Time",
            "baseName": "Time",
            "type": "Date"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpoint.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuCheckpointCreatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Menu identifier
    */
    'Menu'?: Menu;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpointCreatedEvent.attributeTypeMap;
    }
}

/**
* Menu created event
*/
export class MenuCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCreatedEvent.attributeTypeMap;
    }
}

/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementEditResponse {
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementEditResponse.MenuElementTypeEnum;
    /**
    * Validation message for menu element issue
    */
    'ValidationCode'?: MenuElementEditResponse.ValidationCodeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementEditResponse.MenuElementTypeEnum"
        },
        {
            "name": "ValidationCode",
            "baseName": "ValidationCode",
            "type": "MenuElementEditResponse.ValidationCodeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementEditResponse.attributeTypeMap;
    }
}

export namespace MenuElementEditResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
    export enum ValidationCodeEnum {
        Success = <any> 'Success',
        MinimumCountViolation = <any> 'MinimumCountViolation',
        MasterOptionSetViolation = <any> 'MasterOptionSetViolation',
        IncorrectElementTypeInMenu = <any> 'IncorrectElementTypeInMenu',
        DBFailed = <any> 'DBFailed'
    }
}
/**
* Menu element hide
*/
export class MenuElementHide {
    /**
    * id of the menu item or menu option set item
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementHide.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementHide.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementHide.attributeTypeMap;
    }
}

export namespace MenuElementHide {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListItemResponse {
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementListItemResponse.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementListItemResponse.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListItemResponse.attributeTypeMap;
    }
}

export namespace MenuElementListItemResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListResponse {
    /**
    * Menu Item Name
    */
    'MenuElementName'?: string;
    'InstanceCount'?: number;
    /**
    * Menu Item is hide or unhide
    */
    'IsAvailable'?: boolean;
    'Items'?: Array<MenuElementListItemResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementName",
            "baseName": "MenuElementName",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<MenuElementListItemResponse>"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListResponse.attributeTypeMap;
    }
}

/**
* Menu item option set
*/
export class MenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<MenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<MenuItemOptionSetItem>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSet.attributeTypeMap;
    }
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item option set item
*/
export class MenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class MenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItemBase.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetUpdatedEvent.attributeTypeMap;
    }
}

/**
* Collection of Display Orders for a Menu Object (Menu Section / Menu Items / Option Sets etc)
*/
export class MenuObjectDisplayOrders {
    /**
    * List of Objects and their new Display Orders
    */
    'DisplayOrders'?: Array<ObjectDisplayOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplayOrders",
            "baseName": "DisplayOrders",
            "type": "Array<ObjectDisplayOrder>"
        }    ];

    static getAttributeTypeMap() {
        return MenuObjectDisplayOrders.attributeTypeMap;
    }
}

/**
* Menu section
*/
export class MenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId'?: number;
    /**
    * Menu items
    */
    'MenuItems'?: Array<MenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<MenuSectionItem>"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSection.attributeTypeMap;
    }
}

/**
* Menu section availability
*/
export class MenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes'?: Array<BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailability.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailableTimes",
            "baseName": "AvailableTimes",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailability.attributeTypeMap;
    }
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class MenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailabilityBase.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailabilityBase.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailabilityBase.attributeTypeMap;
    }
}

export namespace MenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class MenuSectionBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionBase.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item
*/
export class MenuSectionItem {
    /**
    * Menu item identifier. This ID may change at any time. Use `PublicId` if you need a perminant reference to the item.
    */
    'MenuItemId'?: number;
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice'?: number;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<MenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours'?: Array<BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ActualPrice",
            "baseName": "ActualPrice",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<MenuItemOptionSet>"
        },
        {
            "name": "DailySpecialHours",
            "baseName": "DailySpecialHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItem.attributeTypeMap;
    }
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class MenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemBase.attributeTypeMap;
    }
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Deleted by user
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Store Names
*/
export class MenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuStoreNames.attributeTypeMap;
    }
}

/**
* Menu Summary
*/
export class MenuSummary {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuSummary.attributeTypeMap;
    }
}

/**
* Tax information for Menu
*/
export class MenuTaxDetails {
    /**
    * Tax Rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Display tax for Menu
    */
    'DisplayTax'?: boolean;
    /**
    * TaxType
    */
    'TaxType'?: MenuTaxDetails.TaxTypeEnum;
    /**
    * ItemIds and TaxIds
    */
    'ItemTaxes'?: { [key: string]: number; };
    /**
    * SetItemIds and TaxIds
    */
    'SetItemTaxes'?: { [key: string]: number; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "DisplayTax",
            "baseName": "DisplayTax",
            "type": "boolean"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuTaxDetails.TaxTypeEnum"
        },
        {
            "name": "ItemTaxes",
            "baseName": "ItemTaxes",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "SetItemTaxes",
            "baseName": "SetItemTaxes",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxDetails.attributeTypeMap;
    }
}

export namespace MenuTaxDetails {
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class MenuTaxRate {
    /**
    * Id of Tax Rate
    */
    'TaxRateId'?: number;
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxRate.attributeTypeMap;
    }
}

/**
* Menu updated event
*/
export class MenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu uploaded event
*/
export class MenuUploadedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUploadedEvent.attributeTypeMap;
    }
}

/**
* Metadata
*/
export class Metadata {
    /**
    * Menu entity identifier (eg: MenuItemId, MenuItemOptionSetItemId)
    */
    'MenuEntityId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuEntityId",
            "baseName": "MenuEntityId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metadata.attributeTypeMap;
    }
}

/**
* Oauth client (also knowns as 'app')
*/
export class OAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId'?: string;
    /**
    * OAuth App Name
    */
    'OauthAppName'?: string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * OAuth App logo uri
    */
    'LogoUri'?: string;
    /**
    * Supported OpenID Connect flows
    */
    'Flow'?: OAuthApp.FlowEnum;
    /**
    * ReUse: the refresh token handle will stay the same when refreshing tokens   OneTime: the refresh token handle will be updated when refreshing tokens
    */
    'RefreshTokenUsage'?: OAuthApp.RefreshTokenUsageEnum;
    /**
    * Timem it takes for the IdentityToken to expire in seconds
    */
    'AccessTokenLifetime'?: number;
    /**
    * Maximum lifetime of a refresh token in seconds
    */
    'AbsoluteRefreshTokenLifetime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OauthAppId",
            "baseName": "OauthAppId",
            "type": "string"
        },
        {
            "name": "OauthAppName",
            "baseName": "OauthAppName",
            "type": "string"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Flow",
            "baseName": "Flow",
            "type": "OAuthApp.FlowEnum"
        },
        {
            "name": "RefreshTokenUsage",
            "baseName": "RefreshTokenUsage",
            "type": "OAuthApp.RefreshTokenUsageEnum"
        },
        {
            "name": "AccessTokenLifetime",
            "baseName": "AccessTokenLifetime",
            "type": "number"
        },
        {
            "name": "AbsoluteRefreshTokenLifetime",
            "baseName": "AbsoluteRefreshTokenLifetime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OAuthApp.attributeTypeMap;
    }
}

export namespace OAuthApp {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        Hybrid = <any> 'Hybrid',
        ClientCredentials = <any> 'ClientCredentials'
    }
    export enum RefreshTokenUsageEnum {
        ReUse = <any> 'ReUse',
        OneTimeOnly = <any> 'OneTimeOnly'
    }
}
/**
* OAuth token model
*/
export class OAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key'?: string;
    /**
    * Token type
    */
    'TokenType'?: string;
    /**
    * Oauth subject identifier
    */
    'SubjectId'?: string;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Token expiry
    */
    'Expiry'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "TokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "SubjectId",
            "baseName": "SubjectId",
            "type": "string"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "Expiry",
            "baseName": "Expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OAuthTokenModel.attributeTypeMap;
    }
}

/**
* OAuth client redirect uri
*/
export class OauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id'?: number;
    /**
    * Redirect uri
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* 
*/
export class ObjectDisplayOrder {
    /**
    * ID of object to be ordered
    */
    'Id'?: number;
    /**
    * New Display order
    */
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ObjectDisplayOrder.attributeTypeMap;
    }
}

/**
* Order
*/
export class Order {
    /**
    * Store summary
    */
    'Store'?: StoreSummary;
    /**
    * Customer summary
    */
    'Customer'?: CustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher'?: OrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees'?: FeeSummary;
    /**
    * Ordered items
    */
    'OrderItems'?: Array<OrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation'?: DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation'?: Coordinates;
    /**
    * Represents customers masked phone number
    */
    'MaskedPhoneNumber'?: MaskedPhoneNumber;
    /**
    * Represents table service drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * Id of user who rejected order, if available
    */
    'RejectedByUserId'?: number;
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * Delivery type
    */
    'DeliveryType'?: Order.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: Order.PickupLocationTypeEnum;
    /**
    * Pickup location type
    */
    'TableServiceCatagory'?: Order.TableServiceCatagoryEnum;
    /**
    * Tip amount
    */
    'TipAmount'?: number;
    /**
    * Delivery amount
    */
    'DeliveryAmount'?: number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount'?: number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount'?: number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: Order.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription'?: string;
    /**
    * Order state
    */
    'OrderState'?: Order.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder'?: boolean;
    /**
    * Order placed time
    */
    'PlacedTime'?: Date;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Chef note
    */
    'ChefNote'?: string;
    /**
    * Used app type
    */
    'AppType'?: Order.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating'?: number;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: Order.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason'?: Order.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount'?: number;
    /**
    * Delivery tracking status
    */
    'DeliveryTrackingStatus'?: Order.DeliveryTrackingStatusEnum;
    /**
    * Assigned driver identifier
    */
    'DriverId'?: number;
    /**
    * Total tax applied to order
    */
    'TotalTax'?: number;
    /**
    * Unique, 6 character long alpha numeric code for tracking.
    */
    'OrderTrackingCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Store",
            "baseName": "Store",
            "type": "StoreSummary"
        },
        {
            "name": "Customer",
            "baseName": "Customer",
            "type": "CustomerSummary"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "OrderVoucherSummary"
        },
        {
            "name": "Fees",
            "baseName": "Fees",
            "type": "FeeSummary"
        },
        {
            "name": "OrderItems",
            "baseName": "OrderItems",
            "type": "Array<OrderItem>"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        },
        {
            "name": "CustomerLocation",
            "baseName": "CustomerLocation",
            "type": "Coordinates"
        },
        {
            "name": "MaskedPhoneNumber",
            "baseName": "MaskedPhoneNumber",
            "type": "MaskedPhoneNumber"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "RejectedByUserId",
            "baseName": "RejectedByUserId",
            "type": "number"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "Order.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "Order.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "Order.TableServiceCatagoryEnum"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "OrderItemsAmount",
            "baseName": "OrderItemsAmount",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "Order.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentAccountDescription",
            "baseName": "PaymentAccountDescription",
            "type": "string"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "Order.OrderStateEnum"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "PlacedTime",
            "baseName": "PlacedTime",
            "type": "Date"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "Order.AppTypeEnum"
        },
        {
            "name": "UserRating",
            "baseName": "UserRating",
            "type": "number"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "Order.PaymentStatusEnum"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "Order.RejectionReasonEnum"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "DeliveryTrackingStatus",
            "baseName": "DeliveryTrackingStatus",
            "type": "Order.DeliveryTrackingStatusEnum"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "TotalTax",
            "baseName": "TotalTax",
            "type": "number"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
    export enum DeliveryTrackingStatusEnum {
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Accepted Event
*/
export class OrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderAcceptedTime",
            "baseName": "OrderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderAcceptedEvent.attributeTypeMap;
    }
}

/**
* Store's Order Capacity Configuration Updated
*/
export class OrderCapacityConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Id of the store whose order capacity configuration has been updated
    */
    'StoreId'?: number;
    /**
    * User which updated order capacity configuration for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated order capacity configuration
    */
    'OrderCapacityConfig'?: StoreOrderCapacityConfigEditModel;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCapacityConfig",
            "baseName": "OrderCapacityConfig",
            "type": "StoreOrderCapacityConfigEditModel"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCapacityConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Created Event
*/
export class OrderCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCreatedTime",
            "baseName": "OrderCreatedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderCustomerTrackingCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: CustomerDeliveryTrackingOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "CustomerDeliveryTrackingOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCustomerTrackingCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderDeliveryTrackingStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryTrackingStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Dispatched Event
*/
export class OrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderDispatchedTime",
            "baseName": "OrderDispatchedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDispatchedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderIdAndSequenceNumber {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Sequence for delivery
    */
    'Sequence'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Sequence",
            "baseName": "Sequence",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderIdAndSequenceNumber.attributeTypeMap;
    }
}

/**
* Order item
*/
export class OrderItem {
    /**
    * Option list
    */
    'OrderItemOptions'?: Array<OrderItemOption>;
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId'?: string;
    /**
    * Menu section name
    */
    'MenuSectionName'?: string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems'?: number;
    /**
    * Menu item identifier
    */
    'MenuItemId'?: number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderItemOptions",
            "baseName": "OrderItemOptions",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "MenuItemDisplayOrder",
            "baseName": "MenuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

/**
* Order item option
*/
export class OrderItemOption {
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId'?: string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId'?: number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder'?: number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemOptionPublicId",
            "baseName": "MenuItemOptionPublicId",
            "type": "string"
        },
        {
            "name": "MenuItemOptionId",
            "baseName": "MenuItemOptionId",
            "type": "number"
        },
        {
            "name": "IsMasterOptionSetItem",
            "baseName": "IsMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "MenuItemOptionDisplayOrder",
            "baseName": "MenuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetDisplayOrder",
            "baseName": "MenuItemOptionSetDisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

/**
* Order Payment Information
*/
export class OrderPaymentInformation {
    /**
    * ID of the Order
    */
    'OrderId'?: number;
    /**
    * Signifies if the payment is refundable
    */
    'PaymentRefundable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PaymentRefundable",
            "baseName": "PaymentRefundable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Order Rating Update Event
*/
export class OrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * New User Rating
    */
    'Rating'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Rating",
            "baseName": "Rating",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRatingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Refunded Event
*/
export class OrderRefundedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The amount refunded
    */
    'RefundedAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRefundedEvent.attributeTypeMap;
    }
}

/**
* Order Rejected Event
*/
export class OrderRejectedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime'?: Date;
    /**
    * Reason for Rejection
    */
    'Reason'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderRejectedTime",
            "baseName": "OrderRejectedTime",
            "type": "Date"
        },
        {
            "name": "Reason",
            "baseName": "Reason",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRejectedEvent.attributeTypeMap;
    }
}

/**
* Order summary
*/
export class OrderSummary {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: OrderSummary.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: OrderSummary.PickupLocationTypeEnum;
    /**
    * Table service category
    */
    'TableServiceCatagory'?: OrderSummary.TableServiceCatagoryEnum;
    /**
    * Order state
    */
    'OrderState'?: OrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone'?: string;
    /**
    * Name of the customer
    */
    'CustomerName'?: string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber'?: string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Payment Account
    */
    'PaymentAccountType'?: OrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: OrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency'?: OrderSummary.CurrencyEnum;
    /**
    * Type of app end user is on
    */
    'AppType'?: OrderSummary.AppTypeEnum;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * id of the collection/drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "OrderSummary.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "OrderSummary.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "OrderSummary.TableServiceCatagoryEnum"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "OrderSummary.OrderStateEnum"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreIanaTimeZone",
            "baseName": "StoreIanaTimeZone",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "CustomerPhoneNumber",
            "baseName": "CustomerPhoneNumber",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "OrderSummary.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "OrderSummary.PaymentStatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "OrderSummary.CurrencyEnum"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "OrderSummary.AppTypeEnum"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderSummary.attributeTypeMap;
    }
}

export namespace OrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
}
/**
* Order Tip Update Event
*/
export class OrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Tip Amount
    */
    'TipAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher summary
*/
export class OrderVoucherSummary {
    /**
    * Voucher name
    */
    'Name'?: string;
    /**
    * Voucher description
    */
    'Description'?: string;
    /**
    * Voucher code
    */
    'Code'?: string;
    /**
    * Voucher amount
    */
    'Amount'?: number;
    /**
    * Voucher type
    */
    'Type'?: OrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType'?: OrderVoucherSummary.SubTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "OrderVoucherSummary.TypeEnum"
        },
        {
            "name": "SubType",
            "baseName": "SubType",
            "type": "OrderVoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderVoucherSummary.attributeTypeMap;
    }
}

export namespace OrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Breakdown of other charges
*/
export class OtherChargesDetails {
    /**
    * Total amount of other charges
    */
    'TotalOtherCharges'?: number;
    /**
    * Number of other charges
    */
    'ChargesCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalOtherCharges",
            "baseName": "TotalOtherCharges",
            "type": "number"
        },
        {
            "name": "ChargesCount",
            "baseName": "ChargesCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherChargesDetails.attributeTypeMap;
    }
}

/**
* Password reset model
*/
export class PasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "PasswordConfirmation",
            "baseName": "PasswordConfirmation",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetModel.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal
*/
export class PaymentTerminalDetails {
    /**
    * Terminal Id (tid)
    */
    'TerminalId'?: string;
    /**
    * Status of Terminal
    */
    'Status'?: string;
    /**
    * Currency configured on the terminal
    */
    'Currency'?: string;
    /**
    * Location to Device
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal Transaction
*/
export class PaymentTerminalTransactionDetails {
    /**
    * Card Type
    */
    'CardSchemeName'?: string;
    /**
    * Expirey Date on Card
    */
    'DateOfExpiry'?: string;
    /**
    * AuthCode
    */
    'AuthCode'?: string;
    /**
    * State of Request, \"PENDING\" is not yet completed
    */
    'TransactionResult'?: string;
    /**
    * Masked PAN
    */
    'PrimaryAccountNumber'?: string;
    /**
    * Type of Verification.
    */
    'CardholderVerificationMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CardSchemeName",
            "baseName": "CardSchemeName",
            "type": "string"
        },
        {
            "name": "DateOfExpiry",
            "baseName": "DateOfExpiry",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "TransactionResult",
            "baseName": "TransactionResult",
            "type": "string"
        },
        {
            "name": "PrimaryAccountNumber",
            "baseName": "PrimaryAccountNumber",
            "type": "string"
        },
        {
            "name": "CardholderVerificationMethod",
            "baseName": "CardholderVerificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payout.
*/
export class Payout {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'PayeeBankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: Payout.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    /**
    * Destination bank name
    */
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Type of payout source
    */
    'PayoutType'?: Payout.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: Payout.CurrencyEnum;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "PayeeBankAccountId",
            "baseName": "PayeeBankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "Payout.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "Payout.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Payout.CurrencyEnum"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Payout.attributeTypeMap;
    }
}

export namespace Payout {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a chargeback related to a payout
*/
export class PayoutChargeback {
    /**
    * The id of the order the chargeback was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutChargeback.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutChargeback.OrderTypeEnum;
    /**
    * The date the chargeback was done
    */
    'ChargebackDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Amount of refunded fees
    */
    'RefundedFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutChargeback.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutChargeback.OrderTypeEnum"
        },
        {
            "name": "ChargebackDate",
            "baseName": "ChargebackDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutChargeback.attributeTypeMap;
    }
}

export namespace PayoutChargeback {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Holds the information for a whitelabel payout with details broken down by Store
*/
export class PayoutDetail {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'BankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutDetail.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Type of payout source
    */
    'PayoutType'?: PayoutDetail.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: PayoutDetail.CurrencyEnum;
    /**
    * Payout information broken down by Store
    */
    'PayoutStores'?: Array<PayoutStore>;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "BankAccountId",
            "baseName": "BankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutDetail.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "PayoutDetail.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutDetail.CurrencyEnum"
        },
        {
            "name": "PayoutStores",
            "baseName": "PayoutStores",
            "type": "Array<PayoutStore>"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PayoutDetail.attributeTypeMap;
    }
}

export namespace PayoutDetail {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for an order related to a payout
*/
export class PayoutOrder {
    /**
    * The id of the order
    */
    'OrderId'?: number;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutOrder.OrderTypeEnum;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutOrder.OrderCurrencyEnum;
    /**
    * Order sales amount
    */
    'Sales'?: number;
    /**
    * Order sales tax amount
    */
    'SalesTax'?: number;
    /**
    * Order delivery charges
    */
    'DeliveryCharges'?: number;
    /**
    * Order tips amount
    */
    'Tips'?: number;
    /**
    * Order voucher amount
    */
    'Voucher'?: number;
    /**
    * Order flat fee amount excluding VAT
    */
    'FlatFeeExcludingVat'?: number;
    'FlatFeeExcludingVAT'?: number;
    /**
    * Order percentage fee excluding VAT
    */
    'PercentageFeeExcludingVat'?: number;
    'PercentageFeeExcludingVAT'?: number;
    /**
    * Order VAT amount
    */
    'Vat'?: number;
    /**
    * Total order fees amount
    */
    'TotalFees'?: number;
    /**
    * Cash fee charged to customer
    */
    'CashFeeChargedToCustomer'?: number;
    /**
    * Order net sales amount
    */
    'NetSales'?: number;
    /**
    * Store id
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutOrder.OrderTypeEnum"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutOrder.OrderCurrencyEnum"
        },
        {
            "name": "Sales",
            "baseName": "Sales",
            "type": "number"
        },
        {
            "name": "SalesTax",
            "baseName": "SalesTax",
            "type": "number"
        },
        {
            "name": "DeliveryCharges",
            "baseName": "DeliveryCharges",
            "type": "number"
        },
        {
            "name": "Tips",
            "baseName": "Tips",
            "type": "number"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVat",
            "baseName": "FlatFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVAT",
            "baseName": "FlatFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVat",
            "baseName": "PercentageFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVAT",
            "baseName": "PercentageFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "Vat",
            "baseName": "Vat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        },
        {
            "name": "CashFeeChargedToCustomer",
            "baseName": "CashFeeChargedToCustomer",
            "type": "number"
        },
        {
            "name": "NetSales",
            "baseName": "NetSales",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOrder.attributeTypeMap;
    }
}

export namespace PayoutOrder {
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a charge related to a payout
*/
export class PayoutOtherCharge {
    /**
    * The id of the charge
    */
    'ChargeId'?: number;
    /**
    * Charge amount
    */
    'Amount'?: number;
    /**
    * Currency of the charge
    */
    'Currency'?: PayoutOtherCharge.CurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'ChargeDate'?: Date;
    /**
    * Charge type
    */
    'ChargeType'?: PayoutOtherCharge.ChargeTypeEnum;
    /**
    * Charge description
    */
    'ChargeDescription'?: string;
    /**
    * Store id
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargeId",
            "baseName": "ChargeId",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutOtherCharge.CurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "ChargeDate",
            "baseName": "ChargeDate",
            "type": "Date"
        },
        {
            "name": "ChargeType",
            "baseName": "ChargeType",
            "type": "PayoutOtherCharge.ChargeTypeEnum"
        },
        {
            "name": "ChargeDescription",
            "baseName": "ChargeDescription",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOtherCharge.attributeTypeMap;
    }
}

export namespace PayoutOtherCharge {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChargeTypeEnum {
        Other = <any> 'Other',
        Fees = <any> 'Fees',
        Chargeback = <any> 'Chargeback',
        TipFailure = <any> 'TipFailure',
        ExternalDisbursement = <any> 'ExternalDisbursement',
        Goods = <any> 'Goods',
        RestaurantSales = <any> 'RestaurantSales',
        Tips = <any> 'Tips'
    }
}
/**
* Holds the information for a refund related to a payout
*/
export class PayoutRefund {
    /**
    * The id of the order the refund was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutRefund.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutRefund.OrderTypeEnum;
    /**
    * The date the refund was done
    */
    'RefundDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Total refund amount
    */
    'TotalRefund'?: number;
    /**
    * Refunded fees amount
    */
    'RefundedFees'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Cash fee refunded to customer
    */
    'CashFeeRefundedToCustomer'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutRefund.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutRefund.OrderTypeEnum"
        },
        {
            "name": "RefundDate",
            "baseName": "RefundDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TotalRefund",
            "baseName": "TotalRefund",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "CashFeeRefundedToCustomer",
            "baseName": "CashFeeRefundedToCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutRefund.attributeTypeMap;
    }
}

export namespace PayoutRefund {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Payout details for a single store
*/
export class PayoutStore {
    /**
    * The id of the Store.
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Amount of the payout for this Store
    */
    'Amount'?: number;
    /**
    * Revenue details (DEPRECATED: Use Revenue)
    */
    'OnlineRevenue'?: RevenueDetail;
    /**
    * Revenue details
    */
    'Revenue'?: RevenueDetail;
    /**
    * Revenue Adjustments breakdown
    */
    'RevenueAdjustments'?: RevenueAdjustmentsDetails;
    /**
    * Fees breakdown
    */
    'FlipdishFees'?: FlipdishFeesDetails;
    /**
    * Chargebacks breakdown
    */
    'Chargebacks'?: ChargebackDetails;
    /**
    * Breakdown of other charges
    */
    'OtherCharges'?: OtherChargesDetails;
    /**
    * Period opening and closing balance
    */
    'Balance'?: BalanceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "OnlineRevenue",
            "baseName": "OnlineRevenue",
            "type": "RevenueDetail"
        },
        {
            "name": "Revenue",
            "baseName": "Revenue",
            "type": "RevenueDetail"
        },
        {
            "name": "RevenueAdjustments",
            "baseName": "RevenueAdjustments",
            "type": "RevenueAdjustmentsDetails"
        },
        {
            "name": "FlipdishFees",
            "baseName": "FlipdishFees",
            "type": "FlipdishFeesDetails"
        },
        {
            "name": "Chargebacks",
            "baseName": "Chargebacks",
            "type": "ChargebackDetails"
        },
        {
            "name": "OtherCharges",
            "baseName": "OtherCharges",
            "type": "OtherChargesDetails"
        },
        {
            "name": "Balance",
            "baseName": "Balance",
            "type": "BalanceDetails"
        }    ];

    static getAttributeTypeMap() {
        return PayoutStore.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payouts summary.
*/
export class PayoutSummary {
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutSummary.PayoutStatusEnum;
    /**
    * Total payouts amount
    */
    'TotalAmount'?: number;
    /**
    * Payout currency
    */
    'Currency'?: PayoutSummary.CurrencyEnum;
    /**
    * Total payouts count
    */
    'TotalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutSummary.PayoutStatusEnum"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutSummary.CurrencyEnum"
        },
        {
            "name": "TotalCount",
            "baseName": "TotalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutSummary.attributeTypeMap;
    }
}

export namespace PayoutSummary {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Percent discount details
*/
export class PercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PercentageDiscount",
            "baseName": "PercentageDiscount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PercentDiscountDetails.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId'?: number;
    /**
    * Time of the call
    */
    'TimeOfCall'?: Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal'?: Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId'?: number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName'?: string;
    /**
    * Name of the caller
    */
    'CallerName'?: string;
    /**
    * UserID of the caller
    */
    'CallerUserId'?: number;
    /**
    * Phone number of the caller
    */
    'CallerNumber'?: string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds'?: number;
    /**
    * The status of the call
    */
    'CallStatus'?: PhoneCall.CallStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneCallId",
            "baseName": "PhoneCallId",
            "type": "number"
        },
        {
            "name": "TimeOfCall",
            "baseName": "TimeOfCall",
            "type": "Date"
        },
        {
            "name": "TimeOfCallLocal",
            "baseName": "TimeOfCallLocal",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "CallerName",
            "baseName": "CallerName",
            "type": "string"
        },
        {
            "name": "CallerUserId",
            "baseName": "CallerUserId",
            "type": "number"
        },
        {
            "name": "CallerNumber",
            "baseName": "CallerNumber",
            "type": "string"
        },
        {
            "name": "CallLengthInSeconds",
            "baseName": "CallLengthInSeconds",
            "type": "number"
        },
        {
            "name": "CallStatus",
            "baseName": "CallStatus",
            "type": "PhoneCall.CallStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCall.attributeTypeMap;
    }
}

export namespace PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Phone call ended event
*/
export class PhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallEndedEvent.attributeTypeMap;
    }
}

/**
* Phone call started event
*/
export class PhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallStartedEvent.attributeTypeMap;
    }
}

/**
* Pre Order Config
*/
export class PreOrderConfig {
    /**
    * Lead Time in Minutes
    */
    'LeadTimeMinutes'?: number;
    /**
    * Interval in minutes
    */
    'IntervalMinutes'?: number;
    /**
    * Max Days to order ahead
    */
    'MaxOrderAheadDays'?: number;
    /**
    * Show ASAP as option
    */
    'IncludeAsap'?: boolean;
    /**
    * Granual Init' Time
    */
    'IncludeMoreGranularInitialTime'?: boolean;
    /**
    * Cut off time previous day
    */
    'CutOffTimePreviousDayBasic'?: string;
    /**
    * Cut off time current day
    */
    'CutOffTimeCurrentDayBasic'?: string;
    /**
    * Type of time displayed.
    */
    'PreOrderTimeDisplayType'?: PreOrderConfig.PreOrderTimeDisplayTypeEnum;
    /**
    * Specifies whether a customer can pre-order outside the store opening hours or not.
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * Force customer to select collection time.
    */
    'RequireExplicitSelectAlways'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "number"
        },
        {
            "name": "IntervalMinutes",
            "baseName": "IntervalMinutes",
            "type": "number"
        },
        {
            "name": "MaxOrderAheadDays",
            "baseName": "MaxOrderAheadDays",
            "type": "number"
        },
        {
            "name": "IncludeAsap",
            "baseName": "IncludeAsap",
            "type": "boolean"
        },
        {
            "name": "IncludeMoreGranularInitialTime",
            "baseName": "IncludeMoreGranularInitialTime",
            "type": "boolean"
        },
        {
            "name": "CutOffTimePreviousDayBasic",
            "baseName": "CutOffTimePreviousDayBasic",
            "type": "string"
        },
        {
            "name": "CutOffTimeCurrentDayBasic",
            "baseName": "CutOffTimeCurrentDayBasic",
            "type": "string"
        },
        {
            "name": "PreOrderTimeDisplayType",
            "baseName": "PreOrderTimeDisplayType",
            "type": "PreOrderConfig.PreOrderTimeDisplayTypeEnum"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "RequireExplicitSelectAlways",
            "baseName": "RequireExplicitSelectAlways",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderConfig.attributeTypeMap;
    }
}

export namespace PreOrderConfig {
    export enum PreOrderTimeDisplayTypeEnum {
        SingleTime = <any> 'SingleTime',
        StartAndEndTime = <any> 'StartAndEndTime',
        DayOnly = <any> 'DayOnly'
    }
}
/**
* Time order can be placed
*/
export class PreOrderTime {
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderTime.attributeTypeMap;
    }
}

/**
* Predefined answer
*/
export class PredefinedAnswer {
    /**
    * Identifier
    */
    'Id'?: number;
    /**
    * Text
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredefinedAnswer.attributeTypeMap;
    }
}

/**
* Printer
*/
export class Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber'?: string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "LastPollTime",
            "baseName": "LastPollTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Printer.attributeTypeMap;
    }
}

/**
* Printer assigned to store event
*/
export class PrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterAssignedToStoreEvent.attributeTypeMap;
    }
}

/**
* Printer turned off event
*/
export class PrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOffEvent.attributeTypeMap;
    }
}

/**
* Printer turned on event
*/
export class PrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOnEvent.attributeTypeMap;
    }
}

/**
* Printer assigned from store event
*/
export class PrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterUnassignedFromStoreEvent.attributeTypeMap;
    }
}

/**
* Processing fee config
*/
export class ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee'?: number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "ProcessingFeeConfig.PaymentAccountTypeEnum"
        },
        {
            "name": "PercentFee",
            "baseName": "PercentFee",
            "type": "number"
        },
        {
            "name": "FixedFee",
            "baseName": "FixedFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessingFeeConfig.attributeTypeMap;
    }
}

export namespace ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
}
/**
* 
*/
export class PushNotificationDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationDeletedEvent.attributeTypeMap;
    }
}

/**
* Push Notification Details
*/
export class PushNotificationRequest {
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationRequest.attributeTypeMap;
    }
}

/**
* Push Notification
*/
export class PushNotificationResponse {
    /**
    * Sent
    */
    'Sent'?: boolean;
    /**
    * Push notification identifier
    */
    'ScheduledPushNotificationId'?: number;
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sent",
            "baseName": "Sent",
            "type": "boolean"
        },
        {
            "name": "ScheduledPushNotificationId",
            "baseName": "ScheduledPushNotificationId",
            "type": "number"
        },
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationScheduledEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'User'?: UserEventInfo;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationScheduledEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationSentEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationSentEvent.attributeTypeMap;
    }
}

/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class Range {
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Day of week
    */
    'DayOfWeek'?: Range.DayOfWeekEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* 
*/
export class RedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: RedeemInvitationResult.InvitationStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "RedeemInvitationResult.InvitationStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return RedeemInvitationResult.attributeTypeMap;
    }
}

export namespace RedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* Refund
*/
export class Refund {
    /**
    * Refund reason
    */
    'RefundReason'?: string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If true, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RefundReason",
            "baseName": "RefundReason",
            "type": "string"
        },
        {
            "name": "RefundAmount",
            "baseName": "RefundAmount",
            "type": "number"
        },
        {
            "name": "NotifyCustomer",
            "baseName": "NotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

/**
* Reject
*/
export class Reject {
    /**
    * Reject reason.
    */
    'RejectReason': Reject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RejectReason",
            "baseName": "RejectReason",
            "type": "Reject.RejectReasonEnum"
        },
        {
            "name": "DoNotNotifyCustomer",
            "baseName": "DoNotNotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Reject.attributeTypeMap;
    }
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Request login PIN response
*/
export class RequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class RequestLoginPinResposne {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LoginPinSentViaEmail",
            "baseName": "LoginPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinResposne.attributeTypeMap;
    }
}

/**
* 
*/
export class RequestPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetModel.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAllMetadataResult {
    /**
    * Generic data object.
    */
    'Data': Array<AllMetadataResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AllMetadataResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAllMetadataResult.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmCurrencyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmHourlyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmHourlyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmHourlyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmHourlyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBankAccountSummary {
    /**
    * Generic data object.
    */
    'Data': Array<BankAccountSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BankAccountSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBankAccountSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultCountryWithAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': Array<CountryWithAccountFieldsDefinitions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CountryWithAccountFieldsDefinitions>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultCountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': Array<DeliveryZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DeliveryZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriver {
    /**
    * Generic data object.
    */
    'Data': Array<Driver>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Driver>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDriver.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriverStore {
    /**
    * Generic data object.
    */
    'Data': Array<DriverStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DriverStore>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDriverStore.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultEmvTerminalWithAssignments {
    /**
    * Generic data object.
    */
    'Data': Array<EmvTerminalWithAssignments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<EmvTerminalWithAssignments>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultEmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultHomeAction {
    /**
    * Generic data object.
    */
    'Data': Array<HomeAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HomeAction>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultHomeAction.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultKioskCashPaymentSettings {
    /**
    * Generic data object.
    */
    'Data': Array<KioskCashPaymentSettings>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<KioskCashPaymentSettings>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultKioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocalisedTimeZone {
    /**
    * Generic data object.
    */
    'Data': Array<LocalisedTimeZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocalisedTimeZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<LoyaltyCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LoyaltyCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuCheckpoint {
    /**
    * Generic data object.
    */
    'Data': Array<MenuCheckpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuCheckpoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuCheckpoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementEditResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementEditResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementEditResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementEditResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementListResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementListResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementListResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementListResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuStoreNames {
    /**
    * Generic data object.
    */
    'Data': Array<MenuStoreNames>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuStoreNames>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuStoreNames.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSummary {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuTaxDetails {
    /**
    * Generic data object.
    */
    'Data': Array<MenuTaxDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuTaxDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuTaxDetails.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': Array<OAuthApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthApp>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': Array<OauthClientRedirectUri>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPayoutSummary {
    /**
    * Generic data object.
    */
    'Data': Array<PayoutSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPayoutSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPreOrderTime {
    /**
    * Generic data object.
    */
    'Data': Array<PreOrderTime>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PreOrderTime>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPreOrderTime.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<ProcessingFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ProcessingFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestApiDefaultResponse {
    /**
    * Generic data object.
    */
    'Data': Array<RestApiDefaultResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<RetentionCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RetentionCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreListItem {
    /**
    * Generic data object.
    */
    'Data': Array<StoreListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreListItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreListItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<StoreStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreStatistics.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultSupportedCountry {
    /**
    * Generic data object.
    */
    'Data': Array<SupportedCountry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<SupportedCountry>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultSupportedCountry.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Array<Teammate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Teammate>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultVoucherDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<VoucherDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultVoucherDataPoint.attributeTypeMap;
    }
}

/**
* Rest api default response
*/
export class RestApiDefaultResponse {
    /**
    * Data string
    */
    'Data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api error result
*/
export class RestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Error code
    */
    'ErrorCode'?: number;
    /**
    * Stack trace
    */
    'StackTrace'?: string;
    /**
    * List of errors grouped by field name
    */
    'Errors'?: Array<ValidationErrorResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "ErrorCode",
            "baseName": "ErrorCode",
            "type": "number"
        },
        {
            "name": "StackTrace",
            "baseName": "StackTrace",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<ValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiErrorResult.attributeTypeMap;
    }
}

/**
* 
*/
export class RestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': EventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "EventSearchResult"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

/**
* Rest Api Forbidden Result
*/
export class RestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiForbiddenResult.attributeTypeMap;
    }
}

/**
* Rest api integer result
*/
export class RestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultApp {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<App>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<App>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultApp.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultBusinessHoursOverride {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursOverride>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHttpRequestAndResponseLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HttpRequestAndResponseLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHydraDeviceDetails {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HydraDeviceDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HydraDeviceDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHydraDeviceDetails.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOAuthTokenModel {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OAuthTokenModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOAuthTokenModel.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Order>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Order>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrderSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OrderSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrderSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayout {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Payout>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Payout>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayout.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutChargeback {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutChargeback>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutChargeback>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutChargeback.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOrder>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOtherCharge {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOtherCharge>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOtherCharge>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOtherCharge.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutRefund {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutRefund>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutRefund>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutRefund.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPhoneCall {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PhoneCall>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PhoneCall>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPhoneCall.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPushNotificationResponse {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PushNotificationResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PushNotificationResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStore {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Store>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Store>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStore.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroup>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroupExtended {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroupExtended>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroupExtended>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroupExtended.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreHeader {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreHeader>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreHeader.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultVoucherSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<VoucherSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultVoucherSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookSubscription {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookSubscription.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountDetail {
    /**
    * Generic data object.
    */
    'Data': AccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': AccountFieldsDefinitions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountFieldsDefinitions"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatistics {
    /**
    * Generic data object.
    */
    'Data': ApmStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatus {
    /**
    * Generic data object.
    */
    'Data': ApmStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApp {
    /**
    * Generic data object.
    */
    'Data': App;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "App"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppCompliance {
    /**
    * Generic data object.
    */
    'Data': AppCompliance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppCompliance"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppCompliance.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAssignedBankAccount {
    /**
    * Generic data object.
    */
    'Data': AssignedBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AssignedBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAssignedBankAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBankAccountDetail {
    /**
    * Generic data object.
    */
    'Data': BankAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BankAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBankAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBluetoothTerminalStatus {
    /**
    * Generic data object.
    */
    'Data': BluetoothTerminalStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BluetoothTerminalStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBluetoothTerminalStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursOverride {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursOverride;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursOverride"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursPeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursPeriod"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCoordinates {
    /**
    * Generic data object.
    */
    'Data': Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCoordinates.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCustomer {
    /**
    * Generic data object.
    */
    'Data': Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCustomer.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': DeliveryZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DeliveryZone"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDnsRecordInformation {
    /**
    * Generic data object.
    */
    'Data': DnsRecordInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DnsRecordInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDnsRecordInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDriver {
    /**
    * Generic data object.
    */
    'Data': Driver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Driver"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDriver.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHomeStatistics {
    /**
    * Generic data object.
    */
    'Data': HomeStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HomeStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHomeStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraConfig {
    /**
    * Generic data object.
    */
    'Data': HydraConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraStatus {
    /**
    * Generic data object.
    */
    'Data': HydraStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPage {
    /**
    * Generic data object.
    */
    'Data': IndexPage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPageBase {
    /**
    * Generic data object.
    */
    'Data': IndexPageBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPageBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPageBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultJobResponse {
    /**
    * Generic data object.
    */
    'Data': JobResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "JobResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultJobResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLightspeedSettings {
    /**
    * Generic data object.
    */
    'Data': LightspeedSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LightspeedSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLightspeedSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': LoyaltyCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LoyaltyCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenu {
    /**
    * Generic data object.
    */
    'Data': Menu;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Menu"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenu.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSetItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': MenuSection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSection"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionAvailability {
    /**
    * Generic data object.
    */
    'Data': MenuSectionAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionAvailability"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionAvailability.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': MenuSectionItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Metadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Metadata"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': OAuthApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OAuthApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': OauthClientRedirectUri;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrder {
    /**
    * Generic data object.
    */
    'Data': Order;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrder.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderPaymentInformation {
    /**
    * Generic data object.
    */
    'Data': OrderPaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderPaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalTransactionDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalTransactionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalTransactionDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPreOrderConfig {
    /**
    * Generic data object.
    */
    'Data': PreOrderConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PreOrderConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPreOrderConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': ProcessingFeeConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ProcessingFeeConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPushNotificationResponse {
    /**
    * Generic data object.
    */
    'Data': PushNotificationResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PushNotificationResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRedeemInvitationResult {
    /**
    * Generic data object.
    */
    'Data': RedeemInvitationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RedeemInvitationResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRedeemInvitationResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': RetentionCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RetentionCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStore {
    /**
    * Generic data object.
    */
    'Data': Store;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Store"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStore.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreAddress {
    /**
    * Generic data object.
    */
    'Data': StoreAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreAddress"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreAddress.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreEndOfDayReport {
    /**
    * Generic data object.
    */
    'Data': StoreEndOfDayReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreEndOfDayReport"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreEndOfDayReport.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroup {
    /**
    * Generic data object.
    */
    'Data': StoreGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroup"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroupBase {
    /**
    * Generic data object.
    */
    'Data': StoreGroupBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroupBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroupBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreOrderCapacityConfig {
    /**
    * Generic data object.
    */
    'Data': StoreOrderCapacityConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreOrderCapacityConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreOrderCapacityConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeConnectedAccount {
    /**
    * Generic data object.
    */
    'Data': StripeConnectedAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeConnectedAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeConnectedAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalPrivateKey {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalPrivateKey;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalPrivateKey"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalPrivateKey.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStuartSettings {
    /**
    * Generic data object.
    */
    'Data': StuartSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StuartSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStuartSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Teammate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Teammate"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultVoucherWithStats {
    /**
    * Generic data object.
    */
    'Data': VoucherWithStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "VoucherWithStats"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultVoucherWithStats.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteImage {
    /**
    * Generic data object.
    */
    'Data': WebsiteImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteImage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteImage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteTestimonial {
    /**
    * Generic data object.
    */
    'Data': WebsiteTestimonial;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteTestimonial"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Rest api string array result
*/
export class RestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringArrayResult.attributeTypeMap;
    }
}

/**
* Rest api string result
*/
export class RestApiStringResult {
    /**
    * Data string
    */
    'Data': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringResult.attributeTypeMap;
    }
}

/**
* Rest api unauthorized result
*/
export class RestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiUnauthorizedResult.attributeTypeMap;
    }
}

/**
* Retention campaign
*/
export class RetentionCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaign.attributeTypeMap;
    }
}

/**
* Retention campaign base
*/
export class RetentionCampaignBase {
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignBase.attributeTypeMap;
    }
}

/**
* Retention campaign created event
*/
export class RetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign deleted event
*/
export class RetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign updated event
*/
export class RetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Revenue Adjustments breakdown
*/
export class RevenueAdjustmentsDetails {
    /**
    * Online sales refunds
    */
    'OnlineSalesRefundedAmount'?: number;
    /**
    * Cash sales refunds
    */
    'CashSalesRefundedAmount'?: number;
    /**
    * Customer cash fees
    */
    'CustomerCashFees'?: number;
    /**
    * Number of refunds
    */
    'RefundsCount'?: number;
    /**
    * Total revenue adjustments
    */
    'TotalOnlineRevenueAdjustments'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesRefundedAmount",
            "baseName": "OnlineSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedAmount",
            "baseName": "CashSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CustomerCashFees",
            "baseName": "CustomerCashFees",
            "type": "number"
        },
        {
            "name": "RefundsCount",
            "baseName": "RefundsCount",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenueAdjustments",
            "baseName": "TotalOnlineRevenueAdjustments",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueAdjustmentsDetails.attributeTypeMap;
    }
}

/**
* Sales information
*/
export class RevenueDetail {
    /**
    * Online sales amount
    */
    'OnlineSalesAmount'?: number;
    /**
    * Online sales tax
    */
    'OnlineSalesTax'?: number;
    /**
    * Online sales amount plus online sales tax
    */
    'OnlineSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'OnlineSalesFeesBaseAmount'?: number;
    /**
    * Cash sales amount
    */
    'CashSalesAmount'?: number;
    /**
    * Cash sales tax
    */
    'CashSalesTax'?: number;
    /**
    * Cash sales amount plus online sales tax
    */
    'CashSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'CashSalesFeesBaseAmount'?: number;
    /**
    * Total Sales (online and cash) including tax
    */
    'TotalSalesIncludingTax'?: number;
    /**
    * Delivery charges on online sales
    */
    'OnlineSalesDeliveryCharges'?: number;
    /**
    * Tips for online sales
    */
    'OnlineSalesTips'?: number;
    /**
    * Online sales plus online delivery charges and tips
    */
    'TotalOnlineRevenue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesAmount",
            "baseName": "OnlineSalesAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesTax",
            "baseName": "OnlineSalesTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesIncludingTax",
            "baseName": "OnlineSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesFeesBaseAmount",
            "baseName": "OnlineSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "CashSalesAmount",
            "baseName": "CashSalesAmount",
            "type": "number"
        },
        {
            "name": "CashSalesTax",
            "baseName": "CashSalesTax",
            "type": "number"
        },
        {
            "name": "CashSalesIncludingTax",
            "baseName": "CashSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "CashSalesFeesBaseAmount",
            "baseName": "CashSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "TotalSalesIncludingTax",
            "baseName": "TotalSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesDeliveryCharges",
            "baseName": "OnlineSalesDeliveryCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesTips",
            "baseName": "OnlineSalesTips",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenue",
            "baseName": "TotalOnlineRevenue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueDetail.attributeTypeMap;
    }
}

/**
* Search Criteria for Audit Logs
*/
export class SearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit'?: number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page'?: number;
    /**
    * Start date
    */
    'Start'?: Date;
    /**
    * End date
    */
    'End'?: Date;
    /**
    * Events that have Order Id
    */
    'OrderId'?: number;
    /**
    * Events that have Store Id
    */
    'StoreId'?: number;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Events that have User Id
    */
    'UserId'?: number;
    /**
    * Events that have User Email
    */
    'UserEmail'?: string;
    /**
    * Events that have User Name
    */
    'UserName'?: string;
    /**
    * Events that have voucher code
    */
    'VoucherCode'?: string;
    /**
    * Events that have event type\\s
    */
    'EventType'?: Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "Array<string>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCriteria.attributeTypeMap;
    }
}

/**
* Set password with PIN model
*/
export class SetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SetPasswordWithPinModel.attributeTypeMap;
    }
}

/**
* 
*/
export class SignupStep {
    /**
    * Action needs to take
    */
    'Action'?: SignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question'?: string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers'?: Array<PredefinedAnswer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Action",
            "baseName": "Action",
            "type": "SignupStep.ActionEnum"
        },
        {
            "name": "Question",
            "baseName": "Question",
            "type": "string"
        },
        {
            "name": "PredefinedAnswers",
            "baseName": "PredefinedAnswers",
            "type": "Array<PredefinedAnswer>"
        }    ];

    static getAttributeTypeMap() {
        return SignupStep.attributeTypeMap;
    }
}

export namespace SignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription'
    }
}
/**
* Sms Info
*/
export class SmsInfo {
    /**
    * Origin phone number
    */
    'From'?: string;
    /**
    * Destination phone number
    */
    'To'?: string;
    /**
    * Text message
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "string"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "string"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsInfo.attributeTypeMap;
    }
}

/**
* Sms received event
*/
export class SmsReceivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The sms info
    */
    'SmsInfo'?: SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SmsInfo",
            "baseName": "SmsInfo",
            "type": "SmsInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsReceivedEvent.attributeTypeMap;
    }
}

/**
* A single currency data point, with no date
*/
export class StatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency'?: StatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount'?: number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount'?: number;
    /**
    * Value of orders for this currency
    */
    'OrderValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StatisticsCurrencyDataPoint.CurrencyEnum"
        },
        {
            "name": "UserCount",
            "baseName": "UserCount",
            "type": "number"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StatisticsCurrencyDataPoint.attributeTypeMap;
    }
}

export namespace StatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store
*/
export class Store {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId'?: number;
    /**
    * Store address
    */
    'Address'?: StoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones'?: Array<DeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber'?: string;
    /**
    * Pickup hours
    */
    'PickupHours'?: Array<BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours'?: Array<BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery'?: string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup'?: string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType'?: Store.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes'?: Array<StoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone'?: string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone'?: string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency'?: Store.CurrencyEnum;
    /**
    * Is PerOrder Enabled for Delivery
    */
    'PreOrderDeliveryEnabled'?: boolean;
    /**
    * Is PerOrder Enabled for Pickup
    */
    'PreOrderPickupEnabled'?: boolean;
    /**
    * Url for logo image
    */
    'LogoUrl'?: string;
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "StoreAddress"
        },
        {
            "name": "DeliveryZones",
            "baseName": "DeliveryZones",
            "type": "Array<DeliveryZone>"
        },
        {
            "name": "ApmPhoneNumber",
            "baseName": "ApmPhoneNumber",
            "type": "string"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "DeliveryHours",
            "baseName": "DeliveryHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "OrderConfirmationMessageOverrideDelivery",
            "baseName": "OrderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "OrderConfirmationMessageOverridePickup",
            "baseName": "OrderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "PrintoutLayoutType",
            "baseName": "PrintoutLayoutType",
            "type": "Store.PrintoutLayoutTypeEnum"
        },
        {
            "name": "StoreNotes",
            "baseName": "StoreNotes",
            "type": "Array<StoreNote>"
        },
        {
            "name": "MicrosoftTimeZone",
            "baseName": "MicrosoftTimeZone",
            "type": "string"
        },
        {
            "name": "IanaTimeZone",
            "baseName": "IanaTimeZone",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Store.CurrencyEnum"
        },
        {
            "name": "PreOrderDeliveryEnabled",
            "baseName": "PreOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "PreOrderPickupEnabled",
            "baseName": "PreOrderPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "LogoUrl",
            "baseName": "LogoUrl",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Store.attributeTypeMap;
    }
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store address
*/
export class StoreAddress {
    /**
    * Address identifier
    */
    'AddressId'?: number;
    /**
    * Coordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressId",
            "baseName": "AddressId",
            "type": "number"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddress.attributeTypeMap;
    }
}

/**
* Store address base
*/
export class StoreAddressBase {
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressBase.attributeTypeMap;
    }
}

/**
* Store Address Updated Event
*/
export class StoreAddressUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store address
    */
    'StoreAddress'?: StoreAddress;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreAddress",
            "baseName": "StoreAddress",
            "type": "StoreAddress"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Archived Event
*/
export class StoreArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which archived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Archived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreArchivedEvent.attributeTypeMap;
    }
}

/**
* Store Base
*/
export class StoreBase {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBase.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Created
*/
export class StoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Deleted
*/
export class StoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideDeletedEvent.attributeTypeMap;
    }
}

/**
* Store campaign start time
*/
export class StoreCampaignStartTime {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Campaign start time in Utc
    */
    'TsStart'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TsStart",
            "baseName": "TsStart",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreCampaignStartTime.attributeTypeMap;
    }
}

/**
* Settings for cloning a store
*/
export class StoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TargetStoreGroupId",
            "baseName": "TargetStoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreCloneSettings.attributeTypeMap;
    }
}

/**
* Store Create Base
*/
export class StoreCreateBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreateBase.attributeTypeMap;
    }
}

/**
* Store Created Event
*/
export class StoreCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which created this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Data Point
*/
export class StoreDataPoint {
    /**
    * Day
    */
    'Day'?: Date;
    /**
    * Value for the day
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "Date"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDataPoint.attributeTypeMap;
    }
}

/**
* Store Deleted Event
*/
export class StoreDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeletedEvent.attributeTypeMap;
    }
}

/**
* Store end of day report
*/
export class StoreEndOfDayReport {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Currency
    */
    'Currency'?: StoreEndOfDayReport.CurrencyEnum;
    /**
    * Order Count
    */
    'OrderCount'?: number;
    /**
    * Order Value
    */
    'OrderValue'?: number;
    /**
    * Order Value Excluding Delivery Fees
    */
    'OrderValueExcludingDeliveryFees'?: number;
    /**
    * Collection Order Count
    */
    'CollectionOrderCount'?: number;
    /**
    * Collection Cash Order Count
    */
    'CollectionCashOrderCount'?: number;
    /**
    * Collection Paid Online Order Count
    */
    'CollectionPaidOnlineOrderCount'?: number;
    /**
    * Collection Order Value
    */
    'CollectionOrderValue'?: number;
    /**
    * Collection Cash Order Value
    */
    'CollectionCashOrderValue'?: number;
    /**
    * Collection Paid Online Order Value
    */
    'CollectionPaidOnlineOrderValue'?: number;
    /**
    * Delivery Order Count
    */
    'DeliveryOrderCount'?: number;
    /**
    * Delivery Cash Order Count
    */
    'DeliveryCashOrderCount'?: number;
    /**
    * Delivery Paid Online Order Count
    */
    'DeliveryPaidOnlineOrderCount'?: number;
    /**
    * Delivery Order Value
    */
    'DeliveryOrderValue'?: number;
    /**
    * Delivery Cash Order Value
    */
    'DeliveryCashOrderValue'?: number;
    /**
    * Delivery Paid Online Order Value
    */
    'DeliveryPaidOnlineOrderValue'?: number;
    /**
    * Paid Online Order Count
    */
    'PaidOnlineOrderCount'?: number;
    /**
    * Cash Order Count
    */
    'CashOrderCount'?: number;
    /**
    * Paid Online Order Value
    */
    'PaidOnlineOrderValue'?: number;
    /**
    * Cash Order Value
    */
    'CashOrderValue'?: number;
    /**
    * Paid Online Order Value Excluding Delivery Fees
    */
    'PaidOnlineOrderValueExcludingDeliveryFees'?: number;
    /**
    * Cash Order Value Excluding Delivery Fees
    */
    'CashOrderValueExcludingDeliveryFees'?: number;
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreEndOfDayReport.CurrencyEnum"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        },
        {
            "name": "OrderValueExcludingDeliveryFees",
            "baseName": "OrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CollectionOrderCount",
            "baseName": "CollectionOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderCount",
            "baseName": "CollectionCashOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderCount",
            "baseName": "CollectionPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionOrderValue",
            "baseName": "CollectionOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderValue",
            "baseName": "CollectionCashOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderValue",
            "baseName": "CollectionPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryOrderCount",
            "baseName": "DeliveryOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderCount",
            "baseName": "DeliveryCashOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderCount",
            "baseName": "DeliveryPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryOrderValue",
            "baseName": "DeliveryOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderValue",
            "baseName": "DeliveryCashOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderValue",
            "baseName": "DeliveryPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderCount",
            "baseName": "PaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CashOrderCount",
            "baseName": "CashOrderCount",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValue",
            "baseName": "PaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "CashOrderValue",
            "baseName": "CashOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValueExcludingDeliveryFees",
            "baseName": "PaidOnlineOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CashOrderValueExcludingDeliveryFees",
            "baseName": "CashOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreEndOfDayReport.attributeTypeMap;
    }
}

export namespace StoreEndOfDayReport {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group
*/
export class StoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroup.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroup.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroup.attributeTypeMap;
    }
}

export namespace StoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Update Store Group
*/
export class StoreGroupBase {
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupBase.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupBase.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupBase.attributeTypeMap;
    }
}

export namespace StoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Created Event
*/
export class StoreGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Group Deleted Event
*/
export class StoreGroupDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Extended
*/
export class StoreGroupExtended {
    /**
    * Total Amount of Stores
    */
    'TotalStores'?: number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates'?: Array<GroupedCoordinates>;
    /**
    * Store Headers associated with Store Group
    */
    'StoreHeaders'?: Array<StoreHeader>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupExtended.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalStores",
            "baseName": "TotalStores",
            "type": "number"
        },
        {
            "name": "GroupedCoordinates",
            "baseName": "GroupedCoordinates",
            "type": "Array<GroupedCoordinates>"
        },
        {
            "name": "StoreHeaders",
            "baseName": "StoreHeaders",
            "type": "Array<StoreHeader>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupExtended.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupExtended.attributeTypeMap;
    }
}

export namespace StoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Updated Event
*/
export class StoreGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents the most basic store information, used mostly for searches
*/
export class StoreHeader {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreHeader.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSetting {
    /**
    * Kiosk setting id
    */
    'KioskSettingId'?: number;
    /**
    * Store kiosk name
    */
    'KioskName'?: string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName'?: boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber'?: boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOption'?: boolean;
    /**
    * Physical restaurant id
    */
    'PhysicalRestaurantId'?: number;
    /**
    * Hydra config id
    */
    'HydraConfigId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskSettingId",
            "baseName": "KioskSettingId",
            "type": "number"
        },
        {
            "name": "KioskName",
            "baseName": "KioskName",
            "type": "string"
        },
        {
            "name": "RequireCustomerName",
            "baseName": "RequireCustomerName",
            "type": "boolean"
        },
        {
            "name": "RequestTableNumber",
            "baseName": "RequestTableNumber",
            "type": "boolean"
        },
        {
            "name": "OfferDineInOrTakeawayOption",
            "baseName": "OfferDineInOrTakeawayOption",
            "type": "boolean"
        },
        {
            "name": "PhysicalRestaurantId",
            "baseName": "PhysicalRestaurantId",
            "type": "number"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSetting.attributeTypeMap;
    }
}

/**
* Store kiosk setting updated
*/
export class StoreKioskSettingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store kiosk settings
    */
    'StoreKioskSetting'?: StoreKioskSetting;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreKioskSetting",
            "baseName": "StoreKioskSetting",
            "type": "StoreKioskSetting"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSettingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store id and name
*/
export class StoreListItem {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Name
    */
    'StoreName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Store Group Name
    */
    'StoreGroupName'?: string;
    /**
    * Store has loyalty campaign
    */
    'HasLoyaltyCampaign'?: boolean;
    /**
    * Store has retention campaign
    */
    'HasRetentionCampaign'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "StoreGroupName",
            "baseName": "StoreGroupName",
            "type": "string"
        },
        {
            "name": "HasLoyaltyCampaign",
            "baseName": "HasLoyaltyCampaign",
            "type": "boolean"
        },
        {
            "name": "HasRetentionCampaign",
            "baseName": "HasRetentionCampaign",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StoreListItem.attributeTypeMap;
    }
}

/**
* Store logo created
*/
export class StoreLogoCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who added the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoCreatedEvent.attributeTypeMap;
    }
}

/**
* Store logo deleted
*/
export class StoreLogoDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who removed the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoDeletedEvent.attributeTypeMap;
    }
}

/**
* Store logo updated
*/
export class StoreLogoUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who updated the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Assigned To Store Event
*/
export class StoreMenuAssignedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * MenuId Id
    */
    'MenuId'?: number;
    /**
    * User who assigned the menu to the store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreMenuAssignedEvent.attributeTypeMap;
    }
}

/**
* Store note
*/
export class StoreNote {
    /**
    * User identifier
    */
    'UserId'?: number;
    /**
    * Create time
    */
    'CreateTime'?: Date;
    /**
    * Note
    */
    'Note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Note",
            "baseName": "Note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreNote.attributeTypeMap;
    }
}

/**
* Store Opening Hours Updated Event
*/
export class StoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated opening hours for this store
    */
    'User'?: UserEventInfo;
    /**
    * Type of opening hours Delivery / Pickup
    */
    'DeliveryType'?: StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum;
    /**
    * The period that was updated
    */
    'BusinessHoursPeriodOld'?: BusinessHoursPeriod;
    /**
    * The new values of the period
    */
    'BusinessHoursPeriod'?: BusinessHoursPeriod;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum"
        },
        {
            "name": "BusinessHoursPeriodOld",
            "baseName": "BusinessHoursPeriodOld",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "BusinessHoursPeriod",
            "baseName": "BusinessHoursPeriod",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

export namespace StoreOpeningHoursUpdatedEvent {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration
*/
export class StoreOrderCapacityConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Signifies whether the order capacity configuration is for Delivery / Pickup
    */
    'DeliveryType'?: StoreOrderCapacityConfig.DeliveryTypeEnum;
    /**
    * Store Interval - time between orders, e.g. 10 minutes between each order time available to customer
    */
    'StoreIntervalInMinutes'?: number;
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOrderCapacityConfig.DeliveryTypeEnum"
        },
        {
            "name": "StoreIntervalInMinutes",
            "baseName": "StoreIntervalInMinutes",
            "type": "number"
        },
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfig.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityConfig {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration edit
*/
export class StoreOrderCapacityConfigEditModel {
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfigEditModel.attributeTypeMap;
    }
}

/**
* Represents a single order capacity period
*/
export class StoreOrderCapacityPeriod {
    /**
    * The maximum number of orders per each store order interval in this order capacity period.  E.g. for a period from 9:00 till 11:00, if the store's interval is 10 minutes, and MaxOrderNumberPerStoreInterval is set to 5,  it means that within each 10-minute interval between 9:00 and 11:00 (i.e. 9:00-9:10, 9:10-9:20, .. , 10:50-11:00) it will be possible to  request at most 5 orders.
    */
    'MaxOrderNumberPerStoreInterval'?: number;
    /**
    * Day of the week the period pertains to
    */
    'DayOfTheWeek'?: StoreOrderCapacityPeriod.DayOfTheWeekEnum;
    /**
    * The hour the period starts at
    */
    'PeriodStartHour'?: number;
    /**
    * The minutes after the hour the period starts at
    */
    'PeriodStartMinutes'?: number;
    /**
    * The hour the period ends at
    */
    'PeriodEndHour'?: number;
    /**
    * The minutes after the hour the period ends at
    */
    'PeriodEndMinutes'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxOrderNumberPerStoreInterval",
            "baseName": "MaxOrderNumberPerStoreInterval",
            "type": "number"
        },
        {
            "name": "DayOfTheWeek",
            "baseName": "DayOfTheWeek",
            "type": "StoreOrderCapacityPeriod.DayOfTheWeekEnum"
        },
        {
            "name": "PeriodStartHour",
            "baseName": "PeriodStartHour",
            "type": "number"
        },
        {
            "name": "PeriodStartMinutes",
            "baseName": "PeriodStartMinutes",
            "type": "number"
        },
        {
            "name": "PeriodEndHour",
            "baseName": "PeriodEndHour",
            "type": "number"
        },
        {
            "name": "PeriodEndMinutes",
            "baseName": "PeriodEndMinutes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityPeriod.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityPeriod {
    export enum DayOfTheWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Store Pre order config updated
*/
export class StorePreOrderConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Pre Order Configuration
    */
    'PreOrderConfig'?: PreOrderConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PreOrderConfig",
            "baseName": "PreOrderConfig",
            "type": "PreOrderConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePreOrderConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Published Event
*/
export class StorePublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which published this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Published Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePublishedEvent.attributeTypeMap;
    }
}

/**
* Store statistics
*/
export class StoreStatistics {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Data Points
    */
    'Data'?: Array<StoreDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return StoreStatistics.attributeTypeMap;
    }
}

/**
* Store summary
*/
export class StoreSummary {
    /**
    * Store identifier
    */
    'Id'?: number;
    /**
    * Store name
    */
    'Name'?: string;
    /**
    * Stores menu identifier
    */
    'MenuId'?: number;
    /**
    * Store metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency'?: StoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates'?: Coordinates;
    /**
    * Timezone of store
    */
    'StoreTimezone'?: string;
    /**
    * Store group id of store
    */
    'StoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreSummary.CurrencyEnum"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "StoreTimezone",
            "baseName": "StoreTimezone",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreSummary.attributeTypeMap;
    }
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Unarchived Event
*/
export class StoreUnarchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unarchived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unarchived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnarchivedEvent.attributeTypeMap;
    }
}

/**
* Store Unpublished Event
*/
export class StoreUnpublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unpublished this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unpublished Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnpublishedEvent.attributeTypeMap;
    }
}

/**
* Store Updated Event
*/
export class StoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a request for Stripe account link creation
*/
export class StripeAccountLinkRequest {
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * URL to be hit if link creation succeeds
    */
    'ReturnUrl'?: string;
    /**
    * Which information to collect from users at this stage
    */
    'Collect'?: StripeAccountLinkRequest.CollectEnum;
    /**
    * Either onboarding or edit user information
    */
    'Type'?: StripeAccountLinkRequest.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "ReturnUrl",
            "baseName": "ReturnUrl",
            "type": "string"
        },
        {
            "name": "Collect",
            "baseName": "Collect",
            "type": "StripeAccountLinkRequest.CollectEnum"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "StripeAccountLinkRequest.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeAccountLinkRequest.attributeTypeMap;
    }
}

export namespace StripeAccountLinkRequest {
    export enum CollectEnum {
        CurrentlyDue = <any> 'CurrentlyDue',
        EventuallyDue = <any> 'EventuallyDue'
    }
    export enum TypeEnum {
        Onboarding = <any> 'Onboarding',
        Update = <any> 'Update'
    }
}
/**
* Represents a Stripe custom connected account
*/
export class StripeConnectedAccount {
    /**
    * Flipdish connected account identifier
    */
    'FlipdishConnectedAccountId'?: number;
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * Id of the WhitelabelConfig the connected account is assigned to
    */
    'WhitelabelConfigId'?: number;
    /**
    * Card payments capability status (Inactive, Pending, Active, Unrequested)
    */
    'CardPaymentsStatus'?: StripeConnectedAccount.CardPaymentsStatusEnum;
    /**
    * Transfers capability status (Inactive, Pending, Active, Unrequested)
    */
    'TransfersStatus'?: StripeConnectedAccount.TransfersStatusEnum;
    /**
    * Current status of the account
    */
    'AccountStatus'?: StripeConnectedAccount.AccountStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FlipdishConnectedAccountId",
            "baseName": "FlipdishConnectedAccountId",
            "type": "number"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "WhitelabelConfigId",
            "baseName": "WhitelabelConfigId",
            "type": "number"
        },
        {
            "name": "CardPaymentsStatus",
            "baseName": "CardPaymentsStatus",
            "type": "StripeConnectedAccount.CardPaymentsStatusEnum"
        },
        {
            "name": "TransfersStatus",
            "baseName": "TransfersStatus",
            "type": "StripeConnectedAccount.TransfersStatusEnum"
        },
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccount.AccountStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccount.attributeTypeMap;
    }
}

export namespace StripeConnectedAccount {
    export enum CardPaymentsStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum TransfersStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
}
/**
* Represents information about a Stripe connected account associated with a bank account
*/
export class StripeConnectedAccountInfo {
    /**
    * Stripe connected account status
    */
    'AccountStatus'?: StripeConnectedAccountInfo.AccountStatusEnum;
    /**
    * Stripe connected account id
    */
    'StripeId'?: string;
    /**
    * Current status of the Card Payment capability of the account
    */
    'CardPaymentStatus'?: StripeConnectedAccountInfo.CardPaymentStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccountInfo.AccountStatusEnum"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "CardPaymentStatus",
            "baseName": "CardPaymentStatus",
            "type": "StripeConnectedAccountInfo.CardPaymentStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccountInfo.attributeTypeMap;
    }
}

export namespace StripeConnectedAccountInfo {
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
    export enum CardPaymentStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
}
/**
* Stripe Terminal Private Key
*/
export class StripeTerminalPrivateKey {
    /**
    * Registered location of the terminal
    */
    'Location'?: string;
    /**
    * Secret used to pass to stripe to attach terminal
    */
    'Secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "string"
        },
        {
            "name": "Secret",
            "baseName": "Secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalPrivateKey.attributeTypeMap;
    }
}

/**
* Stuart settings
*/
export class StuartSettings {
    /**
    * Client Id
    */
    'ClientId'?: string;
    /**
    * Client Secret
    */
    'ClientSecret'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication'?: string;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime'?: number;
    /**
    * Package type
    */
    'PackageType'?: StuartSettings.PackageTypeEnum;
    /**
    * Transport type
    */
    'TransportType'?: StuartSettings.TransportTypeEnum;
    /**
    * Determines if Flipdish order should be cancel when Stuart cancels delivery
    */
    'CancelOrderIfStuartCancelDelivery'?: boolean;
    'TransportPrices'?: StuartSettingsTransportPrices;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "ClientSecret",
            "baseName": "ClientSecret",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "WebhookUrlBasicAuthentication",
            "baseName": "WebhookUrlBasicAuthentication",
            "type": "string"
        },
        {
            "name": "MinutesToPickupBeforeThanDeliveryTime",
            "baseName": "MinutesToPickupBeforeThanDeliveryTime",
            "type": "number"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "StuartSettings.PackageTypeEnum"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "StuartSettings.TransportTypeEnum"
        },
        {
            "name": "CancelOrderIfStuartCancelDelivery",
            "baseName": "CancelOrderIfStuartCancelDelivery",
            "type": "boolean"
        },
        {
            "name": "TransportPrices",
            "baseName": "TransportPrices",
            "type": "StuartSettingsTransportPrices"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettings.attributeTypeMap;
    }
}

export namespace StuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
    export enum TransportTypeEnum {
        Bike = <any> 'Bike',
        Cargobike = <any> 'Cargobike',
        Cargobikexl = <any> 'Cargobikexl',
        Motorbike = <any> 'Motorbike',
        Motorbikexl = <any> 'Motorbikexl',
        Car = <any> 'Car',
        Van = <any> 'Van'
    }
}
/**
* If the order exceeds are certain amount this configuration will determine a new vehicle type
*/
export class StuartSettingsTransportPrices {
    'Bike'?: number;
    'Cargobike'?: number;
    'Cargobikexl'?: number;
    'Motorbike'?: number;
    'Motorbikexl'?: number;
    'Car'?: number;
    'Van'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Bike",
            "baseName": "Bike",
            "type": "number"
        },
        {
            "name": "Cargobike",
            "baseName": "Cargobike",
            "type": "number"
        },
        {
            "name": "Cargobikexl",
            "baseName": "Cargobikexl",
            "type": "number"
        },
        {
            "name": "Motorbike",
            "baseName": "Motorbike",
            "type": "number"
        },
        {
            "name": "Motorbikexl",
            "baseName": "Motorbikexl",
            "type": "number"
        },
        {
            "name": "Car",
            "baseName": "Car",
            "type": "number"
        },
        {
            "name": "Van",
            "baseName": "Van",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettingsTransportPrices.attributeTypeMap;
    }
}

/**
* Describes a supported country
*/
export class SupportedCountry {
    /**
    * Country code
    */
    'CountryCode'?: string;
    /**
    * Nice display name for a country
    */
    'Name'?: string;
    /**
    * Country internatinoal phone code prefix
    */
    'PhoneCode'?: number;
    /**
    * Language code
    */
    'LanguageCode'?: string;
    /**
    * Language name
    */
    'LanguageName'?: string;
    /**
    * The phone number provided to Store staff which, in conjunction with a one-time-code, will connect them to the customer.
    */
    'OtpNumber'?: string;
    /**
    * The store's support phone number, displayed to customers.
    */
    'SupportNumber'?: string;
    /**
    * Address layout format. This changes the layout of address entry forms on the web app, iOS and Android app and should be set based on local custom.
    */
    'AddressLayout'?: SupportedCountry.AddressLayoutEnum;
    /**
    * Post code type
    */
    'PostCodeType'?: SupportedCountry.PostCodeTypeEnum;
    /**
    * Supported region. This is not used.
    */
    'SupportRegion'?: SupportedCountry.SupportRegionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PhoneCode",
            "baseName": "PhoneCode",
            "type": "number"
        },
        {
            "name": "LanguageCode",
            "baseName": "LanguageCode",
            "type": "string"
        },
        {
            "name": "LanguageName",
            "baseName": "LanguageName",
            "type": "string"
        },
        {
            "name": "OtpNumber",
            "baseName": "OtpNumber",
            "type": "string"
        },
        {
            "name": "SupportNumber",
            "baseName": "SupportNumber",
            "type": "string"
        },
        {
            "name": "AddressLayout",
            "baseName": "AddressLayout",
            "type": "SupportedCountry.AddressLayoutEnum"
        },
        {
            "name": "PostCodeType",
            "baseName": "PostCodeType",
            "type": "SupportedCountry.PostCodeTypeEnum"
        },
        {
            "name": "SupportRegion",
            "baseName": "SupportRegion",
            "type": "SupportedCountry.SupportRegionEnum"
        }    ];

    static getAttributeTypeMap() {
        return SupportedCountry.attributeTypeMap;
    }
}

export namespace SupportedCountry {
    export enum AddressLayoutEnum {
        BuildingFirst = <any> 'BuildingFirst',
        AddressFirst = <any> 'AddressFirst',
        FullStreetAddressFirst = <any> 'FullStreetAddressFirst'
    }
    export enum PostCodeTypeEnum {
        None = <any> 'None',
        PostCode = <any> 'PostCode',
        Zip = <any> 'Zip'
    }
    export enum SupportRegionEnum {
        Default = <any> 'Default',
        Spain = <any> 'Spain',
        Benelux = <any> 'Benelux'
    }
}
/**
* 
*/
export class Teammate {
    /**
    * Unique indentifier
    */
    'TeammateId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Last activity
    */
    'LastActivity'?: Date;
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: Teammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: Teammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TeammateId",
            "baseName": "TeammateId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "LastActivity",
            "baseName": "LastActivity",
            "type": "Date"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "Teammate.InvitationStatusEnum"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "Teammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return Teammate.attributeTypeMap;
    }
}

export namespace Teammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel'?: TeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "TeammateBase.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TeammateBase.attributeTypeMap;
    }
}

export namespace TeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who deleted the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who accepted the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteAcceptedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who sent the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who updated the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateUpdatedEvent.attributeTypeMap;
    }
}

/**
* UpdateDriver Push Notification Token
*/
export class UpdateDriverNotificationToken {
    /**
    * Push notifications token, cannot be null
    */
    'PushNotificationsToken': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PushNotificationsToken",
            "baseName": "PushNotificationsToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverNotificationToken.attributeTypeMap;
    }
}

/**
* Update Driver Profile
*/
export class UpdateDriverProfileModel {
    /**
    * The new name of the Driver.
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverProfileModel.attributeTypeMap;
    }
}

/**
* User answered signup questions event
*/
export class UserAnsweredSignupQuestionsEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The users answers
    */
    'SignupAnswers'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "SignupAnswers",
            "baseName": "SignupAnswers",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserAnsweredSignupQuestionsEvent.attributeTypeMap;
    }
}

/**
* User created event
*/
export class UserCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserCreatedEvent.attributeTypeMap;
    }
}

/**
* User deleted event
*/
export class UserDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDeletedEvent.attributeTypeMap;
    }
}

/**
* User Event Info
*/
export class UserEventInfo {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * User Email
    */
    'UserEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserEventInfo.attributeTypeMap;
    }
}

/**
* User login event
*/
export class UserLoginEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserLoginEvent.attributeTypeMap;
    }
}

/**
* User created password event
*/
export class UserPasswordCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserPasswordCreatedEvent.attributeTypeMap;
    }
}

/**
* User updated event
*/
export class UserUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdatedEvent.attributeTypeMap;
    }
}

/**
* Validation error result
*/
export class ValidationErrorResult {
    /**
    * Field name
    */
    'FieldName'?: string;
    /**
    * List of errors relates to field
    */
    'Errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FieldName",
            "baseName": "FieldName",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ValidationErrorResult.attributeTypeMap;
    }
}

/**
* Voucher
*/
export class Voucher {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: Voucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: Voucher.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: Voucher.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: Voucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Voucher.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "Voucher.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "Voucher.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Voucher.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Voucher.attributeTypeMap;
    }
}

export namespace Voucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Voucher Base
*/
export class VoucherBase {
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherBase.attributeTypeMap;
    }
}

/**
* Voucher Created Event
*/
export class VoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which created this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherCreatedEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class VoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDataPoint.attributeTypeMap;
    }
}

/**
* Voucher Deleted Event
*/
export class VoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which deleted this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDeletedEvent.attributeTypeMap;
    }
}

/**
* Voucher Summary
*/
export class VoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Status
    */
    'Status'?: VoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherSummary.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherSummary.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherSummary.VoucherSubTypeEnum"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VoucherSummary.attributeTypeMap;
    }
}

export namespace VoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Updated Event
*/
export class VoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which updated this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher With Statistics
*/
export class VoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed'?: number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers'?: number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders'?: number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted'?: number;
    /**
    * Average Order Size
    */
    'AverageOrderSize'?: number;
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: VoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherWithStats.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherWithStats.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: VoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalUsed",
            "baseName": "TotalUsed",
            "type": "number"
        },
        {
            "name": "TotalCustomers",
            "baseName": "TotalCustomers",
            "type": "number"
        },
        {
            "name": "TotalAmountFromOrders",
            "baseName": "TotalAmountFromOrders",
            "type": "number"
        },
        {
            "name": "TotalDiscounted",
            "baseName": "TotalDiscounted",
            "type": "number"
        },
        {
            "name": "AverageOrderSize",
            "baseName": "AverageOrderSize",
            "type": "number"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherWithStats.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherWithStats.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherWithStats.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "VoucherWithStats.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherWithStats.attributeTypeMap;
    }
}

export namespace VoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Sample payload of a webhook event
*/
export class WebhookEventSample {
    /**
    * Event name
    */
    'Type'?: string;
    /**
    * Sample event creation date and time
    */
    'CreateTime'?: Date;
    /**
    * Sample event body
    */
    'Body'?: FlipdishEventBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Body",
            "baseName": "Body",
            "type": "FlipdishEventBase"
        }    ];

    static getAttributeTypeMap() {
        return WebhookEventSample.attributeTypeMap;
    }
}

/**
* Webhook log
*/
export class WebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId'?: number;
    /**
    * Event created
    */
    'EventCreated'?: string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered'?: string;
    /**
    * Webhook event name
    */
    'WebhookEventName'?: string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl'?: string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode'?: string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus'?: string;
    /**
    * Request headers
    */
    'RequestHeaders'?: string;
    /**
    * Request body
    */
    'RequestBody'?: string;
    /**
    * Received response headers
    */
    'ResponseHeaders'?: string;
    /**
    * Received response body
    */
    'ResponseBody'?: string;
    /**
    * Duration of HTTP request
    */
    'Duration'?: string;
    /**
    * Retry count
    */
    'RetryCount'?: number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId'?: string;
    /**
    * Flipdish webhook version
    */
    'Version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebhookSubscriptionOwnerUserId",
            "baseName": "WebhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "EventCreated",
            "baseName": "EventCreated",
            "type": "string"
        },
        {
            "name": "WebhookTriggered",
            "baseName": "WebhookTriggered",
            "type": "string"
        },
        {
            "name": "WebhookEventName",
            "baseName": "WebhookEventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionCallbackUrl",
            "baseName": "WebhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "HttpResponseStatusCode",
            "baseName": "HttpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "HttpResponseStatus",
            "baseName": "HttpResponseStatus",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "string"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "string"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "string"
        },
        {
            "name": "RetryCount",
            "baseName": "RetryCount",
            "type": "number"
        },
        {
            "name": "FlipdishWebhookId",
            "baseName": "FlipdishWebhookId",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

/**
* Webhook subscription
*/
export class WebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version'?: string;
    /**
    * Webhook subscription event names
    */
    'EventNames'?: Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl'?: string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled'?: boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "EventNames",
            "baseName": "EventNames",
            "type": "Array<string>"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "VerifyToken",
            "baseName": "VerifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscription.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId'?: number;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Webhook callback url
    */
    'CallbackUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "WebhookSubscriptionId",
            "baseName": "WebhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a website image
*/
export class WebsiteImage {
    /**
    * Represents the id of the image
    */
    'ImageId'?: number;
    /**
    * Represents the location of the image
    */
    'ImageLocation'?: WebsiteImage.ImageLocationEnum;
    /**
    * Represents the image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageId",
            "baseName": "ImageId",
            "type": "number"
        },
        {
            "name": "ImageLocation",
            "baseName": "ImageLocation",
            "type": "WebsiteImage.ImageLocationEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteImage.attributeTypeMap;
    }
}

export namespace WebsiteImage {
    export enum ImageLocationEnum {
        IndexHeader = <any> 'IndexHeader',
        IndexAboutSectionLeft = <any> 'IndexAboutSectionLeft',
        IndexAboutSectionRight = <any> 'IndexAboutSectionRight',
        IndexGallery = <any> 'IndexGallery',
        IndexOpeningHoursHeader = <any> 'IndexOpeningHoursHeader',
        IndexTestimonialsHeader = <any> 'IndexTestimonialsHeader'
    }
}
/**
* Represents a testimonial
*/
export class WebsiteTestimonial {
    /**
    * Id of the testimonial
    */
    'TestimonialId'?: number;
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TestimonialId",
            "baseName": "TestimonialId",
            "type": "number"
        },
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Represents a testimonial base
*/
export class WebsiteTestimonialBase {
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonialBase.attributeTypeMap;
    }
}

/**
* WebsiteUpdatedEvent
*/
export class WebsiteUpdatedEvent {
    /**
    * App Name id of the whitelabel of the website
    */
    'AppNameId'?: string;
    /**
    * User updating the website
    */
    'User'?: UserEventInfo;
    /**
    * Description of event
    */
    'Description'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppNameId",
            "baseName": "AppNameId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteUpdatedEvent.attributeTypeMap;
    }
}

/**
* Website vanity url
*/
export class WebsiteVanityUrlUpdatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the url
    */
    'User'?: UserEventInfo;
    /**
    * New vanity url
    */
    'VanityUrl'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "VanityUrl",
            "baseName": "VanityUrl",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteVanityUrlUpdatedEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AccountFieldDefinition.KeyEnum": AccountFieldDefinition.KeyEnum,
        "AccountFieldDefinition.TypeEnum": AccountFieldDefinition.TypeEnum,
        "AccountFieldKeyValuePair.KeyEnum": AccountFieldKeyValuePair.KeyEnum,
        "ApmHourlyDataPoint.DayEnum": ApmHourlyDataPoint.DayEnum,
        "App.AppAccessLevelEnum": App.AppAccessLevelEnum,
        "App.AppResourceSetEnum": App.AppResourceSetEnum,
        "App.ApplicationCategoryEnum": App.ApplicationCategoryEnum,
        "AppCompliance.ComplianceTypeEnum": AppCompliance.ComplianceTypeEnum,
        "AppConfigUpdateModel.ApplicationCategoryEnum": AppConfigUpdateModel.ApplicationCategoryEnum,
        "BankAccount.AccountStateEnum": BankAccount.AccountStateEnum,
        "BankAccountCreate.CurrencyCodeEnum": BankAccountCreate.CurrencyCodeEnum,
        "BankAccountCreate.BusinessTypeEnum": BankAccountCreate.BusinessTypeEnum,
        "BankAccountDetail.AccountStateEnum": BankAccountDetail.AccountStateEnum,
        "BankAccountDetail.CurrencyCodeEnum": BankAccountDetail.CurrencyCodeEnum,
        "BankAccountDetail.BusinessTypeEnum": BankAccountDetail.BusinessTypeEnum,
        "BankAccountDetailsUpdateRequest.BusinessTypeEnum": BankAccountDetailsUpdateRequest.BusinessTypeEnum,
        "BankAccountSummary.AccountStateEnum": BankAccountSummary.AccountStateEnum,
        "BankAccountSummary.BusinessTypeEnum": BankAccountSummary.BusinessTypeEnum,
        "BluetoothTerminalStatus.DeviceTypeEnum": BluetoothTerminalStatus.DeviceTypeEnum,
        "BluetoothTerminalStatus.StatusEnum": BluetoothTerminalStatus.StatusEnum,
        "BusinessHoursOverride.DeliveryTypeEnum": BusinessHoursOverride.DeliveryTypeEnum,
        "BusinessHoursOverride.TypeEnum": BusinessHoursOverride.TypeEnum,
        "BusinessHoursOverrideBase.DeliveryTypeEnum": BusinessHoursOverrideBase.DeliveryTypeEnum,
        "BusinessHoursOverrideBase.TypeEnum": BusinessHoursOverrideBase.TypeEnum,
        "BusinessHoursPeriod.DayOfWeekEnum": BusinessHoursPeriod.DayOfWeekEnum,
        "BusinessHoursPeriodBase.DayOfWeekEnum": BusinessHoursPeriodBase.DayOfWeekEnum,
        "CreateFullMenu.MenuSectionBehaviourEnum": CreateFullMenu.MenuSectionBehaviourEnum,
        "CreateFullMenu.TaxTypeEnum": CreateFullMenu.TaxTypeEnum,
        "CreateFullMenuItemOptionSet.CellLayoutTypeEnum": CreateFullMenuItemOptionSet.CellLayoutTypeEnum,
        "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum": CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum,
        "CreateFullMenuSectionItem.SpicinessRatingEnum": CreateFullMenuSectionItem.SpicinessRatingEnum,
        "CreateFullMenuSectionItem.CellLayoutTypeEnum": CreateFullMenuSectionItem.CellLayoutTypeEnum,
        "CreateTeammate.AppAccessLevelEnum": CreateTeammate.AppAccessLevelEnum,
        "CreateVoucher.VoucherTypeEnum": CreateVoucher.VoucherTypeEnum,
        "CurrencyData.CurrencyEnum": CurrencyData.CurrencyEnum,
        "CustomerDeliveryTrackingOrder.CurrencyEnum": CustomerDeliveryTrackingOrder.CurrencyEnum,
        "DriverStore.PresenceEnum": DriverStore.PresenceEnum,
        "HomeAction.HomeActionTypeEnum": HomeAction.HomeActionTypeEnum,
        "HydraConfig.PaymentOptionsEnum": HydraConfig.PaymentOptionsEnum,
        "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum": HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum,
        "HydraDeviceDetails.DeviceTypeEnum": HydraDeviceDetails.DeviceTypeEnum,
        "HydraDeviceDetails.StatusEnum": HydraDeviceDetails.StatusEnum,
        "HydraStatus.UserTypeEnum": HydraStatus.UserTypeEnum,
        "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum": KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent.UpdateTimeEstimateEnum": KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent.UpdateTimeEstimateEnum,
        "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum,
        "LightspeedSettings.PriceTypeEnum": LightspeedSettings.PriceTypeEnum,
        "Menu.MenuSectionBehaviourEnum": Menu.MenuSectionBehaviourEnum,
        "Menu.TaxTypeEnum": Menu.TaxTypeEnum,
        "MenuBase.MenuSectionBehaviourEnum": MenuBase.MenuSectionBehaviourEnum,
        "MenuBase.TaxTypeEnum": MenuBase.TaxTypeEnum,
        "MenuElementEditResponse.MenuElementTypeEnum": MenuElementEditResponse.MenuElementTypeEnum,
        "MenuElementEditResponse.ValidationCodeEnum": MenuElementEditResponse.ValidationCodeEnum,
        "MenuElementHide.MenuElementTypeEnum": MenuElementHide.MenuElementTypeEnum,
        "MenuElementListItemResponse.MenuElementTypeEnum": MenuElementListItemResponse.MenuElementTypeEnum,
        "MenuItemOptionSet.CellLayoutTypeEnum": MenuItemOptionSet.CellLayoutTypeEnum,
        "MenuItemOptionSetBase.CellLayoutTypeEnum": MenuItemOptionSetBase.CellLayoutTypeEnum,
        "MenuItemOptionSetItem.CellLayoutTypeEnum": MenuItemOptionSetItem.CellLayoutTypeEnum,
        "MenuItemOptionSetItemBase.CellLayoutTypeEnum": MenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "MenuSectionAvailability.AvailabilityModeEnum": MenuSectionAvailability.AvailabilityModeEnum,
        "MenuSectionAvailabilityBase.AvailabilityModeEnum": MenuSectionAvailabilityBase.AvailabilityModeEnum,
        "MenuSectionItem.SpicinessRatingEnum": MenuSectionItem.SpicinessRatingEnum,
        "MenuSectionItem.CellLayoutTypeEnum": MenuSectionItem.CellLayoutTypeEnum,
        "MenuSectionItemBase.SpicinessRatingEnum": MenuSectionItemBase.SpicinessRatingEnum,
        "MenuSectionItemBase.CellLayoutTypeEnum": MenuSectionItemBase.CellLayoutTypeEnum,
        "MenuTaxDetails.TaxTypeEnum": MenuTaxDetails.TaxTypeEnum,
        "OAuthApp.FlowEnum": OAuthApp.FlowEnum,
        "OAuthApp.RefreshTokenUsageEnum": OAuthApp.RefreshTokenUsageEnum,
        "Order.DeliveryTypeEnum": Order.DeliveryTypeEnum,
        "Order.PickupLocationTypeEnum": Order.PickupLocationTypeEnum,
        "Order.TableServiceCatagoryEnum": Order.TableServiceCatagoryEnum,
        "Order.PaymentAccountTypeEnum": Order.PaymentAccountTypeEnum,
        "Order.OrderStateEnum": Order.OrderStateEnum,
        "Order.AppTypeEnum": Order.AppTypeEnum,
        "Order.PaymentStatusEnum": Order.PaymentStatusEnum,
        "Order.RejectionReasonEnum": Order.RejectionReasonEnum,
        "Order.DeliveryTrackingStatusEnum": Order.DeliveryTrackingStatusEnum,
        "OrderSummary.DeliveryTypeEnum": OrderSummary.DeliveryTypeEnum,
        "OrderSummary.PickupLocationTypeEnum": OrderSummary.PickupLocationTypeEnum,
        "OrderSummary.TableServiceCatagoryEnum": OrderSummary.TableServiceCatagoryEnum,
        "OrderSummary.OrderStateEnum": OrderSummary.OrderStateEnum,
        "OrderSummary.PaymentAccountTypeEnum": OrderSummary.PaymentAccountTypeEnum,
        "OrderSummary.PaymentStatusEnum": OrderSummary.PaymentStatusEnum,
        "OrderSummary.CurrencyEnum": OrderSummary.CurrencyEnum,
        "OrderSummary.AppTypeEnum": OrderSummary.AppTypeEnum,
        "OrderVoucherSummary.TypeEnum": OrderVoucherSummary.TypeEnum,
        "OrderVoucherSummary.SubTypeEnum": OrderVoucherSummary.SubTypeEnum,
        "Payout.PayoutStatusEnum": Payout.PayoutStatusEnum,
        "Payout.PayoutTypeEnum": Payout.PayoutTypeEnum,
        "Payout.CurrencyEnum": Payout.CurrencyEnum,
        "PayoutChargeback.OrderCurrencyEnum": PayoutChargeback.OrderCurrencyEnum,
        "PayoutChargeback.OrderTypeEnum": PayoutChargeback.OrderTypeEnum,
        "PayoutDetail.PayoutStatusEnum": PayoutDetail.PayoutStatusEnum,
        "PayoutDetail.PayoutTypeEnum": PayoutDetail.PayoutTypeEnum,
        "PayoutDetail.CurrencyEnum": PayoutDetail.CurrencyEnum,
        "PayoutOrder.OrderTypeEnum": PayoutOrder.OrderTypeEnum,
        "PayoutOrder.OrderCurrencyEnum": PayoutOrder.OrderCurrencyEnum,
        "PayoutOtherCharge.CurrencyEnum": PayoutOtherCharge.CurrencyEnum,
        "PayoutOtherCharge.ChargeTypeEnum": PayoutOtherCharge.ChargeTypeEnum,
        "PayoutRefund.OrderCurrencyEnum": PayoutRefund.OrderCurrencyEnum,
        "PayoutRefund.OrderTypeEnum": PayoutRefund.OrderTypeEnum,
        "PayoutSummary.PayoutStatusEnum": PayoutSummary.PayoutStatusEnum,
        "PayoutSummary.CurrencyEnum": PayoutSummary.CurrencyEnum,
        "PhoneCall.CallStatusEnum": PhoneCall.CallStatusEnum,
        "PreOrderConfig.PreOrderTimeDisplayTypeEnum": PreOrderConfig.PreOrderTimeDisplayTypeEnum,
        "ProcessingFeeConfig.PaymentAccountTypeEnum": ProcessingFeeConfig.PaymentAccountTypeEnum,
        "Range.DayOfWeekEnum": Range.DayOfWeekEnum,
        "RedeemInvitationResult.InvitationStatusEnum": RedeemInvitationResult.InvitationStatusEnum,
        "Reject.RejectReasonEnum": Reject.RejectReasonEnum,
        "SignupStep.ActionEnum": SignupStep.ActionEnum,
        "StatisticsCurrencyDataPoint.CurrencyEnum": StatisticsCurrencyDataPoint.CurrencyEnum,
        "Store.PrintoutLayoutTypeEnum": Store.PrintoutLayoutTypeEnum,
        "Store.CurrencyEnum": Store.CurrencyEnum,
        "StoreEndOfDayReport.CurrencyEnum": StoreEndOfDayReport.CurrencyEnum,
        "StoreGroup.CurrencyEnum": StoreGroup.CurrencyEnum,
        "StoreGroupBase.CurrencyEnum": StoreGroupBase.CurrencyEnum,
        "StoreGroupExtended.CurrencyEnum": StoreGroupExtended.CurrencyEnum,
        "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum": StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum,
        "StoreOrderCapacityConfig.DeliveryTypeEnum": StoreOrderCapacityConfig.DeliveryTypeEnum,
        "StoreOrderCapacityPeriod.DayOfTheWeekEnum": StoreOrderCapacityPeriod.DayOfTheWeekEnum,
        "StoreSummary.CurrencyEnum": StoreSummary.CurrencyEnum,
        "StripeAccountLinkRequest.CollectEnum": StripeAccountLinkRequest.CollectEnum,
        "StripeAccountLinkRequest.TypeEnum": StripeAccountLinkRequest.TypeEnum,
        "StripeConnectedAccount.CardPaymentsStatusEnum": StripeConnectedAccount.CardPaymentsStatusEnum,
        "StripeConnectedAccount.TransfersStatusEnum": StripeConnectedAccount.TransfersStatusEnum,
        "StripeConnectedAccount.AccountStatusEnum": StripeConnectedAccount.AccountStatusEnum,
        "StripeConnectedAccountInfo.AccountStatusEnum": StripeConnectedAccountInfo.AccountStatusEnum,
        "StripeConnectedAccountInfo.CardPaymentStatusEnum": StripeConnectedAccountInfo.CardPaymentStatusEnum,
        "StuartSettings.PackageTypeEnum": StuartSettings.PackageTypeEnum,
        "StuartSettings.TransportTypeEnum": StuartSettings.TransportTypeEnum,
        "SupportedCountry.AddressLayoutEnum": SupportedCountry.AddressLayoutEnum,
        "SupportedCountry.PostCodeTypeEnum": SupportedCountry.PostCodeTypeEnum,
        "SupportedCountry.SupportRegionEnum": SupportedCountry.SupportRegionEnum,
        "Teammate.InvitationStatusEnum": Teammate.InvitationStatusEnum,
        "Teammate.AppAccessLevelEnum": Teammate.AppAccessLevelEnum,
        "TeammateBase.AppAccessLevelEnum": TeammateBase.AppAccessLevelEnum,
        "Voucher.StatusEnum": Voucher.StatusEnum,
        "Voucher.VoucherTypeEnum": Voucher.VoucherTypeEnum,
        "Voucher.VoucherSubTypeEnum": Voucher.VoucherSubTypeEnum,
        "Voucher.CurrencyEnum": Voucher.CurrencyEnum,
        "VoucherSummary.StatusEnum": VoucherSummary.StatusEnum,
        "VoucherSummary.VoucherTypeEnum": VoucherSummary.VoucherTypeEnum,
        "VoucherSummary.VoucherSubTypeEnum": VoucherSummary.VoucherSubTypeEnum,
        "VoucherWithStats.StatusEnum": VoucherWithStats.StatusEnum,
        "VoucherWithStats.VoucherTypeEnum": VoucherWithStats.VoucherTypeEnum,
        "VoucherWithStats.VoucherSubTypeEnum": VoucherWithStats.VoucherSubTypeEnum,
        "VoucherWithStats.CurrencyEnum": VoucherWithStats.CurrencyEnum,
        "WebsiteImage.ImageLocationEnum": WebsiteImage.ImageLocationEnum,
}

let typeMap: {[index: string]: any} = {
    "Accept": Accept,
    "AccountDetail": AccountDetail,
    "AccountDetailBase": AccountDetailBase,
    "AccountFieldDefinition": AccountFieldDefinition,
    "AccountFieldKeyValuePair": AccountFieldKeyValuePair,
    "AccountFieldsDefinitions": AccountFieldsDefinitions,
    "AddItemDetails": AddItemDetails,
    "AllMetadataResult": AllMetadataResult,
    "AnalyticsClientEvent": AnalyticsClientEvent,
    "ApmCurrencyDataPoint": ApmCurrencyDataPoint,
    "ApmDataPoint": ApmDataPoint,
    "ApmHourlyDataPoint": ApmHourlyDataPoint,
    "ApmStatistics": ApmStatistics,
    "ApmStatus": ApmStatus,
    "App": App,
    "AppCompliance": AppCompliance,
    "AppConfigUpdateModel": AppConfigUpdateModel,
    "AppCreatedEvent": AppCreatedEvent,
    "AppUpdatedEvent": AppUpdatedEvent,
    "AssignedBankAccount": AssignedBankAccount,
    "BalanceDetails": BalanceDetails,
    "BankAccount": BankAccount,
    "BankAccountCreate": BankAccountCreate,
    "BankAccountCreatedEvent": BankAccountCreatedEvent,
    "BankAccountDeletedEvent": BankAccountDeletedEvent,
    "BankAccountDetail": BankAccountDetail,
    "BankAccountDetailsUpdateRequest": BankAccountDetailsUpdateRequest,
    "BankAccountSummary": BankAccountSummary,
    "BankAccountUpdatedEvent": BankAccountUpdatedEvent,
    "BluetoothTerminalStatus": BluetoothTerminalStatus,
    "BusinessHoursOverride": BusinessHoursOverride,
    "BusinessHoursOverrideBase": BusinessHoursOverrideBase,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "BusinessHoursPeriodBase": BusinessHoursPeriodBase,
    "CampaignStatistics": CampaignStatistics,
    "CertificateCreatedEvent": CertificateCreatedEvent,
    "CertificateRenewedEvent": CertificateRenewedEvent,
    "ChangePasswordModel": ChangePasswordModel,
    "ChargebackDetails": ChargebackDetails,
    "Coordinates": Coordinates,
    "CountryWithAccountFieldsDefinitions": CountryWithAccountFieldsDefinitions,
    "CreateAccountModel": CreateAccountModel,
    "CreateFullMenu": CreateFullMenu,
    "CreateFullMenuItemOptionSet": CreateFullMenuItemOptionSet,
    "CreateFullMenuItemOptionSetItem": CreateFullMenuItemOptionSetItem,
    "CreateFullMenuSection": CreateFullMenuSection,
    "CreateFullMenuSectionItem": CreateFullMenuSectionItem,
    "CreateMenuTaxRate": CreateMenuTaxRate,
    "CreateMetadata": CreateMetadata,
    "CreateTeammate": CreateTeammate,
    "CreateVoucher": CreateVoucher,
    "CreditNoteDetails": CreditNoteDetails,
    "CspReport": CspReport,
    "CspReportRequest": CspReportRequest,
    "CurrencyData": CurrencyData,
    "Customer": Customer,
    "CustomerConsentUpdatedEvent": CustomerConsentUpdatedEvent,
    "CustomerCreatedEvent": CustomerCreatedEvent,
    "CustomerDeliveryTrackingOrder": CustomerDeliveryTrackingOrder,
    "CustomerDeliveryTrackingOrderLine": CustomerDeliveryTrackingOrderLine,
    "CustomerSummary": CustomerSummary,
    "CustomerUpdateModel": CustomerUpdateModel,
    "CustomerUpdatedEvent": CustomerUpdatedEvent,
    "DeliveryLocation": DeliveryLocation,
    "DeliveryZone": DeliveryZone,
    "DeliveryZoneBase": DeliveryZoneBase,
    "DeliveryZoneCreatedEvent": DeliveryZoneCreatedEvent,
    "DeliveryZoneDeletedEvent": DeliveryZoneDeletedEvent,
    "DeliveryZoneUpdatedEvent": DeliveryZoneUpdatedEvent,
    "DeviceSettings": DeviceSettings,
    "DnsRecordInformation": DnsRecordInformation,
    "DnsVerifiedEvent": DnsVerifiedEvent,
    "Driver": Driver,
    "DriverInvitation": DriverInvitation,
    "DriverLoginModel": DriverLoginModel,
    "DriverRequestLoginPinModel": DriverRequestLoginPinModel,
    "DriverStore": DriverStore,
    "EmvNotificationEvent": EmvNotificationEvent,
    "EmvTerminal": EmvTerminal,
    "EmvTerminalWithAssignments": EmvTerminalWithAssignments,
    "EventSearchResult": EventSearchResult,
    "FeeSummary": FeeSummary,
    "FlipdishEventBase": FlipdishEventBase,
    "FlipdishFeesDetails": FlipdishFeesDetails,
    "GroupedCoordinates": GroupedCoordinates,
    "HomeAction": HomeAction,
    "HomeStatistics": HomeStatistics,
    "HttpRequestAndResponseLog": HttpRequestAndResponseLog,
    "HydraAssignedEvent": HydraAssignedEvent,
    "HydraConfig": HydraConfig,
    "HydraConnectionStatusChangedEvent": HydraConnectionStatusChangedEvent,
    "HydraDeviceDetails": HydraDeviceDetails,
    "HydraRegistrationRequest": HydraRegistrationRequest,
    "HydraRequestResetEvent": HydraRequestResetEvent,
    "HydraSettingChangedEvent": HydraSettingChangedEvent,
    "HydraStatus": HydraStatus,
    "HydraStoreAssignedEvent": HydraStoreAssignedEvent,
    "HydraStoreData": HydraStoreData,
    "HydraStoreUnassignedEvent": HydraStoreUnassignedEvent,
    "HydraUnAssignedEvent": HydraUnAssignedEvent,
    "IndexPage": IndexPage,
    "IndexPageBase": IndexPageBase,
    "JobAddress": JobAddress,
    "JobCancellation": JobCancellation,
    "JobContact": JobContact,
    "JobDelivery": JobDelivery,
    "JobDeliveryDetail": JobDeliveryDetail,
    "JobDriver": JobDriver,
    "JobEta": JobEta,
    "JobPricing": JobPricing,
    "JobProof": JobProof,
    "JobResponse": JobResponse,
    "KioskBluetoothInstallUpdateInitiateEvent": KioskBluetoothInstallUpdateInitiateEvent,
    "KioskBluetoothPairingModeEvent": KioskBluetoothPairingModeEvent,
    "KioskBluetoothTerminalCancelUpdateEvent": KioskBluetoothTerminalCancelUpdateEvent,
    "KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent": KioskBluetoothTerminalFirmwareUpdateStatusInfoReceivedEvent,
    "KioskBluetoothTerminalInitiateUpdateCheckEvent": KioskBluetoothTerminalInitiateUpdateCheckEvent,
    "KioskBluetoothTerminalInstallationStatusEvent": KioskBluetoothTerminalInstallationStatusEvent,
    "KioskBluetoothTerminalUpdatedEvent": KioskBluetoothTerminalUpdatedEvent,
    "KioskBluetoothUnpairingModeEvent": KioskBluetoothUnpairingModeEvent,
    "KioskCashPaymentSettings": KioskCashPaymentSettings,
    "Language": Language,
    "LightspeedSettings": LightspeedSettings,
    "LocalisedTimeZone": LocalisedTimeZone,
    "LoginModel": LoginModel,
    "LoginWithPinModel": LoginWithPinModel,
    "LoyaltyCampaign": LoyaltyCampaign,
    "LoyaltyCampaignBase": LoyaltyCampaignBase,
    "LoyaltyCampaignCreatedEvent": LoyaltyCampaignCreatedEvent,
    "LoyaltyCampaignDeletedEvent": LoyaltyCampaignDeletedEvent,
    "LoyaltyCampaignUpdatedEvent": LoyaltyCampaignUpdatedEvent,
    "LumpDiscountDetails": LumpDiscountDetails,
    "MaskedPhoneNumber": MaskedPhoneNumber,
    "Menu": Menu,
    "MenuBase": MenuBase,
    "MenuBulkEditEvent": MenuBulkEditEvent,
    "MenuCheckpoint": MenuCheckpoint,
    "MenuCheckpointCreatedEvent": MenuCheckpointCreatedEvent,
    "MenuCreatedEvent": MenuCreatedEvent,
    "MenuElementEditResponse": MenuElementEditResponse,
    "MenuElementHide": MenuElementHide,
    "MenuElementListItemResponse": MenuElementListItemResponse,
    "MenuElementListResponse": MenuElementListResponse,
    "MenuItemOptionSet": MenuItemOptionSet,
    "MenuItemOptionSetBase": MenuItemOptionSetBase,
    "MenuItemOptionSetCreatedEvent": MenuItemOptionSetCreatedEvent,
    "MenuItemOptionSetDeletedEvent": MenuItemOptionSetDeletedEvent,
    "MenuItemOptionSetItem": MenuItemOptionSetItem,
    "MenuItemOptionSetItemBase": MenuItemOptionSetItemBase,
    "MenuItemOptionSetItemCreatedEvent": MenuItemOptionSetItemCreatedEvent,
    "MenuItemOptionSetItemDeletedEvent": MenuItemOptionSetItemDeletedEvent,
    "MenuItemOptionSetItemUpdatedEvent": MenuItemOptionSetItemUpdatedEvent,
    "MenuItemOptionSetUpdatedEvent": MenuItemOptionSetUpdatedEvent,
    "MenuObjectDisplayOrders": MenuObjectDisplayOrders,
    "MenuSection": MenuSection,
    "MenuSectionAvailability": MenuSectionAvailability,
    "MenuSectionAvailabilityBase": MenuSectionAvailabilityBase,
    "MenuSectionBase": MenuSectionBase,
    "MenuSectionCreatedEvent": MenuSectionCreatedEvent,
    "MenuSectionDeletedEvent": MenuSectionDeletedEvent,
    "MenuSectionItem": MenuSectionItem,
    "MenuSectionItemBase": MenuSectionItemBase,
    "MenuSectionItemCreatedEvent": MenuSectionItemCreatedEvent,
    "MenuSectionItemDeletedEvent": MenuSectionItemDeletedEvent,
    "MenuSectionItemUpdatedEvent": MenuSectionItemUpdatedEvent,
    "MenuSectionUpdatedEvent": MenuSectionUpdatedEvent,
    "MenuStoreNames": MenuStoreNames,
    "MenuSummary": MenuSummary,
    "MenuTaxDetails": MenuTaxDetails,
    "MenuTaxRate": MenuTaxRate,
    "MenuUpdatedEvent": MenuUpdatedEvent,
    "MenuUploadedEvent": MenuUploadedEvent,
    "Metadata": Metadata,
    "OAuthApp": OAuthApp,
    "OAuthTokenModel": OAuthTokenModel,
    "OauthClientRedirectUri": OauthClientRedirectUri,
    "ObjectDisplayOrder": ObjectDisplayOrder,
    "Order": Order,
    "OrderAcceptedEvent": OrderAcceptedEvent,
    "OrderCapacityConfigUpdatedEvent": OrderCapacityConfigUpdatedEvent,
    "OrderCreatedEvent": OrderCreatedEvent,
    "OrderCustomerTrackingCreatedEvent": OrderCustomerTrackingCreatedEvent,
    "OrderDeliveryTrackingStatusUpdatedEvent": OrderDeliveryTrackingStatusUpdatedEvent,
    "OrderDispatchedEvent": OrderDispatchedEvent,
    "OrderIdAndSequenceNumber": OrderIdAndSequenceNumber,
    "OrderItem": OrderItem,
    "OrderItemOption": OrderItemOption,
    "OrderPaymentInformation": OrderPaymentInformation,
    "OrderRatingUpdatedEvent": OrderRatingUpdatedEvent,
    "OrderRefundedEvent": OrderRefundedEvent,
    "OrderRejectedEvent": OrderRejectedEvent,
    "OrderSummary": OrderSummary,
    "OrderTipUpdatedEvent": OrderTipUpdatedEvent,
    "OrderVoucherSummary": OrderVoucherSummary,
    "OtherChargesDetails": OtherChargesDetails,
    "PasswordResetModel": PasswordResetModel,
    "PaymentTerminalDetails": PaymentTerminalDetails,
    "PaymentTerminalTransactionDetails": PaymentTerminalTransactionDetails,
    "Payout": Payout,
    "PayoutChargeback": PayoutChargeback,
    "PayoutDetail": PayoutDetail,
    "PayoutOrder": PayoutOrder,
    "PayoutOtherCharge": PayoutOtherCharge,
    "PayoutRefund": PayoutRefund,
    "PayoutStore": PayoutStore,
    "PayoutSummary": PayoutSummary,
    "PercentDiscountDetails": PercentDiscountDetails,
    "PhoneCall": PhoneCall,
    "PhoneCallEndedEvent": PhoneCallEndedEvent,
    "PhoneCallStartedEvent": PhoneCallStartedEvent,
    "PreOrderConfig": PreOrderConfig,
    "PreOrderTime": PreOrderTime,
    "PredefinedAnswer": PredefinedAnswer,
    "Printer": Printer,
    "PrinterAssignedToStoreEvent": PrinterAssignedToStoreEvent,
    "PrinterTurnedOffEvent": PrinterTurnedOffEvent,
    "PrinterTurnedOnEvent": PrinterTurnedOnEvent,
    "PrinterUnassignedFromStoreEvent": PrinterUnassignedFromStoreEvent,
    "ProcessingFeeConfig": ProcessingFeeConfig,
    "PushNotificationDeletedEvent": PushNotificationDeletedEvent,
    "PushNotificationRequest": PushNotificationRequest,
    "PushNotificationResponse": PushNotificationResponse,
    "PushNotificationScheduledEvent": PushNotificationScheduledEvent,
    "PushNotificationSentEvent": PushNotificationSentEvent,
    "Range": Range,
    "RedeemInvitationResult": RedeemInvitationResult,
    "Refund": Refund,
    "Reject": Reject,
    "RequestLoginPinModel": RequestLoginPinModel,
    "RequestLoginPinResposne": RequestLoginPinResposne,
    "RequestPasswordResetModel": RequestPasswordResetModel,
    "RestApiArrayResultAllMetadataResult": RestApiArrayResultAllMetadataResult,
    "RestApiArrayResultApmCurrencyDataPoint": RestApiArrayResultApmCurrencyDataPoint,
    "RestApiArrayResultApmDataPoint": RestApiArrayResultApmDataPoint,
    "RestApiArrayResultApmHourlyDataPoint": RestApiArrayResultApmHourlyDataPoint,
    "RestApiArrayResultBankAccountSummary": RestApiArrayResultBankAccountSummary,
    "RestApiArrayResultBusinessHoursPeriod": RestApiArrayResultBusinessHoursPeriod,
    "RestApiArrayResultCountryWithAccountFieldsDefinitions": RestApiArrayResultCountryWithAccountFieldsDefinitions,
    "RestApiArrayResultDeliveryZone": RestApiArrayResultDeliveryZone,
    "RestApiArrayResultDriver": RestApiArrayResultDriver,
    "RestApiArrayResultDriverStore": RestApiArrayResultDriverStore,
    "RestApiArrayResultEmvTerminalWithAssignments": RestApiArrayResultEmvTerminalWithAssignments,
    "RestApiArrayResultHomeAction": RestApiArrayResultHomeAction,
    "RestApiArrayResultKioskCashPaymentSettings": RestApiArrayResultKioskCashPaymentSettings,
    "RestApiArrayResultLocalisedTimeZone": RestApiArrayResultLocalisedTimeZone,
    "RestApiArrayResultLoyaltyCampaign": RestApiArrayResultLoyaltyCampaign,
    "RestApiArrayResultMenuCheckpoint": RestApiArrayResultMenuCheckpoint,
    "RestApiArrayResultMenuElementEditResponse": RestApiArrayResultMenuElementEditResponse,
    "RestApiArrayResultMenuElementListResponse": RestApiArrayResultMenuElementListResponse,
    "RestApiArrayResultMenuItemOptionSet": RestApiArrayResultMenuItemOptionSet,
    "RestApiArrayResultMenuItemOptionSetItem": RestApiArrayResultMenuItemOptionSetItem,
    "RestApiArrayResultMenuSection": RestApiArrayResultMenuSection,
    "RestApiArrayResultMenuSectionItem": RestApiArrayResultMenuSectionItem,
    "RestApiArrayResultMenuStoreNames": RestApiArrayResultMenuStoreNames,
    "RestApiArrayResultMenuSummary": RestApiArrayResultMenuSummary,
    "RestApiArrayResultMenuTaxDetails": RestApiArrayResultMenuTaxDetails,
    "RestApiArrayResultMetadata": RestApiArrayResultMetadata,
    "RestApiArrayResultOAuthApp": RestApiArrayResultOAuthApp,
    "RestApiArrayResultOauthClientRedirectUri": RestApiArrayResultOauthClientRedirectUri,
    "RestApiArrayResultPayoutSummary": RestApiArrayResultPayoutSummary,
    "RestApiArrayResultPreOrderTime": RestApiArrayResultPreOrderTime,
    "RestApiArrayResultProcessingFeeConfig": RestApiArrayResultProcessingFeeConfig,
    "RestApiArrayResultRestApiDefaultResponse": RestApiArrayResultRestApiDefaultResponse,
    "RestApiArrayResultRetentionCampaign": RestApiArrayResultRetentionCampaign,
    "RestApiArrayResultStoreListItem": RestApiArrayResultStoreListItem,
    "RestApiArrayResultStoreStatistics": RestApiArrayResultStoreStatistics,
    "RestApiArrayResultSupportedCountry": RestApiArrayResultSupportedCountry,
    "RestApiArrayResultTeammate": RestApiArrayResultTeammate,
    "RestApiArrayResultVoucherDataPoint": RestApiArrayResultVoucherDataPoint,
    "RestApiDefaultResponse": RestApiDefaultResponse,
    "RestApiErrorResult": RestApiErrorResult,
    "RestApiEventSearchPaginationResult": RestApiEventSearchPaginationResult,
    "RestApiForbiddenResult": RestApiForbiddenResult,
    "RestApiIntegerResult": RestApiIntegerResult,
    "RestApiPaginationResultApp": RestApiPaginationResultApp,
    "RestApiPaginationResultBusinessHoursOverride": RestApiPaginationResultBusinessHoursOverride,
    "RestApiPaginationResultHttpRequestAndResponseLog": RestApiPaginationResultHttpRequestAndResponseLog,
    "RestApiPaginationResultHydraDeviceDetails": RestApiPaginationResultHydraDeviceDetails,
    "RestApiPaginationResultOAuthTokenModel": RestApiPaginationResultOAuthTokenModel,
    "RestApiPaginationResultOrder": RestApiPaginationResultOrder,
    "RestApiPaginationResultOrderSummary": RestApiPaginationResultOrderSummary,
    "RestApiPaginationResultPayout": RestApiPaginationResultPayout,
    "RestApiPaginationResultPayoutChargeback": RestApiPaginationResultPayoutChargeback,
    "RestApiPaginationResultPayoutOrder": RestApiPaginationResultPayoutOrder,
    "RestApiPaginationResultPayoutOtherCharge": RestApiPaginationResultPayoutOtherCharge,
    "RestApiPaginationResultPayoutRefund": RestApiPaginationResultPayoutRefund,
    "RestApiPaginationResultPhoneCall": RestApiPaginationResultPhoneCall,
    "RestApiPaginationResultPushNotificationResponse": RestApiPaginationResultPushNotificationResponse,
    "RestApiPaginationResultStore": RestApiPaginationResultStore,
    "RestApiPaginationResultStoreGroup": RestApiPaginationResultStoreGroup,
    "RestApiPaginationResultStoreGroupExtended": RestApiPaginationResultStoreGroupExtended,
    "RestApiPaginationResultStoreHeader": RestApiPaginationResultStoreHeader,
    "RestApiPaginationResultVoucherSummary": RestApiPaginationResultVoucherSummary,
    "RestApiPaginationResultWebhookLog": RestApiPaginationResultWebhookLog,
    "RestApiPaginationResultWebhookSubscription": RestApiPaginationResultWebhookSubscription,
    "RestApiResultAccountDetail": RestApiResultAccountDetail,
    "RestApiResultAccountFieldsDefinitions": RestApiResultAccountFieldsDefinitions,
    "RestApiResultApmStatistics": RestApiResultApmStatistics,
    "RestApiResultApmStatus": RestApiResultApmStatus,
    "RestApiResultApp": RestApiResultApp,
    "RestApiResultAppCompliance": RestApiResultAppCompliance,
    "RestApiResultAssignedBankAccount": RestApiResultAssignedBankAccount,
    "RestApiResultBankAccountDetail": RestApiResultBankAccountDetail,
    "RestApiResultBluetoothTerminalStatus": RestApiResultBluetoothTerminalStatus,
    "RestApiResultBusinessHoursOverride": RestApiResultBusinessHoursOverride,
    "RestApiResultBusinessHoursPeriod": RestApiResultBusinessHoursPeriod,
    "RestApiResultCoordinates": RestApiResultCoordinates,
    "RestApiResultCustomer": RestApiResultCustomer,
    "RestApiResultDeliveryZone": RestApiResultDeliveryZone,
    "RestApiResultDnsRecordInformation": RestApiResultDnsRecordInformation,
    "RestApiResultDriver": RestApiResultDriver,
    "RestApiResultHomeStatistics": RestApiResultHomeStatistics,
    "RestApiResultHydraConfig": RestApiResultHydraConfig,
    "RestApiResultHydraStatus": RestApiResultHydraStatus,
    "RestApiResultIndexPage": RestApiResultIndexPage,
    "RestApiResultIndexPageBase": RestApiResultIndexPageBase,
    "RestApiResultJobResponse": RestApiResultJobResponse,
    "RestApiResultLightspeedSettings": RestApiResultLightspeedSettings,
    "RestApiResultLoyaltyCampaign": RestApiResultLoyaltyCampaign,
    "RestApiResultMenu": RestApiResultMenu,
    "RestApiResultMenuItemOptionSet": RestApiResultMenuItemOptionSet,
    "RestApiResultMenuItemOptionSetItem": RestApiResultMenuItemOptionSetItem,
    "RestApiResultMenuSection": RestApiResultMenuSection,
    "RestApiResultMenuSectionAvailability": RestApiResultMenuSectionAvailability,
    "RestApiResultMenuSectionItem": RestApiResultMenuSectionItem,
    "RestApiResultMetadata": RestApiResultMetadata,
    "RestApiResultOAuthApp": RestApiResultOAuthApp,
    "RestApiResultOauthClientRedirectUri": RestApiResultOauthClientRedirectUri,
    "RestApiResultOrder": RestApiResultOrder,
    "RestApiResultOrderPaymentInformation": RestApiResultOrderPaymentInformation,
    "RestApiResultPaymentTerminalDetails": RestApiResultPaymentTerminalDetails,
    "RestApiResultPaymentTerminalTransactionDetails": RestApiResultPaymentTerminalTransactionDetails,
    "RestApiResultPreOrderConfig": RestApiResultPreOrderConfig,
    "RestApiResultProcessingFeeConfig": RestApiResultProcessingFeeConfig,
    "RestApiResultPushNotificationResponse": RestApiResultPushNotificationResponse,
    "RestApiResultRedeemInvitationResult": RestApiResultRedeemInvitationResult,
    "RestApiResultRetentionCampaign": RestApiResultRetentionCampaign,
    "RestApiResultStore": RestApiResultStore,
    "RestApiResultStoreAddress": RestApiResultStoreAddress,
    "RestApiResultStoreEndOfDayReport": RestApiResultStoreEndOfDayReport,
    "RestApiResultStoreGroup": RestApiResultStoreGroup,
    "RestApiResultStoreGroupBase": RestApiResultStoreGroupBase,
    "RestApiResultStoreOrderCapacityConfig": RestApiResultStoreOrderCapacityConfig,
    "RestApiResultStripeConnectedAccount": RestApiResultStripeConnectedAccount,
    "RestApiResultStripeTerminalPrivateKey": RestApiResultStripeTerminalPrivateKey,
    "RestApiResultStuartSettings": RestApiResultStuartSettings,
    "RestApiResultTeammate": RestApiResultTeammate,
    "RestApiResultVoucherWithStats": RestApiResultVoucherWithStats,
    "RestApiResultWebsiteImage": RestApiResultWebsiteImage,
    "RestApiResultWebsiteTestimonial": RestApiResultWebsiteTestimonial,
    "RestApiStringArrayResult": RestApiStringArrayResult,
    "RestApiStringResult": RestApiStringResult,
    "RestApiUnauthorizedResult": RestApiUnauthorizedResult,
    "RetentionCampaign": RetentionCampaign,
    "RetentionCampaignBase": RetentionCampaignBase,
    "RetentionCampaignCreatedEvent": RetentionCampaignCreatedEvent,
    "RetentionCampaignDeletedEvent": RetentionCampaignDeletedEvent,
    "RetentionCampaignUpdatedEvent": RetentionCampaignUpdatedEvent,
    "RevenueAdjustmentsDetails": RevenueAdjustmentsDetails,
    "RevenueDetail": RevenueDetail,
    "SearchCriteria": SearchCriteria,
    "SetPasswordWithPinModel": SetPasswordWithPinModel,
    "SignupStep": SignupStep,
    "SmsInfo": SmsInfo,
    "SmsReceivedEvent": SmsReceivedEvent,
    "StatisticsCurrencyDataPoint": StatisticsCurrencyDataPoint,
    "Store": Store,
    "StoreAddress": StoreAddress,
    "StoreAddressBase": StoreAddressBase,
    "StoreAddressUpdatedEvent": StoreAddressUpdatedEvent,
    "StoreArchivedEvent": StoreArchivedEvent,
    "StoreBase": StoreBase,
    "StoreBusinessHoursOverrideCreatedEvent": StoreBusinessHoursOverrideCreatedEvent,
    "StoreBusinessHoursOverrideDeletedEvent": StoreBusinessHoursOverrideDeletedEvent,
    "StoreCampaignStartTime": StoreCampaignStartTime,
    "StoreCloneSettings": StoreCloneSettings,
    "StoreCreateBase": StoreCreateBase,
    "StoreCreatedEvent": StoreCreatedEvent,
    "StoreDataPoint": StoreDataPoint,
    "StoreDeletedEvent": StoreDeletedEvent,
    "StoreEndOfDayReport": StoreEndOfDayReport,
    "StoreGroup": StoreGroup,
    "StoreGroupBase": StoreGroupBase,
    "StoreGroupCreatedEvent": StoreGroupCreatedEvent,
    "StoreGroupDeletedEvent": StoreGroupDeletedEvent,
    "StoreGroupExtended": StoreGroupExtended,
    "StoreGroupUpdatedEvent": StoreGroupUpdatedEvent,
    "StoreHeader": StoreHeader,
    "StoreKioskSetting": StoreKioskSetting,
    "StoreKioskSettingUpdatedEvent": StoreKioskSettingUpdatedEvent,
    "StoreListItem": StoreListItem,
    "StoreLogoCreatedEvent": StoreLogoCreatedEvent,
    "StoreLogoDeletedEvent": StoreLogoDeletedEvent,
    "StoreLogoUpdatedEvent": StoreLogoUpdatedEvent,
    "StoreMenuAssignedEvent": StoreMenuAssignedEvent,
    "StoreNote": StoreNote,
    "StoreOpeningHoursUpdatedEvent": StoreOpeningHoursUpdatedEvent,
    "StoreOrderCapacityConfig": StoreOrderCapacityConfig,
    "StoreOrderCapacityConfigEditModel": StoreOrderCapacityConfigEditModel,
    "StoreOrderCapacityPeriod": StoreOrderCapacityPeriod,
    "StorePreOrderConfigUpdatedEvent": StorePreOrderConfigUpdatedEvent,
    "StorePublishedEvent": StorePublishedEvent,
    "StoreStatistics": StoreStatistics,
    "StoreSummary": StoreSummary,
    "StoreUnarchivedEvent": StoreUnarchivedEvent,
    "StoreUnpublishedEvent": StoreUnpublishedEvent,
    "StoreUpdatedEvent": StoreUpdatedEvent,
    "StripeAccountLinkRequest": StripeAccountLinkRequest,
    "StripeConnectedAccount": StripeConnectedAccount,
    "StripeConnectedAccountInfo": StripeConnectedAccountInfo,
    "StripeTerminalPrivateKey": StripeTerminalPrivateKey,
    "StuartSettings": StuartSettings,
    "StuartSettingsTransportPrices": StuartSettingsTransportPrices,
    "SupportedCountry": SupportedCountry,
    "Teammate": Teammate,
    "TeammateBase": TeammateBase,
    "TeammateDeletedEvent": TeammateDeletedEvent,
    "TeammateInviteAcceptedEvent": TeammateInviteAcceptedEvent,
    "TeammateInviteSentEvent": TeammateInviteSentEvent,
    "TeammateUpdatedEvent": TeammateUpdatedEvent,
    "UpdateDriverNotificationToken": UpdateDriverNotificationToken,
    "UpdateDriverProfileModel": UpdateDriverProfileModel,
    "UserAnsweredSignupQuestionsEvent": UserAnsweredSignupQuestionsEvent,
    "UserCreatedEvent": UserCreatedEvent,
    "UserDeletedEvent": UserDeletedEvent,
    "UserEventInfo": UserEventInfo,
    "UserLoginEvent": UserLoginEvent,
    "UserPasswordCreatedEvent": UserPasswordCreatedEvent,
    "UserUpdatedEvent": UserUpdatedEvent,
    "ValidationErrorResult": ValidationErrorResult,
    "Voucher": Voucher,
    "VoucherBase": VoucherBase,
    "VoucherCreatedEvent": VoucherCreatedEvent,
    "VoucherDataPoint": VoucherDataPoint,
    "VoucherDeletedEvent": VoucherDeletedEvent,
    "VoucherSummary": VoucherSummary,
    "VoucherUpdatedEvent": VoucherUpdatedEvent,
    "VoucherWithStats": VoucherWithStats,
    "WebhookEventSample": WebhookEventSample,
    "WebhookLog": WebhookLog,
    "WebhookSubscription": WebhookSubscription,
    "WebhookSubscriptionCreatedEvent": WebhookSubscriptionCreatedEvent,
    "WebhookSubscriptionDeletedEvent": WebhookSubscriptionDeletedEvent,
    "WebhookSubscriptionEventInfo": WebhookSubscriptionEventInfo,
    "WebhookSubscriptionUpdatedEvent": WebhookSubscriptionUpdatedEvent,
    "WebsiteImage": WebsiteImage,
    "WebsiteTestimonial": WebsiteTestimonial,
    "WebsiteTestimonialBase": WebsiteTestimonialBase,
    "WebsiteUpdatedEvent": WebsiteUpdatedEvent,
    "WebsiteVanityUrlUpdatedEvent": WebsiteVanityUrlUpdatedEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Answer a signup question
     * @param signupStepAction Signup step action
     * @param answerId Identifier of the answer
     * @param {*} [options] Override http request options.
     */
    public answerSignUpQuestion (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', answerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerId, "number")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePassword (changePasswordModel: ChangePasswordModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "ChangePasswordModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePasswordWithPin (changePasswordModel: SetPasswordWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "SetPasswordWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create account with email address and store name
     * @param createAccountModel Create account model
     * @param {*} [options] Override http request options.
     */
    public createAccount (createAccountModel: CreateAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAccountModel, "CreateAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current account detail
     * @param {*} [options] Override http request options.
     */
    public getAccountDetails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get timezones localised to users language
     * @param {*} [options] Override http request options.
     */
    public getLocalisedTimeZones (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocalisedTimeZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public login (loginModel: LoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public loginWithPin (loginModel: LoginWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log out. It removes Flipdish authorization Cookie.
     * @param {*} [options] Override http request options.
     */
    public logout (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset password with token.
     * @param passwordResetModel Password reset model
     * @param {*} [options] Override http request options.
     */
    public passwordResetWithToken (passwordResetModel: PasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordResetModel, "PasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request login PIN. The server sends the PIN to the email address.
     * @param requestLoginPinRequest Request login PIN request
     * @param {*} [options] Override http request options.
     */
    public requestLoginPin (requestLoginPinRequest: RequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestLoginPinRequest, "RequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestLoginPinResposne");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request password reset. Flipdish system will send a token via email.
     * @param requestPasswordResetModel Request password reset model
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (requestPasswordResetModel: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetModel, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Skip a signup question
     * @param signupStepAction Signup step action
     * @param {*} [options] Override http request options.
     */
    public skipSignupStep (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update account with name and language
     * @param updateAccountModel Update account model
     * @param {*} [options] Override http request options.
     */
    public updateAccount (updateAccountModel: AccountDetailBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAccountModel, "AccountDetailBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        (this.authentications as any)[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Returns true if APM is enabled on at least one store in an application
     * @param appId App Id
     * @param {*} [options] Override http request options.
     */
    public getApmStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApmStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Basic Statistics
     * @param appId App Id
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calendar statistics
     * @param appId App Id
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmHourlyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calls Statistics
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCallsStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Order Statistics (Value of Orders)
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getOrderStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmCurrencyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get paginated APM call list
     * @param appId App Id
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPhoneCall");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        (this.authentications as any)[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get the application configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A domain might be ready but still need 10 minutes to work properly because of HAProxy.
     * @summary Get the application hostname DNS delegation states for A and CNAME records.
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getAppHostnameStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostnamestatus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppHostnameStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDnsRecordInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Apps
     * @param nameFilter 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getApps (nameFilter?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (nameFilter !== undefined) {
            localVarQueryParameters['nameFilter'] = ObjectSerializer.serialize(nameFilter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the application compliance configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getCompliance (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCompliance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get panacea vanity url. This sets the URL which the Panacea website is available at. ie. my.flipdish.com/[vanityurl]
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getPanaceaVanityUrl (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPanaceaVanityUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all supported countries.
     * @param {*} [options] Override http request options.
     */
    public getSupportedCountries (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/supportedcountries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultSupportedCountry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Is panacea vanity url available
     * @param vanityUrl Vanity url to check
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public isPanaceaVanityUrlAvailable (vanityUrl: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url/available'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application configuration
     * @param appId Application identifier
     * @param appConfigUpdate Changes to the configuration
     * @param {*} [options] Override http request options.
     */
    public setAppConfig (appId: string, appConfigUpdate: AppConfigUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppConfig.');
        }

        // verify required parameter 'appConfigUpdate' is not null or undefined
        if (appConfigUpdate === null || appConfigUpdate === undefined) {
            throw new Error('Required parameter appConfigUpdate was null or undefined when calling setAppConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appConfigUpdate, "AppConfigUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no subdomain is specified in {hostname} 'www' will be prepended.
     * @summary Set the application hostname.
     * @param appId Application identifier.
     * @param hostname The new Hostname.
     * @param isEmbed Will the website be embedded
     * @param {*} [options] Override http request options.
     */
    public setAppHostname (appId: string, hostname: string, isEmbed?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostname'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppHostname.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling setAppHostname.');
        }

        if (hostname !== undefined) {
            localVarQueryParameters['hostname'] = ObjectSerializer.serialize(hostname, "string");
        }

        if (isEmbed !== undefined) {
            localVarQueryParameters['isEmbed'] = ObjectSerializer.serialize(isEmbed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application languages
     * @param appId Application identifier
     * @param languages New list of languages
     * @param {*} [options] Override http request options.
     */
    public setAppLanguages (appId: string, languages: Array<Language>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config/languages'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppLanguages.');
        }

        // verify required parameter 'languages' is not null or undefined
        if (languages === null || languages === undefined) {
            throw new Error('Required parameter languages was null or undefined when calling setAppLanguages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(languages, "Array<Language>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application compliance configuration
     * @param appId Application identifier
     * @param complianceType Compliance type
     * @param {*} [options] Override http request options.
     */
    public setCompliance (appId: string, complianceType: 'Default' | 'GdprCompliance', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setCompliance.');
        }

        // verify required parameter 'complianceType' is not null or undefined
        if (complianceType === null || complianceType === undefined) {
            throw new Error('Required parameter complianceType was null or undefined when calling setCompliance.');
        }

        if (complianceType !== undefined) {
            localVarQueryParameters['complianceType'] = ObjectSerializer.serialize(complianceType, "'Default' | 'GdprCompliance'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Set panacea vanity url
     * @param appId Application identifier.
     * @param vanityUrl Vanity url
     * @param {*} [options] Override http request options.
     */
    public setPanaceaVanityUrl (appId: string, vanityUrl: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setPanaceaVanityUrl.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling setPanaceaVanityUrl.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application logo \\ icon
     * @param appId Application identifier
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppLogo (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/logo'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get authorization tokens
     * @param oauthAppId Client identifier
     * @param appId 
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOAuthTokenModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke token
     * @param key Token identifier key
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public revokeToken (key: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Attach Bank Account to Store
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param storeId Store to be attached to Bank account
     * @param {*} [options] Override http request options.
     */
    public attachBankAccountToStore (appId: string, bankAccountId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Bank Account and attach to this App
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete BankAccount
     * @param appId App Name
     * @param bankAccountId Id of account to be marked as deleted
     * @param {*} [options] Override http request options.
     */
    public deleteBankAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling deleteBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get BankAccount Detail by Id
     * @param bankAccountId Id of account
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccountById (bankAccountId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getBankAccountById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get List of BankAccounts for WL
     * @param appId App Name
     * @param {*} [options] Override http request options.
     */
    public getBankAccounts (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBankAccountSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get bank account fields definitions
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCountriesWithFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/countries-field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCountriesWithFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultCountryWithAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get bank account fields definitions
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update BankAccount
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param account Details to update account with
     * @param {*} [options] Override http request options.
     */
    public updateBankAccount (appId: string, bankAccountId: number, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update State of Bank Account
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param state New state
     * @param reason Reason for state change, Mandatory for rejections
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountState (appId: string, bankAccountId: number, state: string, reason: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/state/{state}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling updateBankAccountState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reason, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates loyalty campaign
     * @param appId App Name Id
     * @param campaign Loyalty campaign details
     * @param {*} [options] Override http request options.
     */
    public createLoyaltyCampaign (appId: string, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates retention campaign
     * @param appId App Name Id
     * @param campaign Retention campaign details
     * @param {*} [options] Override http request options.
     */
    public createRetentionCampaign (appId: string, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets loyalty campaigns for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets loyalty campaigns for store
     * @param appId App Name Id
     * @param storeId Store Id
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets retention campaigns for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets retention campaigns for store
     * @param appId App Name Id
     * @param storeId Store Id
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets list of stores for app
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getStoreList (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreListItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a campaign
     * @param appId App Name Id
     * @param campaignId Campaign Id
     * @param {*} [options] Override http request options.
     */
    public removeCampaign (appId: string, campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates loyalty campaign
     * @param appId App Name Id
     * @param campaignId Loyalty campaign Id
     * @param campaign Loyalty campaign details
     * @param {*} [options] Override http request options.
     */
    public updateLoyaltyCampaign (appId: string, campaignId: number, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates retention campaign
     * @param appId App Name Id
     * @param campaignId Retention campaign Id
     * @param campaign Retention campaign details
     * @param {*} [options] Override http request options.
     */
    public updateRetentionCampaign (appId: string, campaignId: number, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardReadersApiApiKeys {
}

export class CardReadersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardReadersApiApiKeys, value: string) {
        (this.authentications as any)[CardReadersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Authorization Key for Stripe Terminal
     * @param {*} [options] Override http request options.
     */
    public authorizeStripeTerminal (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }> {
        const localVarPath = this.basePath + '/api/v1.0/cardreaders/authorize/stripe';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalPrivateKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Authorization Key for Stripe Terminal
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public authorizeStripeTerminal_1 (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/authorize'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling authorizeStripeTerminal_1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalPrivateKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Cancel currently initiated install update for bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public cancelCurrentlyInitiatedBluetoothDeviceUpdate (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/cancelUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the status of the bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getBluetoothTerminalStatus (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBluetoothTerminalStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Trigger check for Bluetooth device update on Kiosk
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateBluetoothTerminalDeviceUpdateCheck (appId: string, deviceId: string, terminalType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/checkForUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Initiate stripe terminal pairing mode
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothPairingMode (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/pair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Initiate Kiosk Update Install for bluetooth terminal
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothUpdateInstall (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/installUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Unpair the currently paired stripe terminal
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unpairCurrentlyPairedBluetoothDevice (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/unpair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentSecurityPolicyApiApiKeys {
}

export class ContentSecurityPolicyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentSecurityPolicyApiApiKeys, value: string) {
        (this.authentications as any)[ContentSecurityPolicyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public contentSecurityPolicyReport (request: CspReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/csp/report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling contentSecurityPolicyReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CspReportRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomersApiApiKeys {
}

export class CustomersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomersApiApiKeys, value: string) {
        (this.authentications as any)[CustomersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer of an app by Id
     * @param appId App Name Id
     * @param customerId Customer Id
     * @param {*} [options] Override http request options.
     */
    public getCustomerById (appId: string, customerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update customer of an app by Id
     * @param appId App Name Id
     * @param customerId Customer Id
     * @param updateCustomer Updated customer information
     * @param {*} [options] Override http request options.
     */
    public updateCustomerById (appId: string, customerId: number, updateCustomer: CustomerUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'updateCustomer' is not null or undefined
        if (updateCustomer === null || updateCustomer === undefined) {
            throw new Error('Required parameter updateCustomer was null or undefined when calling updateCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCustomer, "CustomerUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryTrackingApiApiKeys {
}

export class DeliveryTrackingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryTrackingApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryTrackingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Assign driver to order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrder (appId: string, orderId: number, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders/{orderId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign driver to multiple orders
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param orderIdAndSequenceNumbers Array of object containing OrderId and Sequence
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrders (appId: string, driverId: number, orderIdAndSequenceNumbers: Array<OrderIdAndSequenceNumber>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'orderIdAndSequenceNumbers' is not null or undefined
        if (orderIdAndSequenceNumbers === null || orderIdAndSequenceNumbers === undefined) {
            throw new Error('Required parameter orderIdAndSequenceNumbers was null or undefined when calling assignDriverToOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderIdAndSequenceNumbers, "Array<OrderIdAndSequenceNumber>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Get drivers by App
     * @param appId Application identifier
     * @param name Driver&#39;s username
     * @param phoneNumber Driver&#39;s phone number
     * @param storeId Store Id
     * @param presence Offline/Online
     * @param {*} [options] Override http request options.
     */
    public getDrivers (appId: string, name?: string, phoneNumber?: string, storeId?: number, presence?: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getDrivers.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (presence !== undefined) {
            localVarQueryParameters['presence'] = ObjectSerializer.serialize(presence, "'Offline' | 'Online'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Invite driver
     * @param appId Application identifier
     * @param driverInvitation Driver invitation model
     * @param {*} [options] Override http request options.
     */
    public inviteDriverToApp (appId: string, driverInvitation: DriverInvitation, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling inviteDriverToApp.');
        }

        // verify required parameter 'driverInvitation' is not null or undefined
        if (driverInvitation === null || driverInvitation === undefined) {
            throw new Error('Required parameter driverInvitation was null or undefined when calling inviteDriverToApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverInvitation, "DriverInvitation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from app
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public removeDriverFromApp (appId: string, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeDriverFromApp.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling removeDriverFromApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param {*} [options] Override http request options.
     */
    public unassignDriverFromOrder (appId: string, orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/{orderId}/driver'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignDriverFromOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling unassignDriverFromOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a delivery zone to the store id
     * @param storeId Store Id to which the delivery zone will be added
     * @param deliveryZoneBase Optional delivery zone, if not supplied will create a default zone
     * @param {*} [options] Override http request options.
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZoneBase, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the delivery zones associated with a store
     * @param storeId Store Id to which the delivery zones are associated
     * @param {*} [options] Override http request options.
     */
    public getDeliveryZones (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be removed
     * @param {*} [options] Override http request options.
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be updated
     * @param deliveryZone Delta of delivery zone parameters that need to be changed
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZone, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DriversApiApiKeys {
}

export class DriversApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DriversApiApiKeys, value: string) {
        (this.authentications as any)[DriversApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add driver token
     * @param updateDriverToken 
     * @param {*} [options] Override http request options.
     */
    public addDriverNotificationToken (updateDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverToken' is not null or undefined
        if (updateDriverToken === null || updateDriverToken === undefined) {
            throw new Error('Required parameter updateDriverToken was null or undefined when calling addDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver profile image
     * @param {*} [options] Override http request options.
     */
    public deleteDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Login with phone number and pin
     * @param driverLoginModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverLogin (driverLoginModel: DriverLoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverLoginModel' is not null or undefined
        if (driverLoginModel === null || driverLoginModel === undefined) {
            throw new Error('Required parameter driverLoginModel was null or undefined when calling driverLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverLoginModel, "DriverLoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Request an SMS to be sent to the driver with their login code
     * @param driverRequestLoginPinModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverRequestLoginCodeSms (driverRequestLoginPinModel: DriverRequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverRequestLoginPinModel' is not null or undefined
        if (driverRequestLoginPinModel === null || driverRequestLoginPinModel === undefined) {
            throw new Error('Required parameter driverRequestLoginPinModel was null or undefined when calling driverRequestLoginCodeSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverRequestLoginPinModel, "DriverRequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get driver profile
     * @param {*} [options] Override http request options.
     */
    public getDriverProfile (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDriver");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores for driver
     * @param {*} [options] Override http request options.
     */
    public getStoresForDriver (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/assignedstores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDriverStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver token
     * @param removeDriverToken 
     * @param {*} [options] Override http request options.
     */
    public removeDriverNotificationToken (removeDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'removeDriverToken' is not null or undefined
        if (removeDriverToken === null || removeDriverToken === undefined) {
            throw new Error('Required parameter removeDriverToken was null or undefined when calling removeDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param presence 
     * @param {*} [options] Override http request options.
     */
    public setDriverPresenceForStore (storeId: number, presence: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/stores/{storeId}/presence/{presence}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'presence' + '}', encodeURIComponent(String(presence)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setDriverPresenceForStore.');
        }

        // verify required parameter 'presence' is not null or undefined
        if (presence === null || presence === undefined) {
            throw new Error('Required parameter presence was null or undefined when calling setDriverPresenceForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set driver profile image and returns it's url
     * @param {*} [options] Override http request options.
     */
    public setDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ...
     * @summary Change delivery tracking status and return the updated status.
     * @param orderId Order identifier
     * @param deliveryTrackingStatus 
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryTrackingStatus (orderId: number, deliveryTrackingStatus: 'Unassigned' | 'Unaccepted' | 'Accepted' | 'Carrying' | 'OnTheWay' | 'ArrivedAtLocation' | 'Delivered' | 'CannotDeliver', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/tracking/{deliveryTrackingStatus}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'deliveryTrackingStatus' + '}', encodeURIComponent(String(deliveryTrackingStatus)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        // verify required parameter 'deliveryTrackingStatus' is not null or undefined
        if (deliveryTrackingStatus === null || deliveryTrackingStatus === undefined) {
            throw new Error('Required parameter deliveryTrackingStatus was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update driver profile
     * @param updateDriverProfile Update the driver profile (i.e Name)
     * @param {*} [options] Override http request options.
     */
    public updateDriverProfile (updateDriverProfile: UpdateDriverProfileModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverProfile' is not null or undefined
        if (updateDriverProfile === null || updateDriverProfile === undefined) {
            throw new Error('Required parameter updateDriverProfile was null or undefined when calling updateDriverProfile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverProfile, "UpdateDriverProfileModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer events  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events  For technical reasons, the number of records returned is limited to 100.
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getEvents (whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event by Id  For technical reasons, the number of records returned is limited to 100.
     * @param eventId Event identifier (Guid)
     * @param {*} [options] Override http request options.
     */
    public getEventsById (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu events  For technical reasons, the number of records returned is limited to 100.
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events  For technical reasons, the number of records returned is limited to 100.
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId2 !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId2, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events by customer  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store events  For technical reasons, the number of records returned is limited to 100.
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user events  For technical reasons, the number of records returned is limited to 100.
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId2?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId2 !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId2, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get WhiteLabel events  For technical reasons, the number of records returned is limited to 100.
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FilesApiApiKeys {
}

export class FilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FilesApiApiKeys, value: string) {
        (this.authentications as any)[FilesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get file from storage
     * @param appId 
     * @param fileId 
     * @param {*} [options] Override http request options.
     */
    public downloadFile (appId: string, fileId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/files/download/{fileId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling downloadFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling downloadFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        (this.authentications as any)[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public database (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Database';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headHostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headPing (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public hostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        (this.authentications as any)[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param appId App Name Id
     * @param homeActionId Id of the action
     * @param isDismissed 
     * @param {*} [options] Override http request options.
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'homeActionId' + '}', encodeURIComponent(String(homeActionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            localVarQueryParameters['isDismissed'] = ObjectSerializer.serialize(isDismissed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param {*} [options] Override http request options.
     */
    public dismissOldPortalAction (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/home/dismissoldportalaction';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Actions
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeActions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultHomeAction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Statistics
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeStatistics (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHomeStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get API interaction logs
     * @param start Start date time
     * @param end End date time
     * @param appId 
     * @param filterByUserId User id (optional)
     * @param guid Id of the log
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, guid?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHttpRequestAndResponseLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        (this.authentications as any)[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Assign an EMV terminal to a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param emvTerminalId 
     * @param {*} [options] Override http request options.
     */
    public assignEmv (appId: string, hydraConfigId: number, emvTerminalId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/assign/{hydraConfigId}/{emvTerminalId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)))
            .replace('{' + 'emvTerminalId' + '}', encodeURIComponent(String(emvTerminalId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'emvTerminalId' is not null or undefined
        if (emvTerminalId === null || emvTerminalId === undefined) {
            throw new Error('Required parameter emvTerminalId was null or undefined when calling assignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/attach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelEmvPayment (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/cancelemvpayment/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelEmvPayment.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelEmvPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public detachStoreFromTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/detach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceType 
     * @param pageIndex 
     * @param pageSize 
     * @param storeId 
     * @param deviceName 
     * @param deviceSerial 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevices (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', pageIndex?: number, pageSize?: number, storeId?: number, deviceName?: string, deviceSerial?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/list'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevices.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevices.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (deviceName !== undefined) {
            localVarQueryParameters['deviceName'] = ObjectSerializer.serialize(deviceName, "string");
        }

        if (deviceSerial !== undefined) {
            localVarQueryParameters['deviceSerial'] = ObjectSerializer.serialize(deviceSerial, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHydraDeviceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEMVTerminalDetails (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEMVTerminalDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEmvOrderState (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvorderstate/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmvOrderState.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEmvOrderState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalTransactionDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get the status of Cash Payment Methon on Kisok
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getKioskCashPaymentSettings (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskcashsettings/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultKioskCashPaymentSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRegistration (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param {*} [options] Override http request options.
     */
    public getSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param emv 
     * @param {*} [options] Override http request options.
     */
    public hydraCreateEmv (appId: string, emv: EmvTerminal, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraCreateEmv.');
        }

        // verify required parameter 'emv' is not null or undefined
        if (emv === null || emv === undefined) {
            throw new Error('Required parameter emv was null or undefined when calling hydraCreateEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emv, "EmvTerminal")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public hydraDeleteEmv (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDeleteEmv.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hydraDeleteEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List EMV terminals belonging to the given AppNameId
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public hydraGetEmvsForAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraGetEmvsForAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultEmvTerminalWithAssignments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param deviceId 
     * @param hydraUserType 
     * @param serialNumber 
     * @param {*} [options] Override http request options.
     */
    public loginWithDeviceId (deviceId: string, hydraUserType?: 'Kiosk' | 'Terminal' | 'LegacyPrinter', serialNumber?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling loginWithDeviceId.');
        }

        if (hydraUserType !== undefined) {
            localVarQueryParameters['hydraUserType'] = ObjectSerializer.serialize(hydraUserType, "'Kiosk' | 'Terminal' | 'LegacyPrinter'");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serialNumber'] = ObjectSerializer.serialize(serialNumber, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param hydraRegistration 
     * @param {*} [options] Override http request options.
     */
    public register (appId: string, hydraRegistration: HydraRegistrationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling register.');
        }

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hydraRegistration, "HydraRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unAssign (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unAssign.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unAssign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unassign the currently assigned EMV terminal from a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param {*} [options] Override http request options.
     */
    public unassignEmv (appId: string, hydraConfigId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/unassign/{hydraConfigId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling unassignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update the Cash Payment Methon Visiability on Kisok
     * @param appId 
     * @param deviceId 
     * @param isCashEnabled 
     * @param {*} [options] Override http request options.
     */
    public updateKioskCashVisibilitySettings (appId: string, deviceId: string, isCashEnabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskupdatecashsettings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'isCashEnabled' is not null or undefined
        if (isCashEnabled === null || isCashEnabled === undefined) {
            throw new Error('Required parameter isCashEnabled was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (isCashEnabled !== undefined) {
            localVarQueryParameters['isCashEnabled'] = ObjectSerializer.serialize(isCashEnabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        (this.authentications as any)[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGenerateMenu (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGetStoreSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param lightspeedSettings 
     * @param {*} [options] Override http request options.
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: LightspeedSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lightspeedSettings, "LightspeedSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     * @param {*} [options] Override http request options.
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private API] Set Tax Rate on OptionSetItem
     * @param menuId Menu identifier
     * @param menuSectionId 
     * @param menuSectionItemId 
     * @param optionSetId 
     * @param menuItemOptionSetItemId Option set item identifier
     * @param taxRateId Tax Rate to use
     * @param {*} [options] Override http request options.
     */
    public setOptionSetItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setOptionSetItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     * @param {*} [options] Override http request options.
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItems (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param destinationDisplayOrder New Display Order of item
     * @param {*} [options] Override http request options.
     */
    public moveMenuItem (menuId: number, menuSectionId: number, menuSectionItemId: number, destinationDisplayOrder: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/setorder/{destinationDisplayOrder}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'destinationDisplayOrder' + '}', encodeURIComponent(String(destinationDisplayOrder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'destinationDisplayOrder' is not null or undefined
        if (destinationDisplayOrder === null || destinationDisplayOrder === undefined) {
            throw new Error('Required parameter destinationDisplayOrder was null or undefined when calling moveMenuItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param taxRateId tax rate to be set against item
     * @param {*} [options] Override http request options.
     */
    public setSectionItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setSectionItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set/update menu section availability hours.
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek Day of the  week
     * @param businessHoursPeriod Menu section active hours, note: DayOfWeek property will be overriden by the path parameter.
     * @param {*} [options] Override http request options.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'dayOfWeek' + '}', encodeURIComponent(String(dayOfWeek)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     * @param {*} [options] Override http request options.
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu availability type
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability DisplayAlways, DisplayBasedOnTimes, DisplayAlwaysStartCollapsed, DisplayAlwaysStartCollapsedBasedOnTimes
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: MenuSectionAvailabilityBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionAvailability, "MenuSectionAvailabilityBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSectionById (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSections (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Re-arrange Items within a Section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param displayOrders Item Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menuSectionsSetItemDisplayOrders (menuId: number, menuSectionId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitemdisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API]Clone a menu, (without attaching stores)
     * @param menuId Menu identifier
     * @param newName Name of the new Menu
     * @param {*} [options] Override http request options.
     */
    public createDraftMenuFromExistingMenu (menuId: number, newName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone/{newName}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'newName' + '}', encodeURIComponent(String(newName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        // verify required parameter 'newName' is not null or undefined
        if (newName === null || newName === undefined) {
            throw new Error('Required parameter newName was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu. If request body is empty, the system will create a menu with default items.
     * @param appId App identifier
     * @param menu Menu
     * @param {*} [options] Override http request options.
     */
    public createNewMenuForApp (appId: string, menu: CreateFullMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "CreateFullMenu")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Mark a Menu as Deleted
     * @param menuId Menu Identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuImage (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all menu metadata by menu ID and store ID
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getAllMenuMetadataByMenuIdAndStoreId (menuId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAllMetadataResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuById (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus store names
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuStoreNames (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuStoreNames");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus tax details
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuTaxDetails (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuTaxDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuTaxDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus by appId
     * @param appId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public getMenusByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get a Menus Checkpoints
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenusCheckpoints (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuCheckpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Remove a Menus Tax Rate, can only remove a tax rate that does not have items/optionSetItems attached
     * @param menuId Menu identifier
     * @param taxId Id of Menu Tax to be removed
     * @param {*} [options] Override http request options.
     */
    public menusDeleteTaxRate (menuId: number, taxId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/{taxId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusDeleteTaxRate.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling menusDeleteTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param menuId 
     * @param isAvailable 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public menusGetMenuBulkShowHide (menuId: number, isAvailable: boolean, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide/list'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set if tax shows for a Menu
     * @param menuId Menu identifier
     * @param show Boolean show or dont show tax (Exclusive tax type can only ever be TRUE)
     * @param {*} [options] Override http request options.
     */
    public menusSetDisplayOnMenuTax (menuId: number, show: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/show/{show}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'show' + '}', encodeURIComponent(String(show)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        // verify required parameter 'show' is not null or undefined
        if (show === null || show === undefined) {
            throw new Error('Required parameter show was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Re-arrange Sections within a Menu
     * @param menuId Menu identifier
     * @param displayOrders Section Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menusSetItemDisplayOrders (menuId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sectiondisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menusSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param menuId 
     * @param menuElements 
     * @param isAvailable 
     * @param undoAfter 
     * @param {*} [options] Override http request options.
     */
    public menusShowHideBulkItems (menuId: number, menuElements: Array<MenuElementHide>, isAvailable: boolean, undoAfter: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'menuElements' is not null or undefined
        if (menuElements === null || menuElements === undefined) {
            throw new Error('Required parameter menuElements was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'undoAfter' is not null or undefined
        if (undoAfter === null || undoAfter === undefined) {
            throw new Error('Required parameter undoAfter was null or undefined when calling menusShowHideBulkItems.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuElements, "Array<MenuElementHide>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementEditResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set the type of Tax on a Menu
     * @param menuId Menu identifier
     * @param type Type of Tax
     * @param {*} [options] Override http request options.
     */
    public menusUpdateTaxType (menuId: number, type: 'IncludedInBasePrice' | 'ExcludedFromBasePrice', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/type/{type}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpdateTaxType.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling menusUpdateTaxType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Add/Update a Tax Rate
     * @param menuId Menu identifier
     * @param taxRate Tax Rate to Add/Update
     * @param {*} [options] Override http request options.
     */
    public menusUpsertTaxRate (menuId: number, taxRate: MenuTaxRate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/taxrate'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpsertTaxRate.');
        }

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling menusUpsertTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxRate, "MenuTaxRate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MenuTaxRate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Restore a Menu to a checkpoint
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     * @param {*} [options] Override http request options.
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'checkpointId' + '}', encodeURIComponent(String(checkpointId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Lock/Unlock a Menu for Editing
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     * @param {*} [options] Override http request options.
     */
    public setMenuLock (menuId: number, locked: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locked, "boolean")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set Menus Name
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     * @param {*} [options] Override http request options.
     */
    public setMenuName (menuId: number, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenu (menuId: number, menu: MenuBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "MenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuImage (menuId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu from xlsx file.
     * @param appId App identifier
     * @param Menu Uploaded xlsx menu
     * @param {*} [options] Override http request options.
     */
    public uploadNewMenuForApp (appId: string, Menu: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/xlsx'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadNewMenuForApp.');
        }

        // verify required parameter 'Menu' is not null or undefined
        if (Menu === null || Menu === undefined) {
            throw new Error('Required parameter Menu was null or undefined when calling uploadNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Menu !== undefined) {
            localVarFormParams['Menu'] = Menu;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uri Redirect uri
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OAuth App
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createOAuthApp (oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteOAuthApp (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all OAuth Apps
     * @param appId 
     * @param oauthAppName 
     * @param {*} [options] Override http request options.
     */
    public getOAuthApps (appId: string, oauthAppName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            localVarQueryParameters['oauthAppName'] = ObjectSerializer.serialize(oauthAppName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App by identifier
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App secret key
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth access token for App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOauthAccessToken (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App redirect uris
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRedirectUris (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public oAuthClientsGetApplications (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uriId Redirect uri identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OAuth App
     * @param oauthAppId OAuth App identifier
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateOAuthApp (oauthAppId: string, oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * To accept an order, you create an `accept` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Accept order
     * @param id Order identifier
     * @param acceptObject Order accept parameters (eg: EstimatedMinutesForDelivery)
     * @param {*} [options] Override http request options.
     */
    public acceptOrder (id: number, acceptObject: Accept, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "Accept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To dispatch an order send a POST request with `Id` path parameter which identifies the order.
     * @summary Dispatch order
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public dispatchOrder (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order by ID
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderById (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orders by filter
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param from Order has been placed after this parameter value
     * @param to Order has been placed before this parameter value
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, from?: Date, to?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get summary of orders by filter
     * @param appId App Name Id
     * @param searchQuery Query string
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param orderByRequestedForTime 
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, orderByRequestedForTime?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderByRequestedForTime !== undefined) {
            localVarQueryParameters['orderByRequestedForTime'] = ObjectSerializer.serialize(orderByRequestedForTime, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrderSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To refund an order, you create a `refund` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Refund order
     * @param id Order identifier
     * @param refundObject 
     * @param {*} [options] Override http request options.
     */
    public refundOrder (id: number, refundObject: Refund, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "Refund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To reject an order, you create a `reject` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Reject order
     * @param id Order identifier
     * @param rejectObject 
     * @param {*} [options] Override http request options.
     */
    public rejectOrder (id: number, rejectObject: Reject, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "Reject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Returns payment refund information related to the order with the order id
     * @param orderId Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderPaymentInformation (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payments/payment/{orderId}/refundable'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderPaymentInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderPaymentInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsApiApiKeys {
}

export class PayoutsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Export a list of payout's chargebacks as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutChargebacks.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's orders as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOrders (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOrders.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's other charges as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOtherCharges.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export a list of payout's refunds as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutRefunds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export payout's details as CSV
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutStores (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutStores.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Payout details broken down by Store
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param {*} [options] Override http request options.
     */
    public getPayout (appId: string, bankAccountId: number, payoutId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PayoutDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's chargebacks
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutChargebacks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutChargeback");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's orders
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOrders (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOrders.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's other charges
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOtherCharges.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOtherCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of payout's refunds
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutRefunds.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutRefund");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Get list of payout summaries
     * @param appId 
     * @param bankAccountId 
     * @param payeeBankAccountDataId Deprecated
     * @param startDate 
     * @param endDate 
     * @param status 
     * @param {*} [options] Override http request options.
     */
    public getPayoutSummaries (appId: string, bankAccountId?: number, payeeBankAccountDataId?: number, startDate?: Date, endDate?: Date, status?: 'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutSummaries.');
        }

        if (bankAccountId !== undefined) {
            localVarQueryParameters['bankAccountId'] = ObjectSerializer.serialize(bankAccountId, "number");
        }

        if (payeeBankAccountDataId !== undefined) {
            localVarQueryParameters['payeeBankAccountDataId'] = ObjectSerializer.serialize(payeeBankAccountDataId, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPayoutSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Get list of payouts
     * @param appId 
     * @param bankAccountId 
     * @param payeeBankAccountDataId Deprecated
     * @param startDate 
     * @param endDate 
     * @param status 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPayouts (appId: string, bankAccountId?: number, payeeBankAccountDataId?: number, startDate?: Date, endDate?: Date, status?: 'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled', page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayouts.');
        }

        if (bankAccountId !== undefined) {
            localVarQueryParameters['bankAccountId'] = ObjectSerializer.serialize(bankAccountId, "number");
        }

        if (payeeBankAccountDataId !== undefined) {
            localVarQueryParameters['payeeBankAccountDataId'] = ObjectSerializer.serialize(payeeBankAccountDataId, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayout");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        (this.authentications as any)[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get processing fee configs by store identifiers
     * @param storeIds Store identifiers
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PushNotificationsApiApiKeys {
}

export class PushNotificationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PushNotificationsApiApiKeys, value: string) {
        (this.authentications as any)[PushNotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param scheduledPushNotificationId ID of Scheduled push notifiaction to delete
     * @param {*} [options] Override http request options.
     */
    public deletePushNotification (appId: string, scheduledPushNotificationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling deletePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPushNotifications (appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPushNotifications.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId Application Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public schedulePushNotification (appId: string, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling schedulePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling schedulePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Update the push notification
     * @param appId Application Id
     * @param scheduledPushNotificationId Notification Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public updatePushNotification (appId: string, scheduledPushNotificationId: number, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updatePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        (this.authentications as any)[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a Store Group  It will be attached to an existing App
     * @param appNameId App Name Id
     * @param storeGroup Store group definition
     * @param {*} [options] Override http request options.
     */
    public createStoreGroup (appNameId: string, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a Store Groups
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a paginated list of Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Returns a paginated list of Extended Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param groupingRadius 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (groupingRadius !== undefined) {
            localVarQueryParameters['groupingRadius'] = ObjectSerializer.serialize(groupingRadius, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroupExtended");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a Store Group  Can only remove a store group if there is no stores attached to the group
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public removeStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Store Group
     * @param storeGroupId Store Group Id
     * @param storeGroup Store Group Delta
     * @param {*} [options] Override http request options.
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroupBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreOrderCapacityApiApiKeys {
}

export class StoreOrderCapacityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreOrderCapacityApiApiKeys, value: string) {
        (this.authentications as any)[StoreOrderCapacityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get store's order capacity configuration
     * @param appId App Name Id
     * @param storeId Store Id
     * @param deliveryType Delivery / Pickup
     * @param {*} [options] Override http request options.
     */
    public getStoreOrderCapacity (appId: string, storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}/{deliveryType}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getStoreOrderCapacity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreOrderCapacityConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a store's order capacity configuration
     * @param storeId Store identifier
     * @param deliveryType Delivery / Pickup
     * @param newOrderCapacityConfig new order capacity configuration
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateStoreOrderCapacityConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', newOrderCapacityConfig: StoreOrderCapacityConfigEditModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'newOrderCapacityConfig' is not null or undefined
        if (newOrderCapacityConfig === null || newOrderCapacityConfig === undefined) {
            throw new Error('Required parameter newOrderCapacityConfig was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        if (deliveryType !== undefined) {
            localVarQueryParameters['deliveryType'] = ObjectSerializer.serialize(deliveryType, "'Delivery' | 'Pickup'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newOrderCapacityConfig, "StoreOrderCapacityConfigEditModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Archive store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public archiveStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/archive'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling archiveStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign Menu to Store
     * @param storeId Store identifier
     * @param menuId Id of Menu to assign to store
     * @param {*} [options] Override http request options.
     */
    public assignMenu (storeId: number, menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/menu/{menuId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling assignMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone store with store clone settings
     * @param storeId Store identifier
     * @param settings Settings for cloning the store
     * @param {*} [options] Override http request options.
     */
    public cloneStore (storeId: number, settings: StoreCloneSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "StoreCloneSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create Business Hours Override for a store
     * @param storeId Store identifier
     * @param businessHoursOverride Business Hours Override
     * @param {*} [options] Override http request options.
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: BusinessHoursOverrideBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursOverride, "BusinessHoursOverrideBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create store with Store Group identifier
     * @param storeGroupId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public createStore (storeGroupId: number, store: StoreCreateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreCreateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Business Hours Override for a store
     * @param storeId 
     * @param businessHoursOverrideId 
     * @param {*} [options] Override http request options.
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'businessHoursOverrideId' + '}', encodeURIComponent(String(businessHoursOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Stores Bank Account Id
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getBankAccountForStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAssignedBankAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param {*} [options] Override http request options.
     */
    public getBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get business hours overrides by store identifier
     * @param storeId Store identifier
     * @param after Return results that ended after this datetime. Default value is the current datetime.
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store end of day report
     * @param storeId Store identifier
     * @param date Store identifier
     * @param {*} [options] Override http request options.
     */
    public getEndOfDayReport (storeId: number, date?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/endofdayreport'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getEndOfDayReport.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreEndOfDayReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param {*} [options] Override http request options.
     */
    public getPreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPreOrderConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the Preview times of the pre-order configuration
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig_leadTimeMinutes Lead Time in Minutes
     * @param preOrderConfig_intervalMinutes Interval in minutes
     * @param preOrderConfig_maxOrderAheadDays Max Days to order ahead
     * @param preOrderConfig_includeAsap Show ASAP as option
     * @param preOrderConfig_includeMoreGranularInitialTime Granual Init&#39; Time
     * @param preOrderConfig_cutOffTimePreviousDayBasic Cut off time previous day
     * @param preOrderConfig_cutOffTimeCurrentDayBasic Cut off time current day
     * @param preOrderConfig_preOrderTimeDisplayType Type of time displayed.
     * @param preOrderConfig_alwaysAppearOpen Specifies whether a customer can pre-order outside the store opening hours or not.
     * @param preOrderConfig_requireExplicitSelectAlways Force customer to select collection time.
     * @param {*} [options] Override http request options.
     */
    public getPreOrderPreview (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig_leadTimeMinutes?: number, preOrderConfig_intervalMinutes?: number, preOrderConfig_maxOrderAheadDays?: number, preOrderConfig_includeAsap?: boolean, preOrderConfig_includeMoreGranularInitialTime?: boolean, preOrderConfig_cutOffTimePreviousDayBasic?: string, preOrderConfig_cutOffTimeCurrentDayBasic?: string, preOrderConfig_preOrderTimeDisplayType?: 'SingleTime' | 'StartAndEndTime' | 'DayOnly', preOrderConfig_alwaysAppearOpen?: boolean, preOrderConfig_requireExplicitSelectAlways?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/preview'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderPreview.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderPreview.');
        }

        if (preOrderConfig_leadTimeMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.leadTimeMinutes'] = ObjectSerializer.serialize(preOrderConfig_leadTimeMinutes, "number");
        }

        if (preOrderConfig_intervalMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.intervalMinutes'] = ObjectSerializer.serialize(preOrderConfig_intervalMinutes, "number");
        }

        if (preOrderConfig_maxOrderAheadDays !== undefined) {
            localVarQueryParameters['preOrderConfig.maxOrderAheadDays'] = ObjectSerializer.serialize(preOrderConfig_maxOrderAheadDays, "number");
        }

        if (preOrderConfig_includeAsap !== undefined) {
            localVarQueryParameters['preOrderConfig.includeAsap'] = ObjectSerializer.serialize(preOrderConfig_includeAsap, "boolean");
        }

        if (preOrderConfig_includeMoreGranularInitialTime !== undefined) {
            localVarQueryParameters['preOrderConfig.includeMoreGranularInitialTime'] = ObjectSerializer.serialize(preOrderConfig_includeMoreGranularInitialTime, "boolean");
        }

        if (preOrderConfig_cutOffTimePreviousDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimePreviousDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimePreviousDayBasic, "string");
        }

        if (preOrderConfig_cutOffTimeCurrentDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimeCurrentDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimeCurrentDayBasic, "string");
        }

        if (preOrderConfig_preOrderTimeDisplayType !== undefined) {
            localVarQueryParameters['preOrderConfig.preOrderTimeDisplayType'] = ObjectSerializer.serialize(preOrderConfig_preOrderTimeDisplayType, "'SingleTime' | 'StartAndEndTime' | 'DayOnly'");
        }

        if (preOrderConfig_alwaysAppearOpen !== undefined) {
            localVarQueryParameters['preOrderConfig.alwaysAppearOpen'] = ObjectSerializer.serialize(preOrderConfig_alwaysAppearOpen, "boolean");
        }

        if (preOrderConfig_requireExplicitSelectAlways !== undefined) {
            localVarQueryParameters['preOrderConfig.requireExplicitSelectAlways'] = ObjectSerializer.serialize(preOrderConfig_requireExplicitSelectAlways, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPreOrderTime");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param paymentAccountType 
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: 'Card' | 'Cash' | 'Ideal' | 'Bancontact' | 'Giropay' | 'Eps' | 'Emv' | 'PayPal', appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'paymentAccountType' + '}', encodeURIComponent(String(paymentAccountType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store by identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getStoreById (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param storeNameQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoreHeadersByAppId (appId: string, storeNameQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/header'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreHeadersByAppId.');
        }

        if (storeNameQuery !== undefined) {
            localVarQueryParameters['storeNameQuery'] = ObjectSerializer.serialize(storeNameQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores statistics by app name id and storeIds
     * @param appId App Name Id
     * @param storeId Store Ids
     * @param {*} [options] Override http request options.
     */
    public getStoreNetSales (appId: string, storeId: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores, excluding archived ones
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public publishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/publish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling publishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param businessHoursPeriod Business Hours Period
     * @param {*} [options] Override http request options.
     */
    public setBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param enabled Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public setPreOrdeEnabled (storeId: number, deliveryType: 'Delivery' | 'Pickup', enabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/enabled'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'enabled' is not null or undefined
        if (enabled === null || enabled === undefined) {
            throw new Error('Required parameter enabled was null or undefined when calling setPreOrdeEnabled.');
        }

        if (enabled !== undefined) {
            localVarQueryParameters['enabled'] = ObjectSerializer.serialize(enabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unpublish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public unpublishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/unpublish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unpublishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public updatePreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig: PreOrderConfig, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'preOrderConfig' is not null or undefined
        if (preOrderConfig === null || preOrderConfig === undefined) {
            throw new Error('Required parameter preOrderConfig was null or undefined when calling updatePreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(preOrderConfig, "PreOrderConfig")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store by identifier
     * @param storeId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public updateStore (storeId: number, store: StoreBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address
     * @param storeId Store identifier
     * @param storeAddress Store address
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddress (storeId: number, storeAddress: StoreAddressBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeAddress, "StoreAddressBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreAddress");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address coordinates
     * @param storeId Store identifier
     * @param coordinates Store address coordinates
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: Coordinates, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coordinates, "Coordinates")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCoordinates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectApiApiKeys {
}

export class StripeCustomConnectApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeCustomConnectApiApiKeys, value: string) {
        (this.authentications as any)[StripeCustomConnectApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a new Bank Account and Stripe connected account
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccountAndConnectedAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a Stripe connected account associated with the bank account of bankAccountId
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/create-update-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling createStripeConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single-use Stripe URL for the given account
     * @param appId App Name
     * @param stripeConnectedAccountId Stripe Connected Account Id
     * @param stripeAccountLinkRequest 
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccountLink (appId: string, stripeConnectedAccountId: string, stripeAccountLinkRequest: StripeAccountLinkRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{stripeConnectedAccountId}/create-account-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'stripeConnectedAccountId' + '}', encodeURIComponent(String(stripeConnectedAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeAccountLinkRequest' is not null or undefined
        if (stripeAccountLinkRequest === null || stripeAccountLinkRequest === undefined) {
            throw new Error('Required parameter stripeAccountLinkRequest was null or undefined when calling createStripeConnectedAccountLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stripeAccountLinkRequest, "StripeAccountLinkRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current verification status of the given connected account
     * @param appId 
     * @param stripeConnectedAccountId 
     * @param {*} [options] Override http request options.
     */
    public getVerificationStatus (appId: string, stripeConnectedAccountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/verification-status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVerificationStatus.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling getVerificationStatus.');
        }

        if (stripeConnectedAccountId !== undefined) {
            localVarQueryParameters['stripeConnectedAccountId'] = ObjectSerializer.serialize(stripeConnectedAccountId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account's BusinessType and create a Stripe Connected Account
     * @param appId App Name
     * @param bankAccountId Bank Account Id
     * @param businessType Bank Account business type
     * @param {*} [options] Override http request options.
     */
    public setBankAccountBusinessType (appId: string, bankAccountId: number, businessType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account/{bankAccountId}/businesstype'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'businessType' is not null or undefined
        if (businessType === null || businessType === undefined) {
            throw new Error('Required parameter businessType was null or undefined when calling setBankAccountBusinessType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessType, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param linkRequestId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public stripeCustomConnectRefresh (linkRequestId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/refresh-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'linkRequestId' is not null or undefined
        if (linkRequestId === null || linkRequestId === undefined) {
            throw new Error('Required parameter linkRequestId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        if (linkRequestId !== undefined) {
            localVarQueryParameters['linkRequestId'] = ObjectSerializer.serialize(linkRequestId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account details
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     * @param updateRequest fields to be updated
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountDetails (appId: string, bankAccountId: number, updateRequest: BankAccountDetailsUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/update-bank-account-details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'updateRequest' is not null or undefined
        if (updateRequest === null || updateRequest === undefined) {
            throw new Error('Required parameter updateRequest was null or undefined when calling updateBankAccountDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateRequest, "BankAccountDetailsUpdateRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        (this.authentications as any)[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Cancel a stuart job
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartCancelJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get start job details
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultJobResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stuart settings for a store
     * @param storeId Store Identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetStuartSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStuartSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set stuart settings for a store
     * @param storeId Store Identifier
     * @param stuartSettings Stuart settings model
     * @param {*} [options] Override http request options.
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: StuartSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stuartSettings, "StuartSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SystemCheckApiApiKeys {
}

export class SystemCheckApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SystemCheckApiApiKeys, value: string) {
        (this.authentications as any)[SystemCheckApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/systemcheck';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        (this.authentications as any)[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create teammate and send an invite.
     * @param appId Application identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public createTeammate (appId: string, teammate: CreateTeammate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "CreateTeammate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete teammate
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteTeammate (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a teammates by email address
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all teammates
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getTeammatesByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeem one-time code from invitation
     * @param otc 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public redeemInvitation (otc: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', encodeURIComponent(String(otc)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRedeemInvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update teammates (this method does not support Deltas!)
     * @param appId Application identifier
     * @param id teammate identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public updateTeammate (appId: string, id: string, teammate: TeammateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "TeammateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param userId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getPreviousOrderCountForStore (userId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/{userId}/previousordercount/{storeId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get role names
     * @param {*} [options] Override http request options.
     */
    public getRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Create voucher
     * @param appId App Name Id
     * @param voucher Voucher Details
     * @param {*} [options] Override http request options.
     */
    public createVoucher (appId: string, voucher: CreateVoucher, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "CreateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher by identifier
     * @param voucherId Id of the voucher
     * @param {*} [options] Override http request options.
     */
    public getVoucherById (voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher stats by identifier
     * @param voucherId Id of the voucher
     * @param aggregateDataBy Aggregate data by day \\ week \\ month
     * @param dataPointLimit Amount of data points per request
     * @param {*} [options] Override http request options.
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            localVarQueryParameters['aggregateDataBy'] = ObjectSerializer.serialize(aggregateDataBy, "'Daily' | 'Weekly' | 'Monthly'");
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultVoucherDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get vouchers summaries for App Id
     * @param appId Application Id
     * @param pageIndex Page Number
     * @param pageSize Page Size
     * @param searchCodes Search by Voucher Code\\s
     * @param statusSearch Search by Status
     * @param typeSearch Search by Type
     * @param subTypeSearch Search by Sub Type
     * @param storeIds Search by Store Ids
     * @param {*} [options] Override http request options.
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>, typeSearch?: Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>, subTypeSearch?: Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchCodes !== undefined) {
            localVarQueryParameters['searchCodes'] = ObjectSerializer.serialize(searchCodes, "Array<string>");
        }

        if (statusSearch !== undefined) {
            localVarQueryParameters['statusSearch'] = ObjectSerializer.serialize(statusSearch, "Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>");
        }

        if (typeSearch !== undefined) {
            localVarQueryParameters['typeSearch'] = ObjectSerializer.serialize(typeSearch, "Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>");
        }

        if (subTypeSearch !== undefined) {
            localVarQueryParameters['subTypeSearch'] = ObjectSerializer.serialize(subTypeSearch, "Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultVoucherSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Updates voucher
     * @param voucherId Id of the voucher
     * @param voucher Updated details for the voucher
     * @param storeId 
     * @param percentValue Percent voucher value (can have 1 of 3)
     * @param lumpValue Lump voucher value (can have 1 of 3)
     * @param freeItemId Free Item Id (can have 1 of 3)
     * @param {*} [options] Override http request options.
     */
    public updateVoucher (voucherId: number, voucher: VoucherBase, storeId?: Array<number>, percentValue?: number, lumpValue?: number, freeItemId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (percentValue !== undefined) {
            localVarQueryParameters['percentValue'] = ObjectSerializer.serialize(percentValue, "number");
        }

        if (lumpValue !== undefined) {
            localVarQueryParameters['lumpValue'] = ObjectSerializer.serialize(lumpValue, "number");
        }

        if (freeItemId !== undefined) {
            localVarQueryParameters['freeItemId'] = ObjectSerializer.serialize(freeItemId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "VoucherBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a webhook subscription for you Oauth App
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public craeteWebhookSubscription (oauthAppId: string, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling craeteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete you webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscription event names
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNames (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your webhook subscriptions selected event names
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a sample event from a webhook subscription
     * @param eventName 
     * @param appId 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param version 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventSample (eventName: string, appId: string, oauthAppId: string, webhookSubscriptionId: string, version?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}/test'
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventSample.');
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookEventSample");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs for your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param appId 
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscriptions by your Oauth App id
     * @param oauthAppId Oauth App identifier
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook subscription object
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebsiteApiApiKeys {
}

export class WebsiteApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebsiteApiApiKeys, value: string) {
        (this.authentications as any)[WebsiteApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a testimonial
     * @param appId Application identifier
     * @param testimonial Testimonial to be added
     * @param {*} [options] Override http request options.
     */
    public addTestimonial (appId: string, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling addTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to delete
     * @param {*} [options] Override http request options.
     */
    public deleteTestimonial (appId: string, testimonialId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling deleteTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Website Image
     * @param appId Application identifier
     * @param imageId Id of the image
     * @param {*} [options] Override http request options.
     */
    public deleteWebsiteImage (appId: string, imageId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebsiteImage.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling deleteWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to edit
     * @param testimonial New values of the testimonial
     * @param {*} [options] Override http request options.
     */
    public editTestimonial (appId: string, testimonialId: number, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling editTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Index Configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getIndexConfiguration (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Index Configuration
     * @param appId Application identifier
     * @param indexPage New index page definition
     * @param {*} [options] Override http request options.
     */
    public setIndexConfiguration (appId: string, indexPage: IndexPageBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setIndexConfiguration.');
        }

        // verify required parameter 'indexPage' is not null or undefined
        if (indexPage === null || indexPage === undefined) {
            throw new Error('Required parameter indexPage was null or undefined when calling setIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(indexPage, "IndexPageBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPageBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload Website Image
     * @param appId Application identifier
     * @param imageLocation Section for which to upload the image
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadWebsiteImage (appId: string, imageLocation: 'IndexHeader' | 'IndexAboutSectionLeft' | 'IndexAboutSectionRight' | 'IndexGallery' | 'IndexOpeningHoursHeader' | 'IndexTestimonialsHeader', Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageLocation}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageLocation' + '}', encodeURIComponent(String(imageLocation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'imageLocation' is not null or undefined
        if (imageLocation === null || imageLocation === undefined) {
            throw new Error('Required parameter imageLocation was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Triggers a Check DNS Process
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public websiteCheckNow (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/dnscheck'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling websiteCheckNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
