/**
 * Flipdish Open API v1.0
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* Accept
*/
export class Accept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery': number;
}

/**
* Account details
*/
export class AccountDetail {
    /**
    * Email
    */
    'Email': string;
    /**
    * Signup steps
    */
    'SignupSteps': Array<SignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified': boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser': boolean;
    /**
    * Accounts Id
    */
    'AccountId': number;
    /**
    * Name
    */
    'Name': string;
    /**
    * Language Id
    */
    'Language': string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId': string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone': boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures': boolean;
}

/**
* Account Details Base
*/
export class AccountDetailBase {
    /**
    * Name
    */
    'Name': string;
    /**
    * Language Id
    */
    'Language': string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId': string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone': boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures': boolean;
}

/**
* Represents the format of a bank account field
*/
export class AccountFieldDefinition {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key': AccountFieldDefinition.KeyEnum;
    /**
    * Display name of the field
    */
    'DisplayName': string;
    /**
    * There are some fields that are of type known to the frontend (IBAN, Swift) -- for those frontend should use its own validation library, e.g. ibantools
    */
    'Type': AccountFieldDefinition.TypeEnum;
    /**
    * Minimum length of the field
    */
    'MinLength': number;
    /**
    * Maximum length of the field
    */
    'MaxLength': number;
    /**
    * Is the field digits (numeric) only
    */
    'DigitsOnly': boolean;
    /**
    * Regex for validating the field (if specified)
    */
    'Regex': string;
}

export namespace AccountFieldDefinition {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
    export enum TypeEnum {
        None = <any> 'None',
        Iban = <any> 'Iban'
    }
}
/**
* Represents one populated account field (its key and value)
*/
export class AccountFieldKeyValuePair {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key': AccountFieldKeyValuePair.KeyEnum;
    /**
    * The value of the field
    */
    'Value': string;
}

export namespace AccountFieldKeyValuePair {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
}
/**
* List of field definitions per country
*/
export class AccountFieldsDefinitions {
    /**
    * List of field definitions per country
    */
    'DefinitionsPerCountry': { [key: string]: Array<AccountFieldDefinition>; };
}

/**
* Add item details
*/
export class AddItemDetails {
    /**
    * Promotional Item Id
    */
    'PromotionalItemId': number;
    /**
    * Promotional Item Name
    */
    'PromotionalItemName': string;
}

/**
* 
*/
export class AllMetadataResult {
    /**
    * Menu item metadata
    */
    'MenuItemMetadata': Array<Metadata>;
    /**
    * Menu item optionset item metadata
    */
    'MenuItemOptionSetItemMetadata': Array<Metadata>;
}

/**
* Client Analytics event
*/
export class AnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Type of the event
    */
    'EventType': string;
    /**
    * Type of the app the event is coming from
    */
    'AppType': string;
    /**
    * JSON Metadata
    */
    'Metadata': string;
    /**
    * User Id
    */
    'UserId': number;
    /**
    * Latitude of the event
    */
    'Latitude': number;
    /**
    * Longitude of the event
    */
    'Longitude': number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart': Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays': number;
    /**
    * The values of this data point
    */
    'CurrencyData': Array<CurrencyData>;
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart': Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays': number;
    /**
    * The value of this data point
    */
    'Value': number;
}

/**
* Provides an average value for a single hour of day of the week
*/
export class ApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day': ApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour': number;
    /**
    * Total Value
    */
    'TotalValue': number;
}

export namespace ApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class ApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved': number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved': number;
    /**
    * Currency based data
    */
    'CurrencyData': Array<StatisticsCurrencyDataPoint>;
}

/**
* APM status
*/
export class ApmStatus {
    /**
    * Indicates if APM is active or otherwise
    */
    'IsApmEnabled': boolean;
}

/**
* App
*/
export class App {
    /**
    * App Identifier
    */
    'AppId': string;
    /**
    * Has iOS app in Apple App Store. This is readonly.
    */
    'HasIosApp': boolean;
    /**
    * Has Android app in Google Play Store. This is readonly.
    */
    'HasAndroidApp': boolean;
    /**
    * Country identifier in ISO 3166-1 alpha-2 format.   This code is set automatically based on the locations of the Stores in the App.     The App Country is used    - to determine how to parse mobile phone numbers that are entered in their local numbering format   - to determine if country specific payment methods should be offered   - in various fraud checks
    */
    'CountryId': string;
    /**
    * Application Logo.
    */
    'LogoImageUrl': string;
    /**
    * Languages that have been selected to be available to customers.
    */
    'Languages': Array<Language>;
    /**
    * Lists all languages that are supported by Flipdish.
    */
    'AvailableAppLanguages': Array<Language>;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel': App.AppAccessLevelEnum;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet': App.Array<AppResourceSetEnum>;
    /**
    * Feature flags. These cannot be set by 3rd parties.
    */
    'Features': Array<string>;
    /**
    * Center of the map coordinates. This is used to center the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapCenter': Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapNorthEast': Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapSouthWest': Coordinates;
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name': string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName': string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor': string;
    /**
    * Application Category
    */
    'ApplicationCategory': App.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled': boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled': boolean;
}

export namespace App {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum Array&lt;AppResourceSetEnum&gt; {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        EditAppAssets = <any> 'EditAppAssets',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        DeleteCampaignsConfigurations = <any> 'DeleteCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        EditStoreKioskSettings = <any> 'EditStoreKioskSettings',
        EditStoreOrderCapacity = <any> 'EditStoreOrderCapacity',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        UpdateVouchersExtendDisable = <any> 'UpdateVouchersExtendDisable',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewWebsiteDnsVerified = <any> 'ViewWebsiteDnsVerified',
        ViewWebsiteCertificateCreated = <any> 'ViewWebsiteCertificateCreated',
        ViewWebsiteCertificateRenewed = <any> 'ViewWebsiteCertificateRenewed',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        VerifyBankAccounts = <any> 'VerifyBankAccounts',
        ViewFeesConfigurations = <any> 'ViewFeesConfigurations',
        EditFeesConfigurations = <any> 'EditFeesConfigurations',
        ViewHydraConfig = <any> 'ViewHydraConfig',
        UpdateHydraConfigManage = <any> 'UpdateHydraConfigManage',
        InitiateBluetoothPairingMode = <any> 'InitiateBluetoothPairingMode',
        ViewCustomers = <any> 'ViewCustomers',
        EditCustomers = <any> 'EditCustomers',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        DownloadCustomerCsvExport = <any> 'DownloadCustomerCsvExport',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        ViewHydraAuditLogs = <any> 'ViewHydraAuditLogs',
        ViewPushNotificationAuditLogs = <any> 'ViewPushNotificationAuditLogs',
        ViewStripeCustomConnectedAccountAuditLogs = <any> 'ViewStripeCustomConnectedAccountAuditLogs',
        ViewKioskBluetoothDeviceAuditLogs = <any> 'ViewKioskBluetoothDeviceAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer',
        InviteDriverToApp = <any> 'InviteDriverToApp',
        GetDriverForApp = <any> 'GetDriverForApp',
        RemoveDriverFromApp = <any> 'RemoveDriverFromApp',
        AssignDriverToOrder = <any> 'AssignDriverToOrder',
        UnassignDriverFromOrder = <any> 'UnassignDriverFromOrder',
        UpdateOrdersDeliveryTrackingStatus = <any> 'UpdateOrdersDeliveryTrackingStatus',
        ViewPayouts = <any> 'ViewPayouts'
    }
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application compliance model
*/
export class AppCompliance {
    /**
    * App ID
    */
    'AppId': string;
    /**
    * Type of compliance.  This controls if the Flipdish websites and apps display cookie consent banners and adjust cookies to be inline with various regulations.   You should set this correctly based on your region.
    */
    'ComplianceType': AppCompliance.ComplianceTypeEnum;
}

export namespace AppCompliance {
    export enum ComplianceTypeEnum {
        Default = <any> 'Default',
        GdprCompliance = <any> 'GdprCompliance'
    }
}
/**
* Application configuration
*/
export class AppConfigUpdateModel {
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name': string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName': string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor': string;
    /**
    * Application Category
    */
    'ApplicationCategory': AppConfigUpdateModel.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled': boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled': boolean;
}

export namespace AppConfigUpdateModel {
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application created event
*/
export class AppCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * App Name
    */
    'AppName': string;
    /**
    * Country Id
    */
    'CountryId': string;
    /**
    * User information
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Application updated event
*/
export class AppUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * A summary of changes made
    */
    'Changes': string;
    /**
    * App Name
    */
    'AppName': string;
    /**
    * Country Id
    */
    'CountryId': string;
    /**
    * User information
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Assigned to Store Bank Account
*/
export class AssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id': number;
    /**
    * Name of Bank Account
    */
    'BankAccountName': string;
}

/**
* Period opening and closing balance
*/
export class BalanceDetails {
    'OpeningBalance': number;
    'ClosingBalance': number;
}

/**
* BANK ACCOUNT
*/
export class BankAccount {
    /**
    * Id of this account
    */
    'Id': number;
    /**
    * Name of this account
    */
    'AccountName': string;
    /**
    * IBAN of this account
    */
    'Iban': string;
    /**
    * SWIFT of this bank account
    */
    'Swift': string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields should be ignored.
    */
    'PopulatedAccountFields': Array<AccountFieldKeyValuePair>;
    /**
    * Status of Account
    */
    'AccountState': BankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames': Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress': string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode': string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress': string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode': string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber': string;
}

export namespace BankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress': string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode': string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress': string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode': string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber': string;
    /**
    * Currency of Account
    */
    'CurrencyCode': BankAccountCreate.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds': Array<number>;
    /**
    * Name of Bank
    */
    'BankName': string;
    /**
    * Name of this account
    */
    'AccountName': string;
    /**
    * IBAN of this account
    */
    'Iban': string;
    /**
    * SWIFT of this bank account
    */
    'Swift': string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode': string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields': Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason': string;
    /**
    * Business Type
    */
    'BusinessType': BankAccountCreate.BusinessTypeEnum;
}

export namespace BankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount': BankAccount;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class BankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount': BankAccount;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class BankAccountDetail {
    /**
    * Id of this account
    */
    'Id': number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames': Array<string>;
    /**
    * Status of Account
    */
    'AccountState': BankAccountDetail.AccountStateEnum;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo': StripeConnectedAccountInfo;
    /**
    * Address lf the bank
    */
    'BankAddress': string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode': string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress': string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode': string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber': string;
    /**
    * Currency of Account
    */
    'CurrencyCode': BankAccountDetail.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds': Array<number>;
    /**
    * Name of Bank
    */
    'BankName': string;
    /**
    * Name of this account
    */
    'AccountName': string;
    /**
    * IBAN of this account
    */
    'Iban': string;
    /**
    * SWIFT of this bank account
    */
    'Swift': string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode': string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields': Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason': string;
    /**
    * Business Type
    */
    'BusinessType': BankAccountDetail.BusinessTypeEnum;
}

export namespace BankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* Represents a request to update bank account information details
*/
export class BankAccountDetailsUpdateRequest {
    /**
    * Address of the bank account
    */
    'BankAddress': string;
    /**
    * Address of the payee
    */
    'AccountHolderAddress': string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber': string;
    /**
    * List of stores to attach to Account
    */
    'StoreIds': Array<number>;
    /**
    * Name of Bank
    */
    'BankName': string;
    /**
    * Name of this account
    */
    'AccountName': string;
    /**
    * IBAN of this account
    */
    'Iban': string;
    /**
    * SWIFT of this bank account
    */
    'Swift': string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode': string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields': Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason': string;
    /**
    * Business Type
    */
    'BusinessType': BankAccountDetailsUpdateRequest.BusinessTypeEnum;
}

export namespace BankAccountDetailsUpdateRequest {
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountSummary {
    /**
    * Id of this account
    */
    'Id': number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames': Array<string>;
    /**
    * Status of Account
    */
    'AccountState': BankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode': string;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo': StripeConnectedAccountInfo;
    /**
    * Name of this account
    */
    'AccountName': string;
    /**
    * IBAN of this account
    */
    'Iban': string;
    /**
    * SWIFT of this bank account
    */
    'Swift': string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode': string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields': Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason': string;
    /**
    * Business Type
    */
    'BusinessType': BankAccountSummary.BusinessTypeEnum;
}

export namespace BankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount': BankAccount;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Status of the bluetooth terminal
*/
export class BluetoothTerminalStatus {
    /**
    * Serial Number
    */
    'SerialNumber': string;
    /**
    * Software Version
    */
    'SoftwareVersion': string;
    /**
    * Device Type
    */
    'DeviceType': BluetoothTerminalStatus.DeviceTypeEnum;
    /**
    * Device Status
    */
    'Status': BluetoothTerminalStatus.StatusEnum;
    /**
    * Indication of the battery level from 0 to 1
    */
    'BatteryLevel': number;
    /**
    * Last time the status was updated
    */
    'UpdateTime': Date;
}

export namespace BluetoothTerminalStatus {
    export enum DeviceTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
    export enum StatusEnum {
        NotConnected = <any> 'Not_Connected',
        Connecting = <any> 'Connecting',
        Connected = <any> 'Connected'
    }
}
/**
* 
*/
export class BusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId': number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType': BusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type': BusinessHoursOverride.TypeEnum;
}

export namespace BusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class BusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType': BusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type': BusinessHoursOverrideBase.TypeEnum;
}

export namespace BusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriod {
    /**
    * Early
    */
    'Early': Range;
    /**
    * Late
    */
    'Late': Range;
    /**
    * Ranges
    */
    'Ranges': Array<Range>;
    /**
    * Day of week
    */
    'DayOfWeek': BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime': string;
    /**
    * Period
    */
    'Period': string;
    /**
    * Start time early
    */
    'StartTimeEarly': string;
    /**
    * Period early
    */
    'PeriodEarly': string;
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek': BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime': string;
    /**
    * Period
    */
    'Period': string;
    /**
    * Start time early
    */
    'StartTimeEarly': string;
    /**
    * Period early
    */
    'PeriodEarly': string;
}

export namespace BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Campaign statistics
*/
export class CampaignStatistics {
    /**
    * Number of issued vouchers
    */
    'VouchersIssued': number;
    /**
    * Number of redeemed vouchers
    */
    'VouchersRedeemed': number;
    /**
    * Conversion percentage of campaign (VouchersIssued / VouchersRedeemed)
    */
    'Conversion': number;
    /**
    * Sales generated by campaign (TotalAmount - FeeChargedToCustomer ie. the discounted sale value)
    */
    'SalesGenerated': number;
    /**
    * Return of investment percentage of campaign (TotalAmount / DiscountAmount)
    */
    'ReturnOfInvestment': number;
}

/**
* The DNS for the Hostname verified
*/
export class CertificateCreatedEvent {
    /**
    * Description
    */
    'Hostname': string;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* The DNS for the Hostname verified
*/
export class CertificateRenewedEvent {
    /**
    * Description
    */
    'Hostname': string;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Change password model
*/
export class ChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;
}

/**
* Chargebacks breakdown
*/
export class ChargebackDetails {
    /**
    * Chargeback amount
    */
    'ChargebackAmount': number;
    /**
    * Chargeback refunded feeds
    */
    'ChargebackRefundedFees': number;
    /**
    * Number of chargebacks
    */
    'ChargebacksCount': number;
    /**
    * Total amount
    */
    'TotalChargebackCost': number;
}

/**
* Coordinates
*/
export class Coordinates {
    /**
    * Latitude
    */
    'Latitude': number;
    /**
    * Longitude
    */
    'Longitude': number;
}

/**
* List of field definitions per country
*/
export class CountryWithAccountFieldsDefinitions {
    /**
    * Country 2-letter ISO code
    */
    'CountryCode': string;
    /**
    * Display name of the country
    */
    'DisplayName': string;
    /**
    * Country support type (supported-by-stripe-cc, supported-by-flipdish,not-supported)
    */
    'SupportType': string;
    /**
    * Bank Account field definitions
    */
    'FieldDefinitions': Array<AccountFieldDefinition>;
}

/**
* Create account model
*/
export class CreateAccountModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId': string;
    /**
    * Referral ID
    */
    'Rid': number;
    /**
    * Campaign ID
    */
    'Cid': string;
}

/**
* Create menu object
*/
export class CreateFullMenu {
    /**
    * Name of Menu, only shown in portal
    */
    'Name': string;
    /**
    * Image url
    */
    'ImageUrl': string;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections': Array<CreateFullMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates': Array<CreateMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks': boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour': CreateFullMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType': CreateFullMenu.TaxTypeEnum;
}

export namespace CreateFullMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Create menu item option set
*/
export class CreateFullMenuItemOptionSet {
    /**
    * Option set items
    */
    'MenuItemOptionSetItems': Array<CreateFullMenuItemOptionSetItem>;
    /**
    * Menu item option set name
    */
    'Name': string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount': number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': CreateFullMenuItemOptionSet.CellLayoutTypeEnum;
}

export namespace CreateFullMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu item option set item
*/
export class CreateFullMenuItemOptionSetItem {
    /**
    * List of metadata
    */
    'Metadata': Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName': string;
    /**
    * Name
    */
    'Name': string;
    /**
    * Price
    */
    'Price': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace CreateFullMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu section
*/
export class CreateFullMenuSection {
    /**
    * Menu section availability
    */
    'MenuSectionAvailability': MenuSectionAvailability;
    /**
    * Menu items
    */
    'MenuItems': Array<CreateFullMenuSectionItem>;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

/**
* Create menu section item
*/
export class CreateFullMenuSectionItem {
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets': Array<CreateFullMenuItemOptionSet>;
    /**
    * List of metadata
    */
    'Metadata': Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName': string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name': string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description': string;
    /**
    * Spiciness rating
    */
    'SpicinessRating': CreateFullMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price': number;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol': boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable': boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': CreateFullMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace CreateFullMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class CreateMenuTaxRate {
    /**
    * Name of Tax Rate
    */
    'Name': string;
    /**
    * In Percentage
    */
    'Rate': number;
}

/**
* Create metadata
*/
export class CreateMetadata {
    /**
    * Store identifier
    */
    'StoreId': number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key': string;
    /**
    * Metadata value
    */
    'Value': string;
}

/**
* 
*/
export class CreateTeammate {
    /**
    * Email address
    */
    'Email': string;
    /**
    * App access level
    */
    'AppAccessLevel': CreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores': boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds': Array<number>;
}

export namespace CreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* Voucher
*/
export class CreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType': CreateVoucher.VoucherTypeEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores': Array<number>;
    /**
    * Add item details
    */
    'AddItemDetails': AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails': CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails': LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails': PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code': string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description': string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver': number;
    /**
    * Takes priority
    */
    'TakesPriority': boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled': boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied': boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders': boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders': boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline': boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash': boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly': boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer': boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce': boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate': Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate': Date;
}

export namespace CreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
}
/**
* Credit note details
*/
export class CreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit': number;
}

export class CspReport {
    'Document-uri': string;
    'Referrer': string;
    'Violated-directive': string;
    'Effective-directive': string;
    'Original-policy': string;
    'Blocked-uri': string;
    'Status-code': number;
}

export class CspReportRequest {
    'Csp-report': CspReport;
}

/**
* A single currency data piece, with no date
*/
export class CurrencyData {
    /**
    * Currency
    */
    'Currency': CurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value': number;
}

export namespace CurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines a customer
*/
export class Customer {
    /**
    * Id of the customer
    */
    'CustomerId': number;
    /**
    * Customer registration date
    */
    'RegistrationDate': Date;
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled': boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled': boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled': boolean;
}

/**
* Customer consent updated
*/
export class CustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Enabled
    */
    'Enabled': boolean;
    /**
    * Description
    */
    'Description': string;
    /**
    * Customer User info
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Customer created event
*/
export class CustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Customer User info
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Defines the order data required for customer driver tracking
*/
export class CustomerDeliveryTrackingOrder {
    /**
    * Order Id
    */
    'OrderId': number;
    /**
    * Pretified address string in country format
    */
    'Address': string;
    /**
    * Delivery Notes
    */
    'DeliveryNotes': string;
    /**
    * Phone number of the store
    */
    'StorePhoneNumber': string;
    /**
    * App Icon of the store
    */
    'AppIconUrl': string;
    /**
    * Order Tracking Code
    */
    'OrderTrackingCode': string;
    /**
    * Payment method description i.e Cash/Card/iDeal/Paypal
    */
    'PaymentMethodDescription': string;
    /**
    * Last 4 digits of the card if applicable otherwise null
    */
    'LastFourDigits': string;
    /**
    * Order lines of the order
    */
    'OrderLines': Array<CustomerDeliveryTrackingOrderLine>;
    /**
    * Total amount for the order including tax
    */
    'TotalAmount': number;
    /**
    * Currency
    */
    'Currency': CustomerDeliveryTrackingOrder.CurrencyEnum;
    /**
    * Customer Location Latitude
    */
    'Latitude': number;
    /**
    * Customer Location Longitude
    */
    'Longitude': number;
    /**
    * Order placed time
    */
    'Placed': Date;
    /**
    * Order requested for
    */
    'RequestedFor': Date;
    /**
    * Driver Id
    */
    'DriverId': number;
    /**
    * Driver Name
    */
    'DriverName': string;
    /**
    * Driver Image
    */
    'DriverImage': string;
    /**
    * 
    */
    'EstimatedMinutesForDelivery': number;
}

export namespace CustomerDeliveryTrackingOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines an order line for driver tracking
*/
export class CustomerDeliveryTrackingOrderLine {
    /**
    * Item name from the order
    */
    'ItemName': string;
    /**
    * Selected option names
    */
    'SelectedOptions': Array<string>;
}

/**
* Customer summary
*/
export class CustomerSummary {
    /**
    * Customer identifier
    */
    'Id': number;
    /**
    * Customer name
    */
    'Name': string;
    /**
    * Customer email address
    */
    'EmailAddress': string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat': string;
    /**
    * Customer phone number
    */
    'PhoneNumber': string;
}

/**
* Defines a customer update model
*/
export class CustomerUpdateModel {
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled': boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled': boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled': boolean;
}

/**
* Customer updated event
*/
export class CustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Customer User info
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Delivery location
*/
export class DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates': Coordinates;
    /**
    * Building
    */
    'Building': string;
    /**
    * Street
    */
    'Street': string;
    /**
    * Town
    */
    'Town': string;
    /**
    * Post code
    */
    'PostCode': string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions': string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString': string;
}

/**
* Delivery Zone
*/
export class DeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id': number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee': number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount': number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText': string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled': boolean;
}

/**
* Delivery Zone Base
*/
export class DeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee': number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount': number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText': string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled': boolean;
}

/**
* Delivery Zone Created Event
*/
export class DeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which created delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone': DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Delivery Zone Deleted Event
*/
export class DeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which deleted delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone': DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Delivery Zone Updated Event
*/
export class DeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which updated delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone': DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Device settings for Hydra
*/
export class DeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;
}

/**
* Holds the information for the A and CNAME Records of a domain.
*/
export class DnsRecordInformation {
    /**
    * indicates whether the CNAME record is ready or not.
    */
    'IsCNameReady': boolean;
    /**
    * indicates whether the A record is ready or not.
    */
    'IsAReady': boolean;
    /**
    * indicates whether the API CNAME record is ready or not.
    */
    'IsApiCNameReady': boolean;
}

/**
* The DNS for the Hostname verified
*/
export class DnsVerifiedEvent {
    /**
    * Description
    */
    'Hostname': string;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class Driver {
    /**
    * User Id
    */
    'UserId': number;
    /**
    * User Name
    */
    'UserName': string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber': string;
    /**
    * 
    */
    'Stores': Array<DriverStore>;
    /**
    * Profile image url
    */
    'ProfileImageUrl': string;
    /**
    * Driver Key
    */
    'DriverKey': string;
}

/**
* 
*/
export class DriverInvitation {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Driver's name
    */
    'Name': string;
    /**
    * Assigned store IDs
    */
    'StoreIds': Array<number>;
}

/**
* Driver Login model
*/
export class DriverLoginModel {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Code
    */
    'Code': string;
}

/**
* Driver Request Login Pin model
*/
export class DriverRequestLoginPinModel {
    /**
    * Email address
    */
    'PhoneNumber': string;
}

/**
* 
*/
export class DriverStore {
    /**
    * Store identifier
    */
    'StoreId': number;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * Presence
    */
    'Presence': DriverStore.PresenceEnum;
}

export namespace DriverStore {
    export enum PresenceEnum {
        Offline = <any> 'Offline',
        Online = <any> 'Online'
    }
}
/**
* Order Terminal Notification
*/
export class EmvNotificationEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Notification Sent
    */
    'Notification': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * TerminalId
    */
    'TerminalId': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Expirey Date
    */
    'ExpDate': string;
    /**
    * Card Type
    */
    'CardType': string;
    /**
    * Payment Method
    */
    'PaymentMethod': string;
    /**
    * Masked Account Number
    */
    'AccountNumber': string;
    /**
    * Auth Code
    */
    'AuthCode': string;
    /**
    * Payment Provider Message
    */
    'ProviderMessage': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* EMV Payment Terminal
*/
export class EmvTerminal {
    /**
    * Flipdish Identifier of Terminal
    */
    'EmvTerminalId': number;
    /**
    * External Identifier of Terminal
    */
    'TerminalId': string;
    /**
    * URL at which terminal can be accessed
    */
    'Url': string;
    /**
    * TOKEN required to access terminal
    */
    'Token': string;
    /**
    * Identifies us to Provider
    */
    'SoftwareHouseId': string;
    /**
    * Identifies installer of terminal
    */
    'InstallerId': string;
}

/**
* EMV Payment Terminal
*/
export class EmvTerminalWithAssignments {
    /**
    * Flipdish Internal identifier of the Terminal
    */
    'EmvTerminalId': string;
    /**
    * External Identifier of the Terminal
    */
    'TerminalId': string;
    /**
    * true if the terminal is assigned to a hydra device (e.g. a kiosk)
    */
    'IsAssignedToHydraDevice': boolean;
    /**
    * hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraConfigId': number;
    /**
    * external hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraDeviceId': string;
    /**
    * hydra device name (null if the terminal is not assigned to any hydra device)
    */
    'HydraName': string;
}

/**
* 
*/
export class EventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent': Array<AppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent': Array<AppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent': Array<AnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent': Array<OrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent': Array<OrderDispatchedEvent>;
    /**
    * Order delivery tracking created events
    */
    'OrderCustomerTrackingCreatedEvent': Array<OrderCustomerTrackingCreatedEvent>;
    /**
    * Order delivery tracking updated events
    */
    'OrderDeliveryTrackingStatusUpdatedEvent': Array<OrderDeliveryTrackingStatusUpdatedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent': Array<OrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent': Array<OrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent': Array<OrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent': Array<OrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent': Array<OrderTipUpdatedEvent>;
    /**
    * Order Terminal Notification events
    */
    'OrderTerminalNotifications': Array<EmvNotificationEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent': Array<StoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent': Array<StoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent': Array<StoreAddressUpdatedEvent>;
    /**
    * Store kiosk setting updated events
    */
    'StoreKioskSettingUpdatedEvent': Array<StoreKioskSettingUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent': Array<DeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent': Array<DeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent': Array<DeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent': Array<StoreOpeningHoursUpdatedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreMenuAssignedEvent': Array<StoreMenuAssignedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent': Array<StoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent': Array<StoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store archived events
    */
    'StoreArchivedEvent': Array<StoreArchivedEvent>;
    /**
    * Store unarchived events
    */
    'StoreUnarchivedEvent': Array<StoreUnarchivedEvent>;
    /**
    * Store published events
    */
    'StorePublishedEvent': Array<StorePublishedEvent>;
    /**
    * Store unpublished events
    */
    'StoreUnpublishedEvent': Array<StoreUnpublishedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent': Array<StoreUpdatedEvent>;
    /**
    * Store updated events
    */
    'StorePreOrderConfigUpdatedEvent': Array<StorePreOrderConfigUpdatedEvent>;
    /**
    * Store logo created events
    */
    'StoreLogoCreatedEvent': Array<StoreLogoCreatedEvent>;
    /**
    * Store logo updated events
    */
    'StoreLogoUpdatedEvent': Array<StoreLogoUpdatedEvent>;
    /**
    * Store logo deleted events
    */
    'StoreLogoDeletedEvent': Array<StoreLogoDeletedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent': Array<MenuCreatedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent': Array<MenuUpdatedEvent>;
    /**
    * Menu uploaded events
    */
    'MenuUploadedEvent': Array<MenuUploadedEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent': Array<MenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent': Array<MenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent': Array<MenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent': Array<MenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent': Array<MenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent': Array<MenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent': Array<MenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent': Array<MenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent': Array<MenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent': Array<MenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent': Array<MenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent': Array<MenuItemOptionSetItemDeletedEvent>;
    /**
    * Menu checkpoint created event
    */
    'MenuCheckpointCreatedEvent': Array<MenuCheckpointCreatedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent': Array<StoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent': Array<StoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent': Array<StoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent': Array<CustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent': Array<CustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent': Array<CustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent': Array<WebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent': Array<WebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent': Array<WebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent': Array<PrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent': Array<PrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent': Array<PrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent': Array<PrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent': Array<PhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent': Array<PhoneCallEndedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent': Array<LoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent': Array<LoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent': Array<LoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent': Array<RetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent': Array<RetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent': Array<RetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent': Array<SmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent': Array<UserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent': Array<UserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent': Array<UserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent': Array<UserDeletedEvent>;
    /**
    * User password created event
    */
    'UserCreatedPasswordEvent': Array<UserPasswordCreatedEvent>;
    /**
    * User answered signup questions event
    */
    'UserAnsweredSignupQuestionsEvent': Array<UserAnsweredSignupQuestionsEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent': Array<VoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent': Array<VoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent': Array<VoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent': Array<TeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent': Array<TeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent': Array<TeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent': Array<TeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent': Array<BankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent': Array<BankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent': Array<BankAccountDeletedEvent>;
    /**
    * Hydra assigned event
    */
    'HydraAssignedEvent': Array<HydraAssignedEvent>;
    /**
    * Hydra reset requested event
    */
    'HydraRequestResetEvent': Array<HydraRequestResetEvent>;
    /**
    * Hydra store assigned event
    */
    'HydraStoreAssignedEvent': Array<HydraStoreAssignedEvent>;
    /**
    * Hydra store unassigned
    */
    'HydraStoreUnassignedEvent': Array<HydraStoreUnassignedEvent>;
    /**
    * Hydra settings changed event
    */
    'HydraSettingChangedEvent': Array<HydraSettingChangedEvent>;
    /**
    * Hydra un-assigned event
    */
    'HydraUnAssignedEvent': Array<HydraUnAssignedEvent>;
    /**
    * Hydra connection state change
    */
    'HydraConnectionStatusChangedEvent': Array<HydraConnectionStatusChangedEvent>;
    /**
    * Bluetooth Pairing Mode initiated
    */
    'KioskBluetoothPairingModeEvent': Array<KioskBluetoothPairingModeEvent>;
    /**
    * Bluetooth Unpairing Mode initiated
    */
    'KioskBluetoothUnpairingModeEvent': Array<KioskBluetoothUnpairingModeEvent>;
    /**
    * Bluetooth Terminal Updated
    */
    'KioskBluetoothTerminalUpdatedEvent': Array<KioskBluetoothTerminalUpdatedEvent>;
    /**
    * Trigger bluetooth payment terminal update checker
    */
    'KioskBluetoothTerminalInitiateUpdateCheckEvent': Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>;
    /**
    * Bluetooth Terminal Initiate Update
    */
    'KioskBluetoothInstallUpdateInitiateEvent': Array<KioskBluetoothInstallUpdateInitiateEvent>;
    /**
    * Push notification scheduled event
    */
    'PushNotificationScheduledEvent': Array<PushNotificationScheduledEvent>;
    /**
    * Push notification sent event
    */
    'PushNotificationSentEvent': Array<PushNotificationSentEvent>;
    /**
    * Push notification deleted event
    */
    'PushNotificationDeletedEvent': Array<PushNotificationDeletedEvent>;
    /**
    * DNS Verified
    */
    'DnsVerifiedEvent': Array<DnsVerifiedEvent>;
    /**
    * Certificate created
    */
    'CertificateCreatedEvent': Array<CertificateCreatedEvent>;
    /**
    * Certificate renewed
    */
    'CertificateRenewedEvent': Array<CertificateRenewedEvent>;
    /**
    * Panacea vanity url updated
    */
    'WebsiteVanityUrlUpdatedEvent': Array<WebsiteVanityUrlUpdatedEvent>;
    /**
    * Website updated
    */
    'WebsiteUpdatedEvent': Array<WebsiteUpdatedEvent>;
    /**
    * Order capacity config updated
    */
    'OrderCapacityUpdatedEvent': Array<OrderCapacityUpdatedEvent>;
}

/**
* Fee Summary
*/
export class FeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount': number;
    /**
    * Percentage rate
    */
    'PercentageRate': number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee': number;
}

/**
* Base Event
*/
export class FlipdishEventBase {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Fees breakdown
*/
export class FlipdishFeesDetails {
    /**
    * Fees on online sales
    */
    'OnlineSalesFees': number;
    /**
    * Fees on cash sales
    */
    'CashSalesFees': number;
    /**
    * Total online and cash sales
    */
    'TotalSalesFees': number;
    /**
    * Fees on refunds for online sales
    */
    'OnlineSalesRefundedFees': number;
    /**
    * Fees on refunds for cash sales
    */
    'CashSalesRefundedFees': number;
    /**
    * VAT on sales fees
    */
    'SalesFeesVat': number;
    /**
    * Total fees
    */
    'TotalFees': number;
}

/**
* Describes coordinates that have a group
*/
export class GroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude': number;
    /**
    * Longitude of this coordinate
    */
    'Longitude': number;
    /**
    * Count of members in the group
    */
    'Count': number;
}

/**
* 
*/
export class HomeAction {
    /**
    * 
    */
    'HomeActionId': number;
    /**
    * Type of Action
    */
    'HomeActionType': HomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order': number;
    /**
    * 
    */
    'TitleKey': string;
    /**
    * 
    */
    'ActionKey': string;
    /**
    * 
    */
    'DescriptionKey': string;
    /**
    * 
    */
    'Action': string;
    /**
    * 
    */
    'Dismissible': boolean;
}

export namespace HomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class HomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved': Array<CurrencyData>;
}

/**
* Http Request and Response Log
*/
export class HttpRequestAndResponseLog {
    /**
    * Id of the log
    */
    'Guid': string;
    /**
    * Verb associated with the HTTP call.
    */
    'Verb': string;
    /**
    * Http request URI.
    */
    'RequestUri': string;
    /**
    * Http response status code.
    */
    'StatusCode': number;
    /**
    * Http response status line.
    */
    'ReasonPhrase': string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds': number;
    /**
    * Identity of the caller.
    */
    'UserId': string;
    /**
    * Ip address of the caller
    */
    'IpAddress': string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime': string;
    /**
    * Http request headers.
    */
    'RequestHeaders': { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody': string;
    /**
    * Http request content-length
    */
    'RequestLength': number;
    /**
    * Http response headers.
    */
    'ResponseHeaders': { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody': string;
    /**
    * Http response content-length
    */
    'ResponseLength': number;
}

/**
* Hydra assigned event
*/
export class HydraAssignedEvent {
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus': HydraStatus;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Hydra configuration
*/
export class HydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': HydraConfig.Array<PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': DeviceSettings;
    /**
    * Version of the device
    */
    'Version': string;
    /**
    * Build number of the device
    */
    'BuildNumber': string;
    /**
    * SHA of the commit
    */
    'GitSha': string;
    /**
    * Build branch
    */
    'GitBranch': string;
}

export namespace HydraConfig {
    export enum Array&lt;PaymentOptionsEnum&gt; {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hydra Connection Status Changed Event
*/
export class HydraConnectionStatusChangedEvent {
    /**
    * Hydra Device Id
    */
    'DeviceId': string;
    /**
    * Hydra Device Status
    */
    'HydraDeviceStatus': HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum;
    /**
    * Hydra Last Poll Time
    */
    'PollTime': Date;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace HydraConnectionStatusChangedEvent {
    export enum HydraDeviceStatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra device details
*/
export class HydraDeviceDetails {
    /**
    * Flipdish internal device identifier
    */
    'HydraConfigId': number;
    /**
    * Device Id or Serial Number
    */
    'DeviceId': string;
    /**
    * Type of the device
    */
    'DeviceType': HydraDeviceDetails.DeviceTypeEnum;
    /**
    * Status of the device
    */
    'Status': HydraDeviceDetails.StatusEnum;
    /**
    * Device Name
    */
    'DeviceName': string;
    /**
    * Store Names
    */
    'StoreNames': Array<HydraStoreData>;
    /**
    * Last poll time in UTC
    */
    'LastPollUtc': Date;
    /**
    * Version of the device
    */
    'Version': string;
    /**
    * Build number of the device
    */
    'BuildNumber': string;
    /**
    * SHA of the commit
    */
    'GitSha': string;
    /**
    * Build branch
    */
    'GitBranch': string;
}

export namespace HydraDeviceDetails {
    export enum DeviceTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
    export enum StatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra registration result
*/
export class HydraRegistrationRequest {
    /**
    * Stores to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode': number;
}

/**
* Hydra request reset event
*/
export class HydraRequestResetEvent {
    /**
    * User who initiated the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Hydra settings changed
*/
export class HydraSettingChangedEvent {
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * Hydra configuration
    */
    'HydraConfig': HydraConfig;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Hydra status
*/
export class HydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode': number;
    /**
    * Hydra images (covers)
    */
    'Images': Array<string>;
    /**
    * Hydra User Type
    */
    'UserType': HydraStatus.UserTypeEnum;
}

export namespace HydraStatus {
    export enum UserTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
}
/**
* Hydra store\\s assigned event
*/
export class HydraStoreAssignedEvent {
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * Store\\s to assign hydra to
    */
    'StoreIds': Array<number>;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Data
*/
export class HydraStoreData {
    /**
    * Id of the store
    */
    'StoreId': number;
    /**
    * Name of the store
    */
    'StoreName': string;
}

/**
* Hydra store\\s unassigned event
*/
export class HydraStoreUnassignedEvent {
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * Store\\s to unassign hydra from
    */
    'StoreIds': Array<number>;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Hydra unassigned event
*/
export class HydraUnAssignedEvent {
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus': HydraStatus;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Index Page
*/
export class IndexPage {
    /**
    * Testimonials
    */
    'Testimonials': Array<WebsiteTestimonial>;
    /**
    * Images
    */
    'Images': Array<WebsiteImage>;
    /**
    * About section enabled
    */
    'AboutSectionEnabled': boolean;
    /**
    * About section title
    */
    'AboutSectionTitle': string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle': string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle': string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody': string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle': string;
    /**
    * About section text right
    */
    'AboutSectionRightBody': string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled': boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled': boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled': boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled': boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled': boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail': string;
    /**
    * Map section Enabled
    */
    'MapEnabled': boolean;
}

/**
* Base of Index Page
*/
export class IndexPageBase {
    /**
    * About section enabled
    */
    'AboutSectionEnabled': boolean;
    /**
    * About section title
    */
    'AboutSectionTitle': string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle': string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle': string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody': string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle': string;
    /**
    * About section text right
    */
    'AboutSectionRightBody': string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled': boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled': boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled': boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled': boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled': boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail': string;
    /**
    * Map section Enabled
    */
    'MapEnabled': boolean;
}

/**
* Job Address
*/
export class JobAddress {
    /**
    * Street
    */
    'Street': string;
    /**
    * Postcode
    */
    'Postcode': string;
    /**
    * City
    */
    'City': string;
    /**
    * Country
    */
    'Country': string;
    /**
    * Zone
    */
    'Zone': string;
    /**
    * Formatted Address
    */
    'FormattedAddress': string;
}

/**
* Job Cancellation
*/
export class JobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy': string;
    /**
    * Reason Key
    */
    'ReasonKey': string;
    /**
    * Comment
    */
    'Comment': string;
}

/**
* Job Contact
*/
export class JobContact {
    /**
    * Firstname
    */
    'Firstname': string;
    /**
    * Lastname
    */
    'Lastname': string;
    /**
    * Phone
    */
    'Phone': string;
    /**
    * Email
    */
    'Email': string;
    /**
    * Company
    */
    'Company': string;
    /**
    * Company Name
    */
    'CompanyName': string;
}

/**
* Job Delivery
*/
export class JobDelivery {
    /**
    * Id
    */
    'Id': number;
    /**
    * Status
    */
    'Status': string;
    /**
    * Picked At
    */
    'PickedAt': string;
    /**
    * Delivered At
    */
    'DeliveredAt': string;
    /**
    * Tracking Url
    */
    'TrackingUrl': string;
    /**
    * Client Reference
    */
    'ClientReference': string;
    /**
    * Package Description
    */
    'PackageDescription': string;
    /**
    * Package Type
    */
    'PackageType': string;
    /**
    * Pickup
    */
    'Pickup': JobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff': JobDeliveryDetail;
    /**
    * Eta
    */
    'Eta': JobEta;
    /**
    * Cancellation
    */
    'Cancellation': JobCancellation;
    /**
    * Proof
    */
    'Proof': JobProof;
}

/**
* Job Delivery Detail
*/
export class JobDeliveryDetail {
    /**
    * Id
    */
    'Id': number;
    /**
    * Latitude
    */
    'Latitude': number;
    /**
    * Longitude
    */
    'Longitude': number;
    /**
    * Comment
    */
    'Comment': string;
    /**
    * Address
    */
    'Address': JobAddress;
    /**
    * Contact
    */
    'Contact': JobContact;
}

/**
* Job Driver
*/
export class JobDriver {
    /**
    * Id
    */
    'Id': number;
    /**
    * Display Name
    */
    'DisplayName': string;
    /**
    * Phone
    */
    'Phone': string;
    /**
    * Picture Url
    */
    'PictureUrl': string;
    /**
    * Transport Type
    */
    'TransportType': string;
    /**
    * Latitude
    */
    'Latitude': number;
    /**
    * Longitude
    */
    'Longitude': number;
}

/**
* Job Eta
*/
export class JobEta {
    /**
    * Pickup
    */
    'Pickup': string;
    /**
    * Dropoff
    */
    'Dropoff': string;
}

/**
* Job Pricing
*/
export class JobPricing {
    /**
    * Currency
    */
    'Currency': string;
    /**
    * Tax Percentage
    */
    'TaxPercentage': number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded': number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded': number;
    /**
    * Tax Amount
    */
    'TaxAmount': number;
    /**
    * Invoice Url
    */
    'InvoiceUrl': string;
}

/**
* Job Proof
*/
export class JobProof {
    /**
    * Signature Url
    */
    'SignatureUrl': string;
}

/**
* Job Response
*/
export class JobResponse {
    /**
    * Id
    */
    'Id': number;
    /**
    * Created At
    */
    'CreatedAt': Date;
    /**
    * Status
    */
    'Status': string;
    /**
    * Package Type
    */
    'PackageType': string;
    /**
    * Transport Type
    */
    'TransportType': string;
    /**
    * Assignment Code
    */
    'AssignmentCode': string;
    /**
    * Pickup At
    */
    'PickupAt': string;
    /**
    * Dropoff At
    */
    'DropoffAt': string;
    /**
    * Comment
    */
    'Comment': string;
    /**
    * Distance
    */
    'Distance': number;
    /**
    * Duration
    */
    'Duration': number;
    /**
    * Deliveries
    */
    'Deliveries': Array<JobDelivery>;
    /**
    * Pricing
    */
    'Pricing': JobPricing;
    /**
    * Driver
    */
    'Driver': JobDriver;
}

/**
* Kiosk bluetooth Initiate Install Update Event
*/
export class KioskBluetoothInstallUpdateInitiateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId': string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType': KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace KioskBluetoothInstallUpdateInitiateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk Bluetooth Pairing mode initiated
*/
export class KioskBluetoothPairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId': string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType': KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace KioskBluetoothPairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk bluetooth trigger update check event
*/
export class KioskBluetoothTerminalInitiateUpdateCheckEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId': string;
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Kiosk bluetooth terminal unpaired
*/
export class KioskBluetoothTerminalUpdatedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId': string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType': KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber': string;
    /**
    * Status of the connected terminal
    */
    'BluetoothTerminalStatus': BluetoothTerminalStatus;
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace KioskBluetoothTerminalUpdatedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothUnpairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId': string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType': KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace KioskBluetoothUnpairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3'
    }
}
/**
* Sorted Language
*/
export class Language {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId': string;
    /**
    * Display Order
    */
    'DisplayOrder': number;
    /**
    * Language Name
    */
    'Name': string;
}

/**
* Ligthspeed store settings
*/
export class LightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId': string;
    /**
    * Use OAuth for authentication
    */
    'UseOAuth': boolean;
    /**
    * Enabled
    */
    'Enabled': boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery': number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection': number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation': string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment': boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId': string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId': string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId': string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType': LightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId': number;
    /**
    * Collection Table ID to send orders
    */
    'CollectionTableId': number;
    /**
    * Delivery Table ID to send orders
    */
    'DeliveryTableId': number;
    /**
    * Collection Table IDs to send orders to
    */
    'CollectionTableIds': { [key: string]: string; };
    /**
    * Delivery Table IDs to send orders to
    */
    'DeliveryTableIds': { [key: string]: string; };
    /**
    * Exclude tax
    */
    'UseTaxInclusivePrices': boolean;
    /**
    * WARNING: only use this option if the Liteserver is not synchronizing within max 5 minutes with Lightspeed cloud!
    */
    'SkipStatusCheckAndAcceptOrderAfterSending': boolean;
}

export namespace LightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Represents a localised time zone
*/
export class LocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId': string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId': string;
    /**
    * Display name in users language
    */
    'DisplayName': string;
}

/**
* Login model
*/
export class LoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;
}

/**
* Login with PIN model
*/
export class LoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;
}

/**
* Loyalty campaign
*/
export class LoyaltyCampaign {
    /**
    * Id of campaign
    */
    'CampaignId': number;
    /**
    * Statistics of campaign
    */
    'Statistics': CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores': Array<StoreCampaignStartTime>;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher': number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount': number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays': number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers': boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders': boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled': boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds': Array<number>;
}

/**
* Loyalty campaign base
*/
export class LoyaltyCampaignBase {
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher': number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount': number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays': number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers': boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders': boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled': boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds': Array<number>;
}

/**
* Loyalty campaign created event
*/
export class LoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign': LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Loyalty campaign deleted event
*/
export class LoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign': LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Loyalty campaign updated event
*/
export class LoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign': LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Lump discount details
*/
export class LumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount': number;
}

/**
* Represents a masked phone number
*/
export class MaskedPhoneNumber {
    /**
    * Defines if the feature is enabled
    */
    'IsEnabled': boolean;
    /**
    * Defines the phone number to call
    */
    'PhoneNumber': string;
    /**
    * Defines the code to enter
    */
    'Code': string;
}

/**
* Menu
*/
export class Menu {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Last modified time
    */
    'ModifiedTime': Date;
    /**
    * Menu version
    */
    'VersionNumber': number;
    /**
    * Image url
    */
    'ImageUrl': string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name': string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked': boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections': Array<MenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates': Array<MenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks': boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour': Menu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType': Menu.TaxTypeEnum;
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu base
*/
export class MenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks': boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour': MenuBase.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType': MenuBase.TaxTypeEnum;
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu Checkpoint
*/
export class MenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId': number;
    /**
    * Time of creation of checkpoint
    */
    'Time': Date;
    /**
    * Name of checkpoint
    */
    'Name': string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url': string;
}

/**
* 
*/
export class MenuCheckpointCreatedEvent {
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Menu identifier
    */
    'Menu': Menu;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu created event
*/
export class MenuCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * The menu
    */
    'Menu': Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementEditResponse {
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId': number;
    /**
    * Type of menu element
    */
    'MenuElementType': MenuElementEditResponse.MenuElementTypeEnum;
    /**
    * Validation message for menu element issue
    */
    'ValidationCode': MenuElementEditResponse.ValidationCodeEnum;
}

export namespace MenuElementEditResponse {
    export enum MenuElementTypeEnum {
        MenuItem = <any> 'MenuItem',
        MenuOptionSetItem = <any> 'MenuOptionSetItem'
    }
    export enum ValidationCodeEnum {
        Success = <any> 'Success',
        MinimumCountViolation = <any> 'MinimumCountViolation'
    }
}
/**
* Menu element hide
*/
export class MenuElementHide {
    /**
    * id of the menu item or menu option set item
    */
    'MenuElementId': number;
    /**
    * Type of menu element
    */
    'MenuElementType': MenuElementHide.MenuElementTypeEnum;
}

export namespace MenuElementHide {
    export enum MenuElementTypeEnum {
        MenuItem = <any> 'MenuItem',
        MenuOptionSetItem = <any> 'MenuOptionSetItem'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId': number;
    /**
    * Image url
    */
    'ImageUrl': string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems': Array<MenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId': string;
    /**
    * Menu item option set name
    */
    'Name': string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount': number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuItemOptionSet.CellLayoutTypeEnum;
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name': string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount': number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuItemOptionSetBase.CellLayoutTypeEnum;
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet': MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet': MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu item option set item
*/
export class MenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId': number;
    /**
    * Permanent reference to the item.
    */
    'PublicId': string;
    /**
    * List of metadata
    */
    'Metadata': Array<CreateMetadata>;
    /**
    * Name
    */
    'Name': string;
    /**
    * Price
    */
    'Price': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class MenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name': string;
    /**
    * Price
    */
    'Price': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder': number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuItemOptionSetItemBase.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem': MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem': MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem': MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet': MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Collection of Display Orders for a Menu Object (Menu Section / Menu Items / Option Sets etc)
*/
export class MenuObjectDisplayOrders {
    /**
    * List of Objects and their new Display Orders
    */
    'DisplayOrders': Array<ObjectDisplayOrder>;
}

/**
* Menu section
*/
export class MenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId': number;
    /**
    * Menu items
    */
    'MenuItems': Array<MenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability': MenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId': string;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

/**
* Menu section availability
*/
export class MenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes': Array<BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode': MenuSectionAvailability.AvailabilityModeEnum;
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class MenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode': MenuSectionAvailabilityBase.AvailabilityModeEnum;
}

export namespace MenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class MenuSectionBase {
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

/**
* 
*/
export class MenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection': MenuSection;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection': MenuSection;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu item
*/
export class MenuSectionItem {
    /**
    * Menu item identifier. This ID may change at any time. Use `PublicId` if you need a perminant reference to the item.
    */
    'MenuItemId': number;
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice': number;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets': Array<MenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours': Array<BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId': string;
    /**
    * List of metadata
    */
    'Metadata': Array<CreateMetadata>;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name': string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description': string;
    /**
    * Spiciness rating
    */
    'SpicinessRating': MenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price': number;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol': boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable': boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class MenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name': string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description': string;
    /**
    * Spiciness rating
    */
    'SpicinessRating': MenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price': number;
    /**
    * Display order
    */
    'DisplayOrder': number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol': boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable': boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType': MenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers': boolean;
    /**
    * Image url
    */
    'ImageUrl': string;
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has created the menu
    */
    'User': UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem': MenuSectionItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Event description
    */
    'Description': string;
    /**
    * Deleted by user
    */
    'User': UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem': MenuSectionItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Event description
    */
    'Description': string;
    /**
    * Updated by user
    */
    'User': UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem': MenuSectionItem;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class MenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Event description
    */
    'Description': string;
    /**
    * Updated by user
    */
    'User': UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection': MenuSection;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu Store Names
*/
export class MenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames': Array<string>;
}

/**
* Menu Summary
*/
export class MenuSummary {
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Last modified time
    */
    'ModifiedTime': Date;
    /**
    * Menu version
    */
    'VersionNumber': number;
    /**
    * Name of Menu, only shown in portal
    */
    'Name': string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked': boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames': Array<string>;
}

/**
* Tax information for Menu
*/
export class MenuTaxDetails {
    /**
    * Tax Rates
    */
    'TaxRates': Array<MenuTaxRate>;
    /**
    * Display tax for Menu
    */
    'DisplayTax': boolean;
    /**
    * TaxType
    */
    'TaxType': MenuTaxDetails.TaxTypeEnum;
    /**
    * ItemIds and TaxIds
    */
    'ItemTaxes': { [key: string]: number; };
    /**
    * SetItemIds and TaxIds
    */
    'SetItemTaxes': { [key: string]: number; };
}

export namespace MenuTaxDetails {
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class MenuTaxRate {
    /**
    * Id of Tax Rate
    */
    'TaxRateId': number;
    /**
    * Name of Tax Rate
    */
    'Name': string;
    /**
    * In Percentage
    */
    'Rate': number;
}

/**
* Menu updated event
*/
export class MenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has updated the menu
    */
    'User': UserEventInfo;
    /**
    * The menu
    */
    'Menu': Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu uploaded event
*/
export class MenuUploadedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has uploaded the menu
    */
    'User': UserEventInfo;
    /**
    * The menu
    */
    'Menu': Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Metadata
*/
export class Metadata {
    /**
    * Menu entity identifier (eg: MenuItemId, MenuItemOptionSetItemId)
    */
    'MenuEntityId': number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key': string;
    /**
    * Metadata value
    */
    'Value': string;
}

/**
* Oauth client (also knowns as 'app')
*/
export class OAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId': string;
    /**
    * OAuth App Name
    */
    'OauthAppName': string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId': number;
    /**
    * OAuth App logo uri
    */
    'LogoUri': string;
    /**
    * Supported OpenID Connect flows
    */
    'Flow': OAuthApp.FlowEnum;
    /**
    * ReUse: the refresh token handle will stay the same when refreshing tokens   OneTime: the refresh token handle will be updated when refreshing tokens
    */
    'RefreshTokenUsage': OAuthApp.RefreshTokenUsageEnum;
    /**
    * Timem it takes for the IdentityToken to expire in seconds
    */
    'AccessTokenLifetime': number;
    /**
    * Maximum lifetime of a refresh token in seconds
    */
    'AbsoluteRefreshTokenLifetime': number;
}

export namespace OAuthApp {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        Hybrid = <any> 'Hybrid',
        ClientCredentials = <any> 'ClientCredentials'
    }
    export enum RefreshTokenUsageEnum {
        ReUse = <any> 'ReUse',
        OneTimeOnly = <any> 'OneTimeOnly'
    }
}
/**
* OAuth token model
*/
export class OAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key': string;
    /**
    * Token type
    */
    'TokenType': string;
    /**
    * Oauth subject identifier
    */
    'SubjectId': string;
    /**
    * Oauth client identifier
    */
    'ClientId': string;
    /**
    * Token expiry
    */
    'Expiry': Date;
}

/**
* OAuth client redirect uri
*/
export class OauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id': number;
    /**
    * Redirect uri
    */
    'Uri': string;
}

/**
* 
*/
export class ObjectDisplayOrder {
    /**
    * ID of object to be ordered
    */
    'Id': number;
    /**
    * New Display order
    */
    'DisplayOrder': number;
}

/**
* Order
*/
export class Order {
    /**
    * Store summary
    */
    'Store': StoreSummary;
    /**
    * Customer summary
    */
    'Customer': CustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher': OrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees': FeeSummary;
    /**
    * Ordered items
    */
    'OrderItems': Array<OrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation': DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation': Coordinates;
    /**
    * Represents customers masked phone number
    */
    'MaskedPhoneNumber': MaskedPhoneNumber;
    /**
    * Represents table service drop off location
    */
    'DropOffLocationId': number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation': string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor': Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone': boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder': boolean;
    /**
    * Id of user who rejected order, if available
    */
    'RejectedByUserId': number;
    /**
    * Order identifier
    */
    'OrderId': number;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId': string;
    /**
    * Delivery type
    */
    'DeliveryType': Order.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType': Order.PickupLocationTypeEnum;
    /**
    * Pickup location type
    */
    'TableServiceCatagory': Order.TableServiceCatagoryEnum;
    /**
    * Tip amount
    */
    'TipAmount': number;
    /**
    * Delivery amount
    */
    'DeliveryAmount': number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount': number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount': number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee': number;
    /**
    * Payment account type
    */
    'PaymentAccountType': Order.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription': string;
    /**
    * Order state
    */
    'OrderState': Order.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder': boolean;
    /**
    * Order placed time
    */
    'PlacedTime': Date;
    /**
    * Order requested for
    */
    'RequestedForTime': Date;
    /**
    * Chef note
    */
    'ChefNote': string;
    /**
    * Used app type
    */
    'AppType': Order.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating': number;
    /**
    * Status of the payment
    */
    'PaymentStatus': Order.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason': Order.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount': number;
    /**
    * Delivery tracking status
    */
    'DeliveryTrackingStatus': Order.DeliveryTrackingStatusEnum;
    /**
    * Assigned driver identifier
    */
    'DriverId': number;
    /**
    * Total tax applied to order
    */
    'TotalTax': number;
    /**
    * Unique, 6 character long alpha numeric code for tracking.
    */
    'OrderTrackingCode': string;
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
    export enum DeliveryTrackingStatusEnum {
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Accepted Event
*/
export class OrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime': Date;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store's Order Capacity Configuration Updated
*/
export class OrderCapacityUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Id of the store whose order capacity configuration has been updated
    */
    'StoreId': number;
    /**
    * User which updated order capacity configuration for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated order capacity configuration
    */
    'OrderCapacityConfig': StoreOrderCapacityConfigEditModel;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Order Created Event
*/
export class OrderCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime': Date;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class OrderCustomerTrackingCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order
    */
    'Order': CustomerDeliveryTrackingOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class OrderDeliveryTrackingStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Order Dispatched Event
*/
export class OrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime': Date;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class OrderIdAndSequenceNumber {
    /**
    * Order identifier
    */
    'OrderId': number;
    /**
    * Sequence for delivery
    */
    'Sequence': number;
}

/**
* Order item
*/
export class OrderItem {
    /**
    * Option list
    */
    'OrderItemOptions': Array<OrderItemOption>;
    /**
    * Metadata
    */
    'Metadata': { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId': string;
    /**
    * Menu section name
    */
    'MenuSectionName': string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder': number;
    /**
    * Name
    */
    'Name': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Price
    */
    'Price': number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems': number;
    /**
    * Menu item identifier
    */
    'MenuItemId': number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder': number;
    /**
    * Is available
    */
    'IsAvailable': boolean;
}

/**
* Order item option
*/
export class OrderItemOption {
    /**
    * Metadata
    */
    'Metadata': { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId': string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId': number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem': boolean;
    /**
    * Name
    */
    'Name': string;
    /**
    * Price
    */
    'Price': number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder': number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder': number;
}

/**
* Order Payment Information
*/
export class OrderPaymentInformation {
    /**
    * ID of the Order
    */
    'OrderId': number;
    /**
    * Signifies if the payment is refundable
    */
    'PaymentRefundable': boolean;
}

/**
* Order Rating Update Event
*/
export class OrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * New User Rating
    */
    'Rating': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Order Refunded Event
*/
export class OrderRefundedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The amount refunded
    */
    'RefundedAmount': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Order Rejected Event
*/
export class OrderRejectedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime': Date;
    /**
    * Reason for Rejection
    */
    'Reason': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Order summary
*/
export class OrderSummary {
    /**
    * Order identifier
    */
    'OrderId': number;
    /**
    * Delivery type
    */
    'DeliveryType': OrderSummary.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType': OrderSummary.PickupLocationTypeEnum;
    /**
    * Table service category
    */
    'TableServiceCatagory': OrderSummary.TableServiceCatagoryEnum;
    /**
    * Order state
    */
    'OrderState': OrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime': Date;
    /**
    * Name of the store
    */
    'StoreName': string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone': string;
    /**
    * Name of the customer
    */
    'CustomerName': string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber': string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount': number;
    /**
    * Refunded amount
    */
    'RefundedAmount': number;
    /**
    * Payment Account
    */
    'PaymentAccountType': OrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus': OrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency': OrderSummary.CurrencyEnum;
    /**
    * Type of app end user is on
    */
    'AppType': OrderSummary.AppTypeEnum;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId': string;
    /**
    * id of the collection/drop off location
    */
    'DropOffLocationId': number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation': string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor': Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone': boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder': boolean;
}

export namespace OrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
}
/**
* Order Tip Update Event
*/
export class OrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Tip Amount
    */
    'TipAmount': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * Order
    */
    'Order': Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Voucher summary
*/
export class OrderVoucherSummary {
    /**
    * Voucher name
    */
    'Name': string;
    /**
    * Voucher description
    */
    'Description': string;
    /**
    * Voucher code
    */
    'Code': string;
    /**
    * Voucher amount
    */
    'Amount': number;
    /**
    * Voucher type
    */
    'Type': OrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType': OrderVoucherSummary.SubTypeEnum;
}

export namespace OrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Breakdown of other charges
*/
export class OtherChargesDetails {
    /**
    * Total amount of other charges
    */
    'TotalOtherCharges': number;
    /**
    * Number of other charges
    */
    'ChargesCount': number;
}

/**
* Password reset model
*/
export class PasswordResetModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token': string;
}

/**
* Details of Payment Terminal
*/
export class PaymentTerminalDetails {
    /**
    * Terminal Id (tid)
    */
    'TerminalId': string;
    /**
    * Status of Terminal
    */
    'Status': string;
    /**
    * Currency configured on the terminal
    */
    'Currency': string;
    /**
    * Location to Device
    */
    'Uri': string;
}

/**
* Details of Payment Terminal Transaction
*/
export class PaymentTerminalTransactionDetails {
    /**
    * Card Type
    */
    'CardSchemeName': string;
    /**
    * Expirey Date on Card
    */
    'DateOfExpiry': string;
    /**
    * AuthCode
    */
    'AuthCode': string;
    /**
    * State of Request, \"PENDING\" is not yet completed
    */
    'TransactionResult': string;
    /**
    * Masked PAN
    */
    'PrimaryAccountNumber': string;
    /**
    * Type of Verification.
    */
    'CardholderVerificationMethod': string;
}

/**
* Holds the information for a whitelabel payout.
*/
export class Payout {
    /**
    * The id of the payout.
    */
    'PayoutId': number;
    /**
    * Bank account identifier
    */
    'PayeeBankAccountId': number;
    /**
    * Account name of the payout destination
    */
    'AccountName': string;
    /**
    * Status of the payout
    */
    'PayoutStatus': Payout.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate': Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime': Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime': Date;
    /**
    * Destination bank name
    */
    'DestinationBank': string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount': string;
    /**
    * Payout amount
    */
    'Amount': number;
    /**
    * Type of payout source
    */
    'PayoutType': Payout.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency': Payout.CurrencyEnum;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate': Date;
}

export namespace Payout {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a chargeback related to a payout
*/
export class PayoutChargeback {
    /**
    * The id of the order the chargeback was for
    */
    'OrderId': number;
    /**
    * Order currency
    */
    'OrderCurrency': PayoutChargeback.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId': number;
    /**
    * The date the order was placed
    */
    'OrderDate': Date;
    /**
    * Order type (online or cash)
    */
    'OrderType': PayoutChargeback.OrderTypeEnum;
    /**
    * The date the chargeback was done
    */
    'ChargebackDate': Date;
    /**
    * Store id
    */
    'StoreId': number;
    /**
    * Chargeback amount
    */
    'ChargebackAmount': number;
    /**
    * Amount of refunded fees
    */
    'RefundedFees': number;
}

export namespace PayoutChargeback {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Holds the information for a whitelabel payout with details broken down by Store
*/
export class PayoutDetail {
    /**
    * The id of the payout.
    */
    'PayoutId': number;
    /**
    * Bank account identifier
    */
    'BankAccountId': number;
    /**
    * Account name of the payout destination
    */
    'AccountName': string;
    /**
    * Status of the payout
    */
    'PayoutStatus': PayoutDetail.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate': Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime': Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime': Date;
    'DestinationBank': string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount': string;
    /**
    * Type of payout source
    */
    'PayoutType': PayoutDetail.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency': PayoutDetail.CurrencyEnum;
    /**
    * Payout information broken down by Store
    */
    'PayoutStores': Array<PayoutStore>;
    /**
    * Payout amount
    */
    'Amount': number;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate': Date;
}

export namespace PayoutDetail {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for an order related to a payout
*/
export class PayoutOrder {
    /**
    * The id of the order
    */
    'OrderId': number;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId': number;
    /**
    * The date the order was placed
    */
    'OrderDate': Date;
    /**
    * Order type (online or cash)
    */
    'OrderType': PayoutOrder.OrderTypeEnum;
    /**
    * Order currency
    */
    'OrderCurrency': PayoutOrder.OrderCurrencyEnum;
    /**
    * Order sales amount
    */
    'Sales': number;
    /**
    * Order sales tax amount
    */
    'SalesTax': number;
    /**
    * Order delivery charges
    */
    'DeliveryCharges': number;
    /**
    * Order tips amount
    */
    'Tips': number;
    /**
    * Order voucher amount
    */
    'Voucher': number;
    /**
    * Order flat fee amount excluding VAT
    */
    'FlatFeeExcludingVat': number;
    'FlatFeeExcludingVAT': number;
    /**
    * Order percentage fee excluding VAT
    */
    'PercentageFeeExcludingVat': number;
    'PercentageFeeExcludingVAT': number;
    /**
    * Order VAT amount
    */
    'Vat': number;
    /**
    * Total order fees amount
    */
    'TotalFees': number;
    /**
    * Cash fee charged to customer
    */
    'CashFeeChargedToCustomer': number;
    /**
    * Order net sales amount
    */
    'NetSales': number;
    /**
    * Store id
    */
    'StoreId': number;
}

export namespace PayoutOrder {
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a charge related to a payout
*/
export class PayoutOtherCharge {
    /**
    * The id of the charge
    */
    'ChargeId': number;
    /**
    * Charge amount
    */
    'Amount': number;
    /**
    * Currency of the charge
    */
    'Currency': PayoutOtherCharge.CurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId': number;
    /**
    * The date the order was placed
    */
    'ChargeDate': Date;
    /**
    * Charge type
    */
    'ChargeType': PayoutOtherCharge.ChargeTypeEnum;
    /**
    * Charge description
    */
    'ChargeDescription': string;
    /**
    * Store id
    */
    'StoreId': number;
}

export namespace PayoutOtherCharge {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChargeTypeEnum {
        Other = <any> 'Other',
        Fees = <any> 'Fees',
        Chargeback = <any> 'Chargeback',
        TipFailure = <any> 'TipFailure',
        ExternalDisbursement = <any> 'ExternalDisbursement',
        Goods = <any> 'Goods',
        RestaurantSales = <any> 'RestaurantSales',
        Tips = <any> 'Tips'
    }
}
/**
* Holds the information for a refund related to a payout
*/
export class PayoutRefund {
    /**
    * The id of the order the refund was for
    */
    'OrderId': number;
    /**
    * Order currency
    */
    'OrderCurrency': PayoutRefund.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId': number;
    /**
    * The date the order was placed
    */
    'OrderDate': Date;
    /**
    * Order type (online or cash)
    */
    'OrderType': PayoutRefund.OrderTypeEnum;
    /**
    * The date the refund was done
    */
    'RefundDate': Date;
    /**
    * Store id
    */
    'StoreId': number;
    /**
    * Total refund amount
    */
    'TotalRefund': number;
    /**
    * Refunded fees amount
    */
    'RefundedFees': number;
    /**
    * Refunded amount
    */
    'RefundedAmount': number;
    /**
    * Cash fee refunded to customer
    */
    'CashFeeRefundedToCustomer': number;
}

export namespace PayoutRefund {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Payout details for a single store
*/
export class PayoutStore {
    /**
    * The id of the Store.
    */
    'StoreId': number;
    /**
    * Name of the store
    */
    'StoreName': string;
    /**
    * Amount of the payout for this Store
    */
    'Amount': number;
    /**
    * Revenue details (DEPRECATED: Use Revenue)
    */
    'OnlineRevenue': RevenueDetail;
    /**
    * Revenue details
    */
    'Revenue': RevenueDetail;
    /**
    * Revenue Adjustments breakdown
    */
    'RevenueAdjustments': RevenueAdjustmentsDetails;
    /**
    * Fees breakdown
    */
    'FlipdishFees': FlipdishFeesDetails;
    /**
    * Chargebacks breakdown
    */
    'Chargebacks': ChargebackDetails;
    /**
    * Breakdown of other charges
    */
    'OtherCharges': OtherChargesDetails;
    /**
    * Period opening and closing balance
    */
    'Balance': BalanceDetails;
}

/**
* Holds the information for a whitelabel payouts summary.
*/
export class PayoutSummary {
    /**
    * Status of the payout
    */
    'PayoutStatus': PayoutSummary.PayoutStatusEnum;
    /**
    * Total payouts amount
    */
    'TotalAmount': number;
    /**
    * Payout currency
    */
    'Currency': PayoutSummary.CurrencyEnum;
    /**
    * Total payouts count
    */
    'TotalCount': number;
}

export namespace PayoutSummary {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Percent discount details
*/
export class PercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount': number;
}

/**
* Phone call
*/
export class PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId': number;
    /**
    * Time of the call
    */
    'TimeOfCall': Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal': Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId': number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName': string;
    /**
    * Name of the caller
    */
    'CallerName': string;
    /**
    * UserID of the caller
    */
    'CallerUserId': number;
    /**
    * Phone number of the caller
    */
    'CallerNumber': string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds': number;
    /**
    * The status of the call
    */
    'CallStatus': PhoneCall.CallStatusEnum;
}

export namespace PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Phone call ended event
*/
export class PhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * The phone call
    */
    'PhoneCall': PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Phone call started event
*/
export class PhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * The phone call
    */
    'PhoneCall': PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Pre Order Config
*/
export class PreOrderConfig {
    /**
    * Lead Time in Minutes
    */
    'LeadTimeMinutes': number;
    /**
    * Interval in minutes
    */
    'IntervalMinutes': number;
    /**
    * Max Days to order ahead
    */
    'MaxOrderAheadDays': number;
    /**
    * Show ASAP as option
    */
    'IncludeAsap': boolean;
    /**
    * Granual Init' Time
    */
    'IncludeMoreGranularInitialTime': boolean;
    /**
    * Cut off time previous day
    */
    'CutOffTimePreviousDayBasic': string;
    /**
    * Cut off time current day
    */
    'CutOffTimeCurrentDayBasic': string;
    /**
    * Type of time displayed.
    */
    'PreOrderTimeDisplayType': PreOrderConfig.PreOrderTimeDisplayTypeEnum;
    /**
    * Specifies whether a customer can pre-order outside the store opening hours or not.
    */
    'AlwaysAppearOpen': boolean;
    /**
    * Force customer to select collection time.
    */
    'RequireExplicitSelectAlways': boolean;
}

export namespace PreOrderConfig {
    export enum PreOrderTimeDisplayTypeEnum {
        SingleTime = <any> 'SingleTime',
        StartAndEndTime = <any> 'StartAndEndTime',
        DayOnly = <any> 'DayOnly'
    }
}
/**
* Time order can be placed
*/
export class PreOrderTime {
    /**
    * Start Time
    */
    'StartTime': Date;
    /**
    * End Time
    */
    'EndTime': Date;
}

/**
* Predefined answer
*/
export class PredefinedAnswer {
    /**
    * Identifier
    */
    'Id': number;
    /**
    * Text
    */
    'Text': string;
}

/**
* Printer
*/
export class Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber': string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime': Date;
}

/**
* Printer assigned to store event
*/
export class PrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The printer
    */
    'Printer': Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Printer turned off event
*/
export class PrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The printer
    */
    'Printer': Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Printer turned on event
*/
export class PrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The printer
    */
    'Printer': Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Printer assigned from store event
*/
export class PrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The printer
    */
    'Printer': Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Processing fee config
*/
export class ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Payment account type
    */
    'PaymentAccountType': ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee': number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee': number;
}

export namespace ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
}
/**
* 
*/
export class PushNotificationDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'PushNotification': PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Push Notification Details
*/
export class PushNotificationRequest {
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime': Date;
    /**
    * Title of the notification
    */
    'Title': string;
    /**
    * Message of the notification
    */
    'Message': string;
}

/**
* Push Notification
*/
export class PushNotificationResponse {
    /**
    * Sent
    */
    'Sent': boolean;
    /**
    * Push notification identifier
    */
    'ScheduledPushNotificationId': number;
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime': Date;
    /**
    * Title of the notification
    */
    'Title': string;
    /**
    * Message of the notification
    */
    'Message': string;
}

/**
* 
*/
export class PushNotificationScheduledEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * 
    */
    'User': UserEventInfo;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'PushNotification': PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class PushNotificationSentEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * 
    */
    'PushNotification': PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class Range {
    /**
    * Start time
    */
    'StartTime': string;
    /**
    * Period
    */
    'Period': string;
    /**
    * Day of week
    */
    'DayOfWeek': Range.DayOfWeekEnum;
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* 
*/
export class RedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId': string;
    /**
    * Invitation status
    */
    'InvitationStatus': RedeemInvitationResult.InvitationStatusEnum;
}

export namespace RedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* Refund
*/
export class Refund {
    /**
    * Refund reason
    */
    'RefundReason': string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If true, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;
}

/**
* Reject
*/
export class Reject {
    /**
    * Reject reason.
    */
    'RejectReason': Reject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer': boolean;
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Request login PIN response
*/
export class RequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;
}

/**
* Request login PIN response
*/
export class RequestLoginPinResposne {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail': boolean;
}

/**
* 
*/
export class RequestPasswordResetModel {
    /**
    * Email address
    */
    'Email': string;
}

/**
* Rest api array result
*/
export class RestApiArrayResultAllMetadataResult {
    /**
    * Generic data object.
    */
    'Data': Array<AllMetadataResult>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmCurrencyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmCurrencyDataPoint>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmDataPoint>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmHourlyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmHourlyDataPoint>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultBankAccountSummary {
    /**
    * Generic data object.
    */
    'Data': Array<BankAccountSummary>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursPeriod>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultCountryWithAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': Array<CountryWithAccountFieldsDefinitions>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': Array<DeliveryZone>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriver {
    /**
    * Generic data object.
    */
    'Data': Array<Driver>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultDriverStore {
    /**
    * Generic data object.
    */
    'Data': Array<DriverStore>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultEmvTerminalWithAssignments {
    /**
    * Generic data object.
    */
    'Data': Array<EmvTerminalWithAssignments>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultHomeAction {
    /**
    * Generic data object.
    */
    'Data': Array<HomeAction>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocalisedTimeZone {
    /**
    * Generic data object.
    */
    'Data': Array<LocalisedTimeZone>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<LoyaltyCampaign>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuCheckpoint {
    /**
    * Generic data object.
    */
    'Data': Array<MenuCheckpoint>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementEditResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementEditResponse>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSet>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSetItem>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSection>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSectionItem>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuStoreNames {
    /**
    * Generic data object.
    */
    'Data': Array<MenuStoreNames>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSummary {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSummary>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuTaxDetails {
    /**
    * Generic data object.
    */
    'Data': Array<MenuTaxDetails>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Array<Metadata>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': Array<OAuthApp>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': Array<OauthClientRedirectUri>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultPayoutSummary {
    /**
    * Generic data object.
    */
    'Data': Array<PayoutSummary>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultPreOrderTime {
    /**
    * Generic data object.
    */
    'Data': Array<PreOrderTime>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<ProcessingFeeConfig>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestApiDefaultResponse {
    /**
    * Generic data object.
    */
    'Data': Array<RestApiDefaultResponse>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<RetentionCampaign>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreListItem {
    /**
    * Generic data object.
    */
    'Data': Array<StoreListItem>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<StoreStatistics>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultSupportedCountry {
    /**
    * Generic data object.
    */
    'Data': Array<SupportedCountry>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Array<Teammate>;
}

/**
* Rest api array result
*/
export class RestApiArrayResultVoucherDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<VoucherDataPoint>;
}

/**
* Rest api default response
*/
export class RestApiDefaultResponse {
    /**
    * Data string
    */
    'Data': string;
}

/**
* Rest api error result
*/
export class RestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Error code
    */
    'ErrorCode': number;
    /**
    * Stack trace
    */
    'StackTrace': string;
    /**
    * List of errors grouped by field name
    */
    'Errors': Array<ValidationErrorResult>;
}

/**
* 
*/
export class RestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': EventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
}

/**
* Rest Api Forbidden Result
*/
export class RestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;
}

/**
* Rest api integer result
*/
export class RestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultApp {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<App>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultBusinessHoursOverride {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursOverride>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHttpRequestAndResponseLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HttpRequestAndResponseLog>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHydraDeviceDetails {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HydraDeviceDetails>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOAuthTokenModel {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OAuthTokenModel>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Order>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrderSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OrderSummary>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayout {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Payout>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutChargeback {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutChargeback>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOrder>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOtherCharge {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOtherCharge>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutRefund {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutRefund>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPhoneCall {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PhoneCall>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPushNotificationResponse {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PushNotificationResponse>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStore {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Store>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroup>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroupExtended {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroupExtended>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreHeader {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreHeader>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultVoucherSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<VoucherSummary>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookLog>;
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookSubscription {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookSubscription>;
}

/**
* Rest api result
*/
export class RestApiResultAccountDetail {
    /**
    * Generic data object.
    */
    'Data': AccountDetail;
}

/**
* Rest api result
*/
export class RestApiResultAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': AccountFieldsDefinitions;
}

/**
* Rest api result
*/
export class RestApiResultApmStatistics {
    /**
    * Generic data object.
    */
    'Data': ApmStatistics;
}

/**
* Rest api result
*/
export class RestApiResultApmStatus {
    /**
    * Generic data object.
    */
    'Data': ApmStatus;
}

/**
* Rest api result
*/
export class RestApiResultApp {
    /**
    * Generic data object.
    */
    'Data': App;
}

/**
* Rest api result
*/
export class RestApiResultAppCompliance {
    /**
    * Generic data object.
    */
    'Data': AppCompliance;
}

/**
* Rest api result
*/
export class RestApiResultAssignedBankAccount {
    /**
    * Generic data object.
    */
    'Data': AssignedBankAccount;
}

/**
* Rest api result
*/
export class RestApiResultBankAccountDetail {
    /**
    * Generic data object.
    */
    'Data': BankAccountDetail;
}

/**
* Rest api result
*/
export class RestApiResultBluetoothTerminalStatus {
    /**
    * Generic data object.
    */
    'Data': BluetoothTerminalStatus;
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursOverride {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursOverride;
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursPeriod;
}

/**
* Rest api result
*/
export class RestApiResultCoordinates {
    /**
    * Generic data object.
    */
    'Data': Coordinates;
}

/**
* Rest api result
*/
export class RestApiResultCustomer {
    /**
    * Generic data object.
    */
    'Data': Customer;
}

/**
* Rest api result
*/
export class RestApiResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': DeliveryZone;
}

/**
* Rest api result
*/
export class RestApiResultDnsRecordInformation {
    /**
    * Generic data object.
    */
    'Data': DnsRecordInformation;
}

/**
* Rest api result
*/
export class RestApiResultDriver {
    /**
    * Generic data object.
    */
    'Data': Driver;
}

/**
* Rest api result
*/
export class RestApiResultHomeStatistics {
    /**
    * Generic data object.
    */
    'Data': HomeStatistics;
}

/**
* Rest api result
*/
export class RestApiResultHydraConfig {
    /**
    * Generic data object.
    */
    'Data': HydraConfig;
}

/**
* Rest api result
*/
export class RestApiResultHydraStatus {
    /**
    * Generic data object.
    */
    'Data': HydraStatus;
}

/**
* Rest api result
*/
export class RestApiResultIndexPage {
    /**
    * Generic data object.
    */
    'Data': IndexPage;
}

/**
* Rest api result
*/
export class RestApiResultIndexPageBase {
    /**
    * Generic data object.
    */
    'Data': IndexPageBase;
}

/**
* Rest api result
*/
export class RestApiResultJobResponse {
    /**
    * Generic data object.
    */
    'Data': JobResponse;
}

/**
* Rest api result
*/
export class RestApiResultLightspeedSettings {
    /**
    * Generic data object.
    */
    'Data': LightspeedSettings;
}

/**
* Rest api result
*/
export class RestApiResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': LoyaltyCampaign;
}

/**
* Rest api result
*/
export class RestApiResultMenu {
    /**
    * Generic data object.
    */
    'Data': Menu;
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSet;
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSetItem;
}

/**
* Rest api result
*/
export class RestApiResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': MenuSection;
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionAvailability {
    /**
    * Generic data object.
    */
    'Data': MenuSectionAvailability;
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': MenuSectionItem;
}

/**
* Rest api result
*/
export class RestApiResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Metadata;
}

/**
* Rest api result
*/
export class RestApiResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': OAuthApp;
}

/**
* Rest api result
*/
export class RestApiResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': OauthClientRedirectUri;
}

/**
* Rest api result
*/
export class RestApiResultOrder {
    /**
    * Generic data object.
    */
    'Data': Order;
}

/**
* Rest api result
*/
export class RestApiResultOrderPaymentInformation {
    /**
    * Generic data object.
    */
    'Data': OrderPaymentInformation;
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalDetails;
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalTransactionDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalTransactionDetails;
}

/**
* Rest api result
*/
export class RestApiResultPreOrderConfig {
    /**
    * Generic data object.
    */
    'Data': PreOrderConfig;
}

/**
* Rest api result
*/
export class RestApiResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': ProcessingFeeConfig;
}

/**
* Rest api result
*/
export class RestApiResultPushNotificationResponse {
    /**
    * Generic data object.
    */
    'Data': PushNotificationResponse;
}

/**
* Rest api result
*/
export class RestApiResultRedeemInvitationResult {
    /**
    * Generic data object.
    */
    'Data': RedeemInvitationResult;
}

/**
* Rest api result
*/
export class RestApiResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': RetentionCampaign;
}

/**
* Rest api result
*/
export class RestApiResultStore {
    /**
    * Generic data object.
    */
    'Data': Store;
}

/**
* Rest api result
*/
export class RestApiResultStoreAddress {
    /**
    * Generic data object.
    */
    'Data': StoreAddress;
}

/**
* Rest api result
*/
export class RestApiResultStoreEndOfDayReport {
    /**
    * Generic data object.
    */
    'Data': StoreEndOfDayReport;
}

/**
* Rest api result
*/
export class RestApiResultStoreGroup {
    /**
    * Generic data object.
    */
    'Data': StoreGroup;
}

/**
* Rest api result
*/
export class RestApiResultStoreGroupBase {
    /**
    * Generic data object.
    */
    'Data': StoreGroupBase;
}

/**
* Rest api result
*/
export class RestApiResultStoreOrderCapacityConfig {
    /**
    * Generic data object.
    */
    'Data': StoreOrderCapacityConfig;
}

/**
* Rest api result
*/
export class RestApiResultStripeConnectedAccount {
    /**
    * Generic data object.
    */
    'Data': StripeConnectedAccount;
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalPrivateKey {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalPrivateKey;
}

/**
* Rest api result
*/
export class RestApiResultStuartSettings {
    /**
    * Generic data object.
    */
    'Data': StuartSettings;
}

/**
* Rest api result
*/
export class RestApiResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Teammate;
}

/**
* Rest api result
*/
export class RestApiResultVoucherWithStats {
    /**
    * Generic data object.
    */
    'Data': VoucherWithStats;
}

/**
* Rest api result
*/
export class RestApiResultWebsiteImage {
    /**
    * Generic data object.
    */
    'Data': WebsiteImage;
}

/**
* Rest api result
*/
export class RestApiResultWebsiteTestimonial {
    /**
    * Generic data object.
    */
    'Data': WebsiteTestimonial;
}

/**
* Rest api string array result
*/
export class RestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;
}

/**
* Rest api string result
*/
export class RestApiStringResult {
    /**
    * Data string
    */
    'Data': string;
}

/**
* Rest api unauthorized result
*/
export class RestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;
}

/**
* Retention campaign
*/
export class RetentionCampaign {
    /**
    * Id of campaign
    */
    'CampaignId': number;
    /**
    * Statistics of campaign
    */
    'Statistics': CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores': Array<StoreCampaignStartTime>;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes': number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount': number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount': number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays': number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers': boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders': boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled': boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds': Array<number>;
}

/**
* Retention campaign base
*/
export class RetentionCampaignBase {
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes': number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount': number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount': number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays': number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers': boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders': boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled': boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds': Array<number>;
}

/**
* Retention campaign created event
*/
export class RetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign': RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Retention campaign deleted event
*/
export class RetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign': RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Retention campaign updated event
*/
export class RetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Info User
    */
    'User': UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign': RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Revenue Adjustments breakdown
*/
export class RevenueAdjustmentsDetails {
    /**
    * Online sales refunds
    */
    'OnlineSalesRefundedAmount': number;
    /**
    * Cash sales refunds
    */
    'CashSalesRefundedAmount': number;
    /**
    * Customer cash fees
    */
    'CustomerCashFees': number;
    /**
    * Number of refunds
    */
    'RefundsCount': number;
    /**
    * Total revenue adjustments
    */
    'TotalOnlineRevenueAdjustments': number;
}

/**
* Sales information
*/
export class RevenueDetail {
    /**
    * Online sales amount
    */
    'OnlineSalesAmount': number;
    /**
    * Online sales tax
    */
    'OnlineSalesTax': number;
    /**
    * Online sales amount plus online sales tax
    */
    'OnlineSalesIncludingTax': number;
    /**
    * Online sales base amount to calculate fees
    */
    'OnlineSalesFeesBaseAmount': number;
    /**
    * Cash sales amount
    */
    'CashSalesAmount': number;
    /**
    * Cash sales tax
    */
    'CashSalesTax': number;
    /**
    * Cash sales amount plus online sales tax
    */
    'CashSalesIncludingTax': number;
    /**
    * Online sales base amount to calculate fees
    */
    'CashSalesFeesBaseAmount': number;
    /**
    * Total Sales (online and cash) including tax
    */
    'TotalSalesIncludingTax': number;
    /**
    * Delivery charges on online sales
    */
    'OnlineSalesDeliveryCharges': number;
    /**
    * Tips for online sales
    */
    'OnlineSalesTips': number;
    /**
    * Online sales plus online delivery charges and tips
    */
    'TotalOnlineRevenue': number;
}

/**
* Search Criteria for Audit Logs
*/
export class SearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit': number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page': number;
    /**
    * Start date
    */
    'Start': Date;
    /**
    * End date
    */
    'End': Date;
    /**
    * Events that have Order Id
    */
    'OrderId': number;
    /**
    * Events that have Store Id
    */
    'StoreId': number;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId': number;
    /**
    * Events that have User Id
    */
    'UserId': number;
    /**
    * Events that have User Email
    */
    'UserEmail': string;
    /**
    * Events that have User Name
    */
    'UserName': string;
    /**
    * Events that have voucher code
    */
    'VoucherCode': string;
    /**
    * Events that have event type\\s
    */
    'EventType': Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId': string;
}

/**
* Set password with PIN model
*/
export class SetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;
}

/**
* 
*/
export class SignupStep {
    /**
    * Action needs to take
    */
    'Action': SignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question': string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers': Array<PredefinedAnswer>;
}

export namespace SignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription'
    }
}
/**
* Sms Info
*/
export class SmsInfo {
    /**
    * Origin phone number
    */
    'From': string;
    /**
    * Destination phone number
    */
    'To': string;
    /**
    * Text message
    */
    'Text': string;
}

/**
* Sms received event
*/
export class SmsReceivedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The sms info
    */
    'SmsInfo': SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* A single currency data point, with no date
*/
export class StatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency': StatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount': number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount': number;
    /**
    * Value of orders for this currency
    */
    'OrderValue': number;
}

export namespace StatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store
*/
export class Store {
    /**
    * Store identifier
    */
    'StoreId': number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId': number;
    /**
    * Store address
    */
    'Address': StoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones': Array<DeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber': string;
    /**
    * Pickup hours
    */
    'PickupHours': Array<BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours': Array<BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId': number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery': string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup': string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType': Store.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes': Array<StoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone': string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone': string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency': Store.CurrencyEnum;
    /**
    * Is PerOrder Enabled for Delivery
    */
    'PreOrderDeliveryEnabled': boolean;
    /**
    * Is PerOrder Enabled for Pickup
    */
    'PreOrderPickupEnabled': boolean;
    /**
    * Url for logo image
    */
    'LogoUrl': string;
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen': boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled': boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled': boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled': boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled': boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService': boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled': boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled': boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled': boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled': boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled': boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled': boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled': boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders': boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery': boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup': boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount': number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup': boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers': boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery': boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes': boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled': boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled': boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived': boolean;
    /**
    * Is the Store Published
    */
    'IsPublished': boolean;
    /**
    * Name
    */
    'Name': string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress': string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage': string;
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store address
*/
export class StoreAddress {
    /**
    * Address identifier
    */
    'AddressId': number;
    /**
    * Coordinate
    */
    'Coordinates': Coordinates;
    /**
    * Address line 1
    */
    'Line1': string;
    /**
    * Postcode
    */
    'Postcode': string;
    /**
    * City
    */
    'City': string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode': string;
    /**
    * Display for customer
    */
    'DisplayForCustomer': string;
}

/**
* Store address base
*/
export class StoreAddressBase {
    /**
    * Address line 1
    */
    'Line1': string;
    /**
    * Postcode
    */
    'Postcode': string;
    /**
    * City
    */
    'City': string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode': string;
    /**
    * Display for customer
    */
    'DisplayForCustomer': string;
}

/**
* Store Address Updated Event
*/
export class StoreAddressUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which updated this store address
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated store address
    */
    'StoreAddress': StoreAddress;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Archived Event
*/
export class StoreArchivedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which archived this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Archived Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Base
*/
export class StoreBase {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen': boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled': boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled': boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled': boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled': boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService': boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled': boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled': boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled': boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled': boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled': boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled': boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled': boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders': boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery': boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup': boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount': number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup': boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers': boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery': boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes': boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled': boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled': boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived': boolean;
    /**
    * Is the Store Published
    */
    'IsPublished': boolean;
    /**
    * Name
    */
    'Name': string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress': string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage': string;
}

/**
* Store Business Hours Override Created
*/
export class StoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which deleted delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride': BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Business Hours Override Deleted
*/
export class StoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which deleted delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride': BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store campaign start time
*/
export class StoreCampaignStartTime {
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Campaign start time in Utc
    */
    'TsStart': Date;
}

/**
* Settings for cloning a store
*/
export class StoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId': number;
}

/**
* Store Create Base
*/
export class StoreCreateBase {
    /**
    * Name
    */
    'Name': string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress': string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage': string;
}

/**
* Store Created Event
*/
export class StoreCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * User which created this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Created Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Data Point
*/
export class StoreDataPoint {
    /**
    * Day
    */
    'Day': Date;
    /**
    * Value for the day
    */
    'Value': number;
}

/**
* Store Deleted Event
*/
export class StoreDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which deleted this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Deleted Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store end of day report
*/
export class StoreEndOfDayReport {
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * Currency
    */
    'Currency': StoreEndOfDayReport.CurrencyEnum;
    /**
    * Order Count
    */
    'OrderCount': number;
    /**
    * Order Value
    */
    'OrderValue': number;
    /**
    * Order Value Excluding Delivery Fees
    */
    'OrderValueExcludingDeliveryFees': number;
    /**
    * Collection Order Count
    */
    'CollectionOrderCount': number;
    /**
    * Collection Cash Order Count
    */
    'CollectionCashOrderCount': number;
    /**
    * Collection Paid Online Order Count
    */
    'CollectionPaidOnlineOrderCount': number;
    /**
    * Collection Order Value
    */
    'CollectionOrderValue': number;
    /**
    * Collection Cash Order Value
    */
    'CollectionCashOrderValue': number;
    /**
    * Collection Paid Online Order Value
    */
    'CollectionPaidOnlineOrderValue': number;
    /**
    * Delivery Order Count
    */
    'DeliveryOrderCount': number;
    /**
    * Delivery Cash Order Count
    */
    'DeliveryCashOrderCount': number;
    /**
    * Delivery Paid Online Order Count
    */
    'DeliveryPaidOnlineOrderCount': number;
    /**
    * Delivery Order Value
    */
    'DeliveryOrderValue': number;
    /**
    * Delivery Cash Order Value
    */
    'DeliveryCashOrderValue': number;
    /**
    * Delivery Paid Online Order Value
    */
    'DeliveryPaidOnlineOrderValue': number;
    /**
    * Paid Online Order Count
    */
    'PaidOnlineOrderCount': number;
    /**
    * Cash Order Count
    */
    'CashOrderCount': number;
    /**
    * Paid Online Order Value
    */
    'PaidOnlineOrderValue': number;
    /**
    * Cash Order Value
    */
    'CashOrderValue': number;
    /**
    * Paid Online Order Value Excluding Delivery Fees
    */
    'PaidOnlineOrderValueExcludingDeliveryFees': number;
    /**
    * Cash Order Value Excluding Delivery Fees
    */
    'CashOrderValueExcludingDeliveryFees': number;
    /**
    * Start Time
    */
    'StartTime': Date;
    /**
    * End Time
    */
    'EndTime': Date;
}

export namespace StoreEndOfDayReport {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group
*/
export class StoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId': number;
    /**
    * Store Group rating
    */
    'GeneralRating': number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount': number;
    /**
    * Store Group Name
    */
    'Name': string;
    /**
    * Currency used by the stores in this group
    */
    'Currency': StoreGroup.CurrencyEnum;
}

export namespace StoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Update Store Group
*/
export class StoreGroupBase {
    /**
    * Store Group Name
    */
    'Name': string;
    /**
    * Currency used by the stores in this group
    */
    'Currency': StoreGroupBase.CurrencyEnum;
}

export namespace StoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Created Event
*/
export class StoreGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Group Id
    */
    'StoreGroupId': number;
    /**
    * User which created this store group
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Created store group
    */
    'StoreGroup': StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Group Deleted Event
*/
export class StoreGroupDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Group Id
    */
    'StoreGroupId': number;
    /**
    * User which deleted this store group
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Deleted store group
    */
    'StoreGroup': StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Group Extended
*/
export class StoreGroupExtended {
    /**
    * Total Amount of Stores
    */
    'TotalStores': number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates': Array<GroupedCoordinates>;
    /**
    * Store Headers associated with Store Group
    */
    'StoreHeaders': Array<StoreHeader>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId': number;
    /**
    * Store Group rating
    */
    'GeneralRating': number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount': number;
    /**
    * Store Group Name
    */
    'Name': string;
    /**
    * Currency used by the stores in this group
    */
    'Currency': StoreGroupExtended.CurrencyEnum;
}

export namespace StoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Updated Event
*/
export class StoreGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Group Id
    */
    'StoreGroupId': number;
    /**
    * User which updated this store group
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated store group
    */
    'StoreGroup': StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Represents the most basic store information, used mostly for searches
*/
export class StoreHeader {
    /**
    * Store identifier
    */
    'StoreId': number;
    /**
    * Name
    */
    'Name': string;
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSetting {
    /**
    * Kiosk setting id
    */
    'KioskSettingId': number;
    /**
    * Store kiosk name
    */
    'KioskName': string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName': boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber': boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOption': boolean;
    /**
    * Physical restaurant id
    */
    'PhysicalRestaurantId': number;
    /**
    * Hydra config id
    */
    'HydraConfigId': number;
}

/**
* Store kiosk setting updated
*/
export class StoreKioskSettingUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * User which deleted delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Store kiosk settings
    */
    'StoreKioskSetting': StoreKioskSetting;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store id and name
*/
export class StoreListItem {
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store Name
    */
    'StoreName': string;
    /**
    * Store Group Id
    */
    'StoreGroupId': number;
    /**
    * Store Group Name
    */
    'StoreGroupName': string;
    /**
    * Store has loyalty campaign
    */
    'HasLoyaltyCampaign': boolean;
    /**
    * Store has retention campaign
    */
    'HasRetentionCampaign': boolean;
}

/**
* Store logo created
*/
export class StoreLogoCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who added the logo
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store logo deleted
*/
export class StoreLogoDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who removed the logo
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store logo updated
*/
export class StoreLogoUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId': number;
    /**
    * Description
    */
    'Description': string;
    /**
    * User who updated the logo
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Menu Assigned To Store Event
*/
export class StoreMenuAssignedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * MenuId Id
    */
    'MenuId': number;
    /**
    * User who assigned the menu to the store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store note
*/
export class StoreNote {
    /**
    * User identifier
    */
    'UserId': number;
    /**
    * Create time
    */
    'CreateTime': Date;
    /**
    * Note
    */
    'Note': string;
}

/**
* Store Opening Hours Updated Event
*/
export class StoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which updated opening hours for this store
    */
    'User': UserEventInfo;
    /**
    * Type of opening hours Delivery / Pickup
    */
    'DeliveryType': StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum;
    /**
    * The period that was updated
    */
    'BusinessHoursPeriodOld': BusinessHoursPeriod;
    /**
    * The new values of the period
    */
    'BusinessHoursPeriod': BusinessHoursPeriod;
    /**
    * Description
    */
    'Description': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

export namespace StoreOpeningHoursUpdatedEvent {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration
*/
export class StoreOrderCapacityConfig {
    /**
    * Store identifier
    */
    'StoreId': number;
    /**
    * Signifies whether the order capacity configuration is for Delivery / Pickup
    */
    'DeliveryType': StoreOrderCapacityConfig.DeliveryTypeEnum;
    /**
    * Store Interval - time between orders, e.g. 10 minutes between each order time available to customer
    */
    'StoreIntervalInMinutes': number;
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods': Array<StoreOrderCapacityPeriod>;
}

export namespace StoreOrderCapacityConfig {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration edit
*/
export class StoreOrderCapacityConfigEditModel {
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods': Array<StoreOrderCapacityPeriod>;
}

/**
* Represents a single order capacity period
*/
export class StoreOrderCapacityPeriod {
    /**
    * The maximum number of orders per each store order interval in this order capacity period.  E.g. for a period from 9:00 till 11:00, if the store's interval is 10 minutes, and MaxOrderNumberPerStoreInterval is set to 5,  it means that within each 10-minute interval between 9:00 and 11:00 (i.e. 9:00-9:10, 9:10-9:20, .. , 10:50-11:00) it will be possible to  request at most 5 orders.
    */
    'MaxOrderNumberPerStoreInterval': number;
    /**
    * Day of the week the period pertains to
    */
    'DayOfTheWeek': StoreOrderCapacityPeriod.DayOfTheWeekEnum;
    /**
    * The hour the period starts at
    */
    'PeriodStartHour': number;
    /**
    * The minutes after the hour the period starts at
    */
    'PeriodStartMinutes': number;
    /**
    * The hour the period ends at
    */
    'PeriodEndHour': number;
    /**
    * The minutes after the hour the period ends at
    */
    'PeriodEndMinutes': number;
}

export namespace StoreOrderCapacityPeriod {
    export enum DayOfTheWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Store Pre order config updated
*/
export class StorePreOrderConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * User which deleted delivery zone for this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Pre Order Configuration
    */
    'PreOrderConfig': PreOrderConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Published Event
*/
export class StorePublishedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which published this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Published Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store statistics
*/
export class StoreStatistics {
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store Data Points
    */
    'Data': Array<StoreDataPoint>;
}

/**
* Store summary
*/
export class StoreSummary {
    /**
    * Store identifier
    */
    'Id': number;
    /**
    * Store name
    */
    'Name': string;
    /**
    * Stores menu identifier
    */
    'MenuId': number;
    /**
    * Store metadata
    */
    'Metadata': { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency': StoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates': Coordinates;
    /**
    * Timezone of store
    */
    'StoreTimezone': string;
    /**
    * Store group id of store
    */
    'StoreGroupId': number;
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Unarchived Event
*/
export class StoreUnarchivedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which unarchived this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Unarchived Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Unpublished Event
*/
export class StoreUnpublishedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which unpublished this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Unpublished Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Store Updated Event
*/
export class StoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Store Id
    */
    'StoreId': number;
    /**
    * Store group Id
    */
    'StoreGroupId': number;
    /**
    * User which updated this store
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated Store
    */
    'Store': Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Represents a request for Stripe account link creation
*/
export class StripeAccountLinkRequest {
    /**
    * Stripe's own connected account identifier
    */
    'StripeId': string;
    /**
    * URL to be hit if link creation succeeds
    */
    'ReturnUrl': string;
    /**
    * Which information to collect from users at this stage
    */
    'Collect': StripeAccountLinkRequest.CollectEnum;
    /**
    * Either onboarding or edit user information
    */
    'Type': StripeAccountLinkRequest.TypeEnum;
}

export namespace StripeAccountLinkRequest {
    export enum CollectEnum {
        CurrentlyDue = <any> 'CurrentlyDue',
        EventuallyDue = <any> 'EventuallyDue'
    }
    export enum TypeEnum {
        Onboarding = <any> 'Onboarding',
        Update = <any> 'Update'
    }
}
/**
* Represents a Stripe custom connected account
*/
export class StripeConnectedAccount {
    /**
    * Flipdish connected account identifier
    */
    'FlipdishConnectedAccountId': number;
    /**
    * Stripe's own connected account identifier
    */
    'StripeId': string;
    /**
    * Id of the WhitelabelConfig the connected account is assigned to
    */
    'WhitelabelConfigId': number;
    /**
    * Card payments capability status (Inactive, Pending, Active, Unrequested)
    */
    'CardPaymentsStatus': StripeConnectedAccount.CardPaymentsStatusEnum;
    /**
    * Transfers capability status (Inactive, Pending, Active, Unrequested)
    */
    'TransfersStatus': StripeConnectedAccount.TransfersStatusEnum;
    /**
    * Current status of the account
    */
    'AccountStatus': StripeConnectedAccount.AccountStatusEnum;
}

export namespace StripeConnectedAccount {
    export enum CardPaymentsStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum TransfersStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
}
/**
* Represents information about a Stripe connected account associated with a bank account
*/
export class StripeConnectedAccountInfo {
    /**
    * Stripe connected account status
    */
    'AccountStatus': StripeConnectedAccountInfo.AccountStatusEnum;
    /**
    * Stripe connected account id
    */
    'StripeId': string;
    /**
    * Current status of the Card Payment capability of the account
    */
    'CardPaymentStatus': StripeConnectedAccountInfo.CardPaymentStatusEnum;
}

export namespace StripeConnectedAccountInfo {
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount'
    }
    export enum CardPaymentStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
}
/**
* Stripe Terminal Private Key
*/
export class StripeTerminalPrivateKey {
    /**
    * Registered location of the terminal
    */
    'Location': string;
    /**
    * Secret used to pass to stripe to attach terminal
    */
    'Secret': string;
}

/**
* Stuart settings
*/
export class StuartSettings {
    /**
    * Client Id
    */
    'ClientId': string;
    /**
    * Client Secret
    */
    'ClientSecret': string;
    /**
    * Enabled
    */
    'Enabled': boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication': string;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime': number;
    /**
    * Package type
    */
    'PackageType': StuartSettings.PackageTypeEnum;
    /**
    * Transport type
    */
    'TransportType': StuartSettings.TransportTypeEnum;
    /**
    * Determines if Flipdish order should be cancel when Stuart cancels delivery
    */
    'CancelOrderIfStuartCancelDelivery': boolean;
    'TransportPrices': StuartSettingsTransportPrices;
}

export namespace StuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
    export enum TransportTypeEnum {
        Bike = <any> 'Bike',
        Cargobike = <any> 'Cargobike',
        Cargobikexl = <any> 'Cargobikexl',
        Motorbike = <any> 'Motorbike',
        Motorbikexl = <any> 'Motorbikexl',
        Car = <any> 'Car',
        Van = <any> 'Van'
    }
}
/**
* If the order exceeds are certain amount this configuration will determine a new vehicle type
*/
export class StuartSettingsTransportPrices {
    'Bike': number;
    'Cargobike': number;
    'Cargobikexl': number;
    'Motorbike': number;
    'Motorbikexl': number;
    'Car': number;
    'Van': number;
}

/**
* Describes a supported country
*/
export class SupportedCountry {
    /**
    * Country code
    */
    'CountryCode': string;
    /**
    * Nice display name for a country
    */
    'Name': string;
    /**
    * Country internatinoal phone code prefix
    */
    'PhoneCode': number;
    /**
    * Language code
    */
    'LanguageCode': string;
    /**
    * Language name
    */
    'LanguageName': string;
    /**
    * The phone number provided to Store staff which, in conjunction with a one-time-code, will connect them to the customer.
    */
    'OtpNumber': string;
    /**
    * The store's support phone number, displayed to customers.
    */
    'SupportNumber': string;
    /**
    * Address layout format. This changes the layout of address entry forms on the web app, iOS and Android app and should be set based on local custom.
    */
    'AddressLayout': SupportedCountry.AddressLayoutEnum;
    /**
    * Post code type
    */
    'PostCodeType': SupportedCountry.PostCodeTypeEnum;
    /**
    * Supported region. This is not used.
    */
    'SupportRegion': SupportedCountry.SupportRegionEnum;
}

export namespace SupportedCountry {
    export enum AddressLayoutEnum {
        BuildingFirst = <any> 'BuildingFirst',
        AddressFirst = <any> 'AddressFirst',
        FullStreetAddressFirst = <any> 'FullStreetAddressFirst'
    }
    export enum PostCodeTypeEnum {
        None = <any> 'None',
        PostCode = <any> 'PostCode',
        Zip = <any> 'Zip'
    }
    export enum SupportRegionEnum {
        Default = <any> 'Default',
        Spain = <any> 'Spain',
        Benelux = <any> 'Benelux'
    }
}
/**
* 
*/
export class Teammate {
    /**
    * Unique indentifier
    */
    'TeammateId': string;
    /**
    * Name
    */
    'Name': string;
    /**
    * Last activity
    */
    'LastActivity': Date;
    /**
    * Access level is for this App
    */
    'AppId': string;
    /**
    * Invitation status
    */
    'InvitationStatus': Teammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email': string;
    /**
    * App access level
    */
    'AppAccessLevel': Teammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores': boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds': Array<number>;
}

export namespace Teammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel': TeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores': boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds': Array<number>;
}

export namespace TeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate': Teammate;
    /**
    * User who deleted the teammate
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class TeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate': Teammate;
    /**
    * User who accepted the invitation
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class TeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate': Teammate;
    /**
    * User who sent the invitation
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class TeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate': Teammate;
    /**
    * User who updated the teammate
    */
    'User': UserEventInfo;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* UpdateDriver Push Notification Token
*/
export class UpdateDriverNotificationToken {
    /**
    * Push notifications token, cannot be null
    */
    'PushNotificationsToken': string;
}

/**
* Update Driver Profile
*/
export class UpdateDriverProfileModel {
    /**
    * The new name of the Driver.
    */
    'Name': string;
}

/**
* User answered signup questions event
*/
export class UserAnsweredSignupQuestionsEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The users answers
    */
    'SignupAnswers': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* User created event
*/
export class UserCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* User deleted event
*/
export class UserDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* User Event Info
*/
export class UserEventInfo {
    /**
    * User Id
    */
    'UserId': number;
    /**
    * User Name
    */
    'UserName': string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber': string;
    /**
    * User Email
    */
    'UserEmail': string;
}

/**
* User login event
*/
export class UserLoginEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* User created password event
*/
export class UserPasswordCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* User updated event
*/
export class UserUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Description
    */
    'Description': string;
    /**
    * The user
    */
    'User': UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Validation error result
*/
export class ValidationErrorResult {
    /**
    * Field name
    */
    'FieldName': string;
    /**
    * List of errors relates to field
    */
    'Errors': Array<string>;
}

/**
* Voucher
*/
export class Voucher {
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * Voucher Status
    */
    'Status': Voucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType': Voucher.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType': Voucher.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency': Voucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores': Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames': Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails': AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails': CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails': LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails': PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code': string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description': string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver': number;
    /**
    * Takes priority
    */
    'TakesPriority': boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled': boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied': boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders': boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders': boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline': boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash': boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly': boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer': boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce': boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate': Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate': Date;
}

export namespace Voucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Voucher Base
*/
export class VoucherBase {
    /**
    * Voucher Code
    */
    'Code': string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description': string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver': number;
    /**
    * Takes priority
    */
    'TakesPriority': boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled': boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied': boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders': boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders': boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline': boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash': boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly': boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer': boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce': boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate': Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate': Date;
}

/**
* Voucher Created Event
*/
export class VoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * User which created this voucher
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Created voucher
    */
    'Voucher': Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class VoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart': Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays': number;
    /**
    * The value of this data point
    */
    'Value': number;
}

/**
* Voucher Deleted Event
*/
export class VoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * User which deleted this voucher
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Deleted voucher
    */
    'Voucher': Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Voucher Summary
*/
export class VoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * Voucher Code
    */
    'Code': string;
    /**
    * Voucher Status
    */
    'Status': VoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType': VoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType': VoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description': string;
    /**
    * Is voucher enabled
    */
    'IsEnabled': boolean;
}

export namespace VoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Updated Event
*/
export class VoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * User which updated this voucher
    */
    'User': UserEventInfo;
    /**
    * Description
    */
    'Description': string;
    /**
    * Updated voucher
    */
    'Voucher': Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Voucher With Statistics
*/
export class VoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed': number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers': number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders': number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted': number;
    /**
    * Average Order Size
    */
    'AverageOrderSize': number;
    /**
    * Voucher Id
    */
    'VoucherId': number;
    /**
    * Voucher Status
    */
    'Status': VoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType': VoucherWithStats.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType': VoucherWithStats.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency': VoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores': Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames': Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails': AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails': CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails': LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails': PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code': string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description': string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver': number;
    /**
    * Takes priority
    */
    'TakesPriority': boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled': boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied': boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee': boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders': boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders': boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline': boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash': boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly': boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer': boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce': boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate': Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate': Date;
}

export namespace VoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Sample payload of a webhook event
*/
export class WebhookEventSample {
    /**
    * Event name
    */
    'Type': string;
    /**
    * Sample event creation date and time
    */
    'CreateTime': Date;
    /**
    * Sample event body
    */
    'Body': FlipdishEventBase;
}

/**
* Webhook log
*/
export class WebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId': number;
    /**
    * Event created
    */
    'EventCreated': string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered': string;
    /**
    * Webhook event name
    */
    'WebhookEventName': string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl': string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode': string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus': string;
    /**
    * Request headers
    */
    'RequestHeaders': string;
    /**
    * Request body
    */
    'RequestBody': string;
    /**
    * Received response headers
    */
    'ResponseHeaders': string;
    /**
    * Received response body
    */
    'ResponseBody': string;
    /**
    * Duration of HTTP request
    */
    'Duration': string;
    /**
    * Retry count
    */
    'RetryCount': number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId': string;
    /**
    * Flipdish webhook version
    */
    'Version': string;
}

/**
* Webhook subscription
*/
export class WebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id': number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId': number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version': string;
    /**
    * Webhook subscription event names
    */
    'EventNames': Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl': string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled': boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken': string;
}

/**
* 
*/
export class WebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class WebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* 
*/
export class WebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId': number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId': number;
    /**
    * Oauth client identifier
    */
    'ClientId': string;
    /**
    * Webhook callback url
    */
    'CallbackUrl': string;
}

/**
* 
*/
export class WebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName': string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Represents a website image
*/
export class WebsiteImage {
    /**
    * Represents the id of the image
    */
    'ImageId': number;
    /**
    * Represents the location of the image
    */
    'ImageLocation': WebsiteImage.ImageLocationEnum;
    /**
    * Represents the image url
    */
    'ImageUrl': string;
}

export namespace WebsiteImage {
    export enum ImageLocationEnum {
        IndexHeader = <any> 'IndexHeader',
        IndexAboutSectionLeft = <any> 'IndexAboutSectionLeft',
        IndexAboutSectionRight = <any> 'IndexAboutSectionRight',
        IndexGallery = <any> 'IndexGallery',
        IndexOpeningHoursHeader = <any> 'IndexOpeningHoursHeader',
        IndexTestimonialsHeader = <any> 'IndexTestimonialsHeader'
    }
}
/**
* Represents a testimonial
*/
export class WebsiteTestimonial {
    /**
    * Id of the testimonial
    */
    'TestimonialId': number;
    /**
    * Author of the testimonial
    */
    'Author': string;
    /**
    * Message of the testimonial
    */
    'Message': string;
}

/**
* Represents a testimonial base
*/
export class WebsiteTestimonialBase {
    /**
    * Author of the testimonial
    */
    'Author': string;
    /**
    * Message of the testimonial
    */
    'Message': string;
}

/**
* WebsiteUpdatedEvent
*/
export class WebsiteUpdatedEvent {
    /**
    * App Name id of the whitelabel of the website
    */
    'AppNameId': string;
    /**
    * User updating the website
    */
    'User': UserEventInfo;
    /**
    * Description of event
    */
    'Description': string;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}

/**
* Website vanity url
*/
export class WebsiteVanityUrlUpdatedEvent {
    /**
    * Description
    */
    'Description': string;
    /**
    * User who has updated the url
    */
    'User': UserEventInfo;
    /**
    * New vanity url
    */
    'VanityUrl': string;
    /**
    * The event name
    */
    'EventName': string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId': string;
    /**
    * The time of creation of the event
    */
    'CreateTime': Date;
    /**
    * Position
    */
    'Position': number;
    /**
    * App id
    */
    'AppId': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        this.authentications[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Answer a signup question
     * 
     * @param signupStepAction Signup step action
     * @param answerId Identifier of the answer
     */
    public answerSignUpQuestion (signupStepAction: string, answerId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', String(signupStepAction));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: answerId,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Change password
     * 
     * @param changePasswordModel Change password model
     */
    public changePassword (changePasswordModel: ChangePasswordModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: changePasswordModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Change password
     * 
     * @param changePasswordModel Change password model
     */
    public changePasswordWithPin (changePasswordModel: SetPasswordWithPinModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: changePasswordModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create account with email address and store name
     * 
     * @param createAccountModel Create account model
     */
    public createAccount (createAccountModel: CreateAccountModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: createAccountModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the current account detail
     * 
     */
    public getAccountDetails () : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get timezones localised to users language
     * 
     */
    public getLocalisedTimeZones () : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Login with username and password
     * 
     * @param loginModel Login model
     */
    public login (loginModel: LoginModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loginModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Login with username and password
     * 
     * @param loginModel Login model
     */
    public loginWithPin (loginModel: LoginWithPinModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loginModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Log out. It removes Flipdish authorization Cookie.
     * 
     */
    public logout () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reset password with token.
     * 
     * @param passwordResetModel Password reset model
     */
    public passwordResetWithToken (passwordResetModel: PasswordResetModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: passwordResetModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request login PIN. The server sends the PIN to the email address.
     * 
     * @param requestLoginPinRequest Request login PIN request
     */
    public requestLoginPin (requestLoginPinRequest: RequestLoginPinModel) : Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: requestLoginPinRequest,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request password reset. Flipdish system will send a token via email.
     * 
     * @param requestPasswordResetModel Request password reset model
     */
    public requestPasswordReset (requestPasswordResetModel: RequestPasswordResetModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: requestPasswordResetModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Skip a signup question
     * 
     * @param signupStepAction Signup step action
     */
    public skipSignupStep (signupStepAction: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', String(signupStepAction));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update account with name and language
     * 
     * @param updateAccountModel Update account model
     */
    public updateAccount (updateAccountModel: AccountDetailBase) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateAccountModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        this.authentications[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE API] Returns true if APM is enabled on at least one store in an application
     * 
     * @param appId App Id
     */
    public getApmStatus (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/status'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApmStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Basic Statistics
     * 
     * @param appId App Id
     * @param storeId List of stores to search by
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Calendar statistics
     * 
     * @param appId App Id
     * @param storeId List of stores to search by
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Calls Statistics
     * 
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     */
    public getCallsStatistics (appId: string, aggregateDataBy: string, dataPointLimit?: number, storeId?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'aggregateDataBy' + '}', String(aggregateDataBy));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            queryParameters['dataPointLimit'] = dataPointLimit;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Order Statistics (Value of Orders)
     * 
     * @param appId App Id
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     */
    public getOrderStatistics (appId: string, aggregateDataBy: string, dataPointLimit?: number, storeId?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'aggregateDataBy' + '}', String(aggregateDataBy));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            queryParameters['dataPointLimit'] = dataPointLimit;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get paginated APM call list
     * 
     * @param appId App Id
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeId List of stores to search by
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        this.authentications[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get the application configuration
     * 
     * @param appId Application identifier
     */
    public getApp (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the application hostname DNS delegation states for A and CNAME records.
     * A domain might be ready but still need 10 minutes to work properly because of HAProxy.
     * @param appId Application identifier.
     */
    public getAppHostnameStatus (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostnamestatus'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppHostnameStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Apps
     * 
     * @param nameFilter 
     * @param page 
     * @param limit 
     */
    public getApps (nameFilter?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the application compliance configuration
     * 
     * @param appId Application identifier
     */
    public getCompliance (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCompliance.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get panacea vanity url. This sets the URL which the Panacea website is available at. ie. my.flipdish.com/[vanityurl]
     * 
     * @param appId Application identifier.
     */
    public getPanaceaVanityUrl (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPanaceaVanityUrl.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all supported countries.
     * 
     */
    public getSupportedCountries () : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/supportedcountries';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Is panacea vanity url available
     * Minimum length of 3 characters
     * @param vanityUrl Vanity url to check
     * @param appId 
     */
    public isPanaceaVanityUrlAvailable (vanityUrl: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url/available'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        if (vanityUrl !== undefined) {
            queryParameters['vanityUrl'] = vanityUrl;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the application configuration
     * 
     * @param appId Application identifier
     * @param appConfigUpdate Changes to the configuration
     */
    public setAppConfig (appId: string, appConfigUpdate: AppConfigUpdateModel) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppConfig.');
        }

        // verify required parameter 'appConfigUpdate' is not null or undefined
        if (appConfigUpdate === null || appConfigUpdate === undefined) {
            throw new Error('Required parameter appConfigUpdate was null or undefined when calling setAppConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: appConfigUpdate,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the application hostname.
     * If no subdomain is specified in {hostname} &#39;www&#39; will be prepended.
     * @param appId Application identifier.
     * @param hostname The new Hostname.
     * @param isEmbed Will the website be embedded
     */
    public setAppHostname (appId: string, hostname: string, isEmbed?: boolean) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostname'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppHostname.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling setAppHostname.');
        }

        if (hostname !== undefined) {
            queryParameters['hostname'] = hostname;
        }

        if (isEmbed !== undefined) {
            queryParameters['isEmbed'] = isEmbed;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the application languages
     * 
     * @param appId Application identifier
     * @param languages New list of languages
     */
    public setAppLanguages (appId: string, languages: Array<Language>) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config/languages'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppLanguages.');
        }

        // verify required parameter 'languages' is not null or undefined
        if (languages === null || languages === undefined) {
            throw new Error('Required parameter languages was null or undefined when calling setAppLanguages.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: languages,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the application compliance configuration
     * 
     * @param appId Application identifier
     * @param complianceType Compliance type
     */
    public setCompliance (appId: string, complianceType: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setCompliance.');
        }

        // verify required parameter 'complianceType' is not null or undefined
        if (complianceType === null || complianceType === undefined) {
            throw new Error('Required parameter complianceType was null or undefined when calling setCompliance.');
        }

        if (complianceType !== undefined) {
            queryParameters['complianceType'] = complianceType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set panacea vanity url
     * Minimum length of 3 characters
     * @param appId Application identifier.
     * @param vanityUrl Vanity url
     */
    public setPanaceaVanityUrl (appId: string, vanityUrl: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setPanaceaVanityUrl.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling setPanaceaVanityUrl.');
        }

        if (vanityUrl !== undefined) {
            queryParameters['vanityUrl'] = vanityUrl;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the application logo \\ icon
     * 
     * @param appId Application identifier
     * @param image App Logo
     */
    public uploadAppLogo (appId: string, image: any) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/logo'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadAppLogo.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadAppLogo.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        this.authentications[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get authorization tokens
     * 
     * @param oauthAppId Client identifier
     * @param appId 
     * @param page Requested page number
     * @param limit Requested page limit
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revoke token
     * 
     * @param key Token identifier key
     * @param appId 
     */
    public revokeToken (key: string, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', String(key))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        this.authentications[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE API] Attach Bank Account to Store
     * 
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param storeId Store to be attached to Bank account
     */
    public attachBankAccountToStore (appId: string, bankAccountId: number, storeId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new Bank Account and attach to this App
     * 
     * @param appId App Name
     * @param account Account to be created
     */
    public createBankAccount (appId: string, account: BankAccountCreate) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: account,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete BankAccount
     * 
     * @param appId App Name
     * @param bankAccountId Id of account to be marked as deleted
     */
    public deleteBankAccount (appId: string, bankAccountId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling deleteBankAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get BankAccount Detail by Id
     * 
     * @param bankAccountId Id of account
     * @param appId 
     */
    public getBankAccountById (bankAccountId: number, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getBankAccountById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccountById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get List of BankAccounts for WL
     * 
     * @param appId App Name
     */
    public getBankAccounts (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get bank account fields definitions
     * 
     * @param appId 
     */
    public getCountriesWithFieldDefinitions (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/countries-field-definitions'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCountriesWithFieldDefinitions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get bank account fields definitions
     * 
     * @param appId 
     */
    public getFieldDefinitions (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/field-definitions'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFieldDefinitions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update BankAccount
     * 
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param account Details to update account with
     */
    public updateBankAccount (appId: string, bankAccountId: number, account: BankAccountCreate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: account,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Update State of Bank Account
     * 
     * @param appId App Name
     * @param bankAccountId Id of account to be updated
     * @param state New state
     * @param reason Reason for state change, Mandatory for rejections
     */
    public updateBankAccountState (appId: string, bankAccountId: number, state: string, reason: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/state/{state}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling updateBankAccountState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: reason,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        this.authentications[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Creates loyalty campaign
     * 
     * @param appId App Name Id
     * @param campaign Loyalty campaign details
     */
    public createLoyaltyCampaign (appId: string, campaign: LoyaltyCampaignBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createLoyaltyCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaign,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates retention campaign
     * 
     * @param appId App Name Id
     * @param campaign Retention campaign details
     */
    public createRetentionCampaign (appId: string, campaign: RetentionCampaignBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createRetentionCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaign,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets loyalty campaigns for app
     * 
     * @param appId App Name Id
     */
    public getLoyaltyCampaignsForApp (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets loyalty campaigns for store
     * 
     * @param appId App Name Id
     * @param storeId Store Id
     */
    public getLoyaltyCampaignsForStore (appId: string, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{storeId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets retention campaigns for app
     * 
     * @param appId App Name Id
     */
    public getRetentionCampaignsForApp (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets retention campaigns for store
     * 
     * @param appId App Name Id
     * @param storeId Store Id
     */
    public getRetentionCampaignsForStore (appId: string, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{storeId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets list of stores for app
     * 
     * @param appId App Name Id
     */
    public getStoreList (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/stores'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a campaign
     * 
     * @param appId App Name Id
     * @param campaignId Campaign Id
     */
    public removeCampaign (appId: string, campaignId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/{campaignId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'campaignId' + '}', String(campaignId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates loyalty campaign
     * 
     * @param appId App Name Id
     * @param campaignId Loyalty campaign Id
     * @param campaign Loyalty campaign details
     */
    public updateLoyaltyCampaign (appId: string, campaignId: number, campaign: LoyaltyCampaignBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{campaignId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'campaignId' + '}', String(campaignId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateLoyaltyCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaign,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates retention campaign
     * 
     * @param appId App Name Id
     * @param campaignId Retention campaign Id
     * @param campaign Retention campaign details
     */
    public updateRetentionCampaign (appId: string, campaignId: number, campaign: RetentionCampaignBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{campaignId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'campaignId' + '}', String(campaignId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRetentionCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: campaign,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardReadersApiApiKeys {
}

export class CardReadersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CardReadersApiApiKeys, value: string) {
        this.authentications[CardReadersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get Authorization Key for Stripe Terminal
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     */
    public authorizeStripeTerminal () : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }> {
        const localVarPath = this.basePath + '/api/v1.0/cardreaders/authorize/stripe';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Authorization Key for Stripe Terminal
     * Can only be called by Kiosk  [BETA - this endpoint is under development, do not use it in your production system]
     * @param appId 
     */
    public authorizeStripeTerminal_1 (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/authorize'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling authorizeStripeTerminal_1.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalPrivateKey;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the status of the bluetooth terminal
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @param appId 
     * @param deviceId 
     */
    public getBluetoothTerminalStatus (appId: string, deviceId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/status'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Trigger check for Bluetooth device update on Kiosk
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     */
    public initiateBluetoothTerminalDeviceUpdateCheck (appId: string, deviceId: string, terminalType: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/checkForUpdate'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId))
            .replace('{' + 'terminalType' + '}', String(terminalType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Initiate stripe terminal pairing mode
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     */
    public initiateKioskBluetoothPairingMode (appId: string, deviceId: string, terminalType: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/pair'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId))
            .replace('{' + 'terminalType' + '}', String(terminalType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     */
    public initiateKioskUpdateInstallForBluetoothTerminal (appId: string, deviceId: string, terminalType: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/installUpdate'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId))
            .replace('{' + 'terminalType' + '}', String(terminalType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskUpdateInstallForBluetoothTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskUpdateInstallForBluetoothTerminal.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskUpdateInstallForBluetoothTerminal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpair the currently paired stripe terminal
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @param appId 
     * @param deviceId 
     */
    public unpairCurrentlyPairedBluetoothDevice (appId: string, deviceId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/unpair'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentSecurityPolicyApiApiKeys {
}

export class ContentSecurityPolicyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContentSecurityPolicyApiApiKeys, value: string) {
        this.authentications[ContentSecurityPolicyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param request 
     */
    public contentSecurityPolicyReport (request: CspReportRequest) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/csp/report';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling contentSecurityPolicyReport.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: request,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomersApiApiKeys {
}

export class CustomersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CustomersApiApiKeys, value: string) {
        this.authentications[CustomersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get customer of an app by Id
     * 
     * @param appId App Name Id
     * @param customerId Customer Id
     */
    public getCustomerById (appId: string, customerId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'customerId' + '}', String(customerId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update customer of an app by Id
     * 
     * @param appId App Name Id
     * @param customerId Customer Id
     * @param updateCustomer Updated customer information
     */
    public updateCustomerById (appId: string, customerId: number, updateCustomer: CustomerUpdateModel) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'customerId' + '}', String(customerId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'updateCustomer' is not null or undefined
        if (updateCustomer === null || updateCustomer === undefined) {
            throw new Error('Required parameter updateCustomer was null or undefined when calling updateCustomerById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateCustomer,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryTrackingApiApiKeys {
}

export class DeliveryTrackingApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DeliveryTrackingApiApiKeys, value: string) {
        this.authentications[DeliveryTrackingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE] Assign driver to order
     * 
     * @param appId Application identifier
     * @param orderId Order Id
     * @param driverId Driver Id
     */
    public assignDriverToOrder (appId: string, orderId: number, driverId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders/{orderId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'orderId' + '}', String(orderId))
            .replace('{' + 'driverId' + '}', String(driverId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assign driver to multiple orders
     * 
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param orderIdAndSequenceNumbers Array of object containing OrderId and Sequence
     */
    public assignDriverToOrders (appId: string, driverId: number, orderIdAndSequenceNumbers: Array<OrderIdAndSequenceNumber>) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'driverId' + '}', String(driverId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'orderIdAndSequenceNumbers' is not null or undefined
        if (orderIdAndSequenceNumbers === null || orderIdAndSequenceNumbers === undefined) {
            throw new Error('Required parameter orderIdAndSequenceNumbers was null or undefined when calling assignDriverToOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderIdAndSequenceNumbers,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Get drivers by App
     * 
     * @param appId Application identifier
     * @param name Driver&#39;s username
     * @param phoneNumber Driver&#39;s phone number
     * @param storeId Store Id
     * @param presence Offline/Online
     */
    public getDrivers (appId: string, name?: string, phoneNumber?: string, storeId?: number, presence?: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getDrivers.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (phoneNumber !== undefined) {
            queryParameters['phoneNumber'] = phoneNumber;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (presence !== undefined) {
            queryParameters['presence'] = presence;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriver;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Invite driver
     * 
     * @param appId Application identifier
     * @param driverInvitation Driver invitation model
     */
    public inviteDriverToApp (appId: string, driverInvitation: DriverInvitation) : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling inviteDriverToApp.');
        }

        // verify required parameter 'driverInvitation' is not null or undefined
        if (driverInvitation === null || driverInvitation === undefined) {
            throw new Error('Required parameter driverInvitation was null or undefined when calling inviteDriverToApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: driverInvitation,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Unassign driver from app
     * 
     * @param appId Application identifier
     * @param driverId Driver Id
     */
    public removeDriverFromApp (appId: string, driverId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'driverId' + '}', String(driverId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeDriverFromApp.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling removeDriverFromApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Unassign driver from order
     * 
     * @param appId Application identifier
     * @param orderId Order Id
     */
    public unassignDriverFromOrder (appId: string, orderId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/{orderId}/driver'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'orderId' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignDriverFromOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling unassignDriverFromOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        this.authentications[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Adds a delivery zone to the store id
     * 
     * @param storeId Store Id to which the delivery zone will be added
     * @param deliveryZoneBase Optional delivery zone, if not supplied will create a default zone
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: DeliveryZoneBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deliveryZoneBase,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the delivery zones associated with a store
     * 
     * @param storeId Store Id to which the delivery zones are associated
     */
    public getDeliveryZones (storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes the existing delivery zone
     * 
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be removed
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryZoneId' + '}', String(deliveryZoneId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the existing delivery zone
     * 
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be updated
     * @param deliveryZone Delta of delivery zone parameters that need to be changed
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: DeliveryZoneBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryZoneId' + '}', String(deliveryZoneId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deliveryZone,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DriversApiApiKeys {
}

export class DriversApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DriversApiApiKeys, value: string) {
        this.authentications[DriversApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Add driver token
     * 
     * @param updateDriverToken 
     */
    public addDriverNotificationToken (updateDriverToken: UpdateDriverNotificationToken) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateDriverToken' is not null or undefined
        if (updateDriverToken === null || updateDriverToken === undefined) {
            throw new Error('Required parameter updateDriverToken was null or undefined when calling addDriverNotificationToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateDriverToken,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete driver profile image
     * 
     */
    public deleteDriverProfileImage () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Login with phone number and pin
     * 
     * @param driverLoginModel Driver request login code model
     */
    public driverLogin (driverLoginModel: DriverLoginModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/login';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'driverLoginModel' is not null or undefined
        if (driverLoginModel === null || driverLoginModel === undefined) {
            throw new Error('Required parameter driverLoginModel was null or undefined when calling driverLogin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: driverLoginModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Request an SMS to be sent to the driver with their login code
     * 
     * @param driverRequestLoginPinModel Driver request login code model
     */
    public driverRequestLoginCodeSms (driverRequestLoginPinModel: DriverRequestLoginPinModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/pin';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'driverRequestLoginPinModel' is not null or undefined
        if (driverRequestLoginPinModel === null || driverRequestLoginPinModel === undefined) {
            throw new Error('Required parameter driverRequestLoginPinModel was null or undefined when calling driverRequestLoginCodeSms.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: driverRequestLoginPinModel,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get driver profile
     * 
     */
    public getDriverProfile () : Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDriver;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get stores for driver
     * 
     */
    public getStoresForDriver () : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/assignedstores';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDriverStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete driver token
     * 
     * @param removeDriverToken 
     */
    public removeDriverNotificationToken (removeDriverToken: UpdateDriverNotificationToken) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'removeDriverToken' is not null or undefined
        if (removeDriverToken === null || removeDriverToken === undefined) {
            throw new Error('Required parameter removeDriverToken was null or undefined when calling removeDriverNotificationToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: removeDriverToken,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param storeId 
     * @param presence 
     */
    public setDriverPresenceForStore (storeId: number, presence: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/stores/{storeId}/presence/{presence}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'presence' + '}', String(presence));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setDriverPresenceForStore.');
        }

        // verify required parameter 'presence' is not null or undefined
        if (presence === null || presence === undefined) {
            throw new Error('Required parameter presence was null or undefined when calling setDriverPresenceForStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set driver profile image and returns it&#39;s url
     * 
     */
    public setDriverProfileImage () : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Change delivery tracking status and return the updated status.
     * ...
     * @param orderId Order identifier
     * @param deliveryTrackingStatus 
     */
    public updateDeliveryTrackingStatus (orderId: number, deliveryTrackingStatus: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/tracking/{deliveryTrackingStatus}'
            .replace('{' + 'orderId' + '}', String(orderId))
            .replace('{' + 'deliveryTrackingStatus' + '}', String(deliveryTrackingStatus));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        // verify required parameter 'deliveryTrackingStatus' is not null or undefined
        if (deliveryTrackingStatus === null || deliveryTrackingStatus === undefined) {
            throw new Error('Required parameter deliveryTrackingStatus was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update driver profile
     * 
     * @param updateDriverProfile Update the driver profile (i.e Name)
     */
    public updateDriverProfile (updateDriverProfile: UpdateDriverProfileModel) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateDriverProfile' is not null or undefined
        if (updateDriverProfile === null || updateDriverProfile === undefined) {
            throw new Error('Required parameter updateDriverProfile was null or undefined when calling updateDriverProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateDriverProfile,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        this.authentications[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get customer events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', String(customerId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getEvents (whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (whiteLabelId !== undefined) {
            queryParameters['whiteLabelId'] = whiteLabelId;
        }

        if (customerId !== undefined) {
            queryParameters['customerId'] = customerId;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get event by Id  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param eventId Event identifier (Guid)
     */
    public getEventsById (eventId: string) : Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get order events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId2 !== undefined) {
            queryParameters['orderId'] = orderId2;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get order events by customer  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            queryParameters['customerId'] = customerId;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get store events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId2 !== undefined) {
            queryParameters['storeId'] = storeId2;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get user events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId2?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId2 !== undefined) {
            queryParameters['userId'] = userId2;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get WhiteLabel events  For technical reasons, the number of records returned is limited to 100.
     * 
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', String(whitelabelId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (orderId !== undefined) {
            queryParameters['orderId'] = orderId;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        if (userId !== undefined) {
            queryParameters['userId'] = userId;
        }

        if (userEmail !== undefined) {
            queryParameters['userEmail'] = userEmail;
        }

        if (userName !== undefined) {
            queryParameters['userName'] = userName;
        }

        if (voucherCode !== undefined) {
            queryParameters['voucherCode'] = voucherCode;
        }

        if (eventType !== undefined) {
            queryParameters['eventType'] = eventType;
        }

        if (flipdishEventId !== undefined) {
            queryParameters['flipdishEventId'] = flipdishEventId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FilesApiApiKeys {
}

export class FilesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FilesApiApiKeys, value: string) {
        this.authentications[FilesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get file from storage
     * 
     * @param appId 
     * @param fileId 
     */
    public downloadFile (appId: string, fileId: string) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/files/download/{fileId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'fileId' + '}', String(fileId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling downloadFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling downloadFile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        this.authentications[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     */
    public headHostname () : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public headPing () : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public hostname () : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public ping () : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        this.authentications[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE API] Complete Home Action
     * 
     * @param appId App Name Id
     * @param homeActionId Id of the action
     * @param isDismissed 
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'homeActionId' + '}', String(homeActionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            queryParameters['isDismissed'] = isDismissed;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Complete Home Action
     * 
     */
    public dismissOldPortalAction () : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/home/dismissoldportalaction';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Home Actions
     * 
     * @param appId App Name Id
     */
    public getHomeActions (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get Home Statistics
     * 
     * @param appId App Name Id
     */
    public getHomeStatistics (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        this.authentications[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get API interaction logs
     * 
     * @param start Start date time
     * @param end End date time
     * @param appId 
     * @param filterByUserId User id (optional)
     * @param guid Id of the log
     * @param page Page number
     * @param limit Page size
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, guid?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (filterByUserId !== undefined) {
            queryParameters['filterByUserId'] = filterByUserId;
        }

        if (guid !== undefined) {
            queryParameters['guid'] = guid;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        this.authentications[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Assign an EMV terminal to a kiosk
     * 
     * @param appId 
     * @param hydraConfigId 
     * @param emvTerminalId 
     */
    public assignEmv (appId: string, hydraConfigId: number, emvTerminalId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/assign/{hydraConfigId}/{emvTerminalId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'hydraConfigId' + '}', String(hydraConfigId))
            .replace('{' + 'emvTerminalId' + '}', String(emvTerminalId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'emvTerminalId' is not null or undefined
        if (emvTerminalId === null || emvTerminalId === undefined) {
            throw new Error('Required parameter emvTerminalId was null or undefined when calling assignEmv.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param deviceId 
     * @param storeId 
     */
    public attachStoreToTerminal (appId: string, deviceId: string, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/attach/{storeId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToTerminal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param orderId 
     * @param appId 
     */
    public cancelEmvPayment (orderId: number, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/cancelemvpayment/{orderId}'
            .replace('{' + 'orderId' + '}', String(orderId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelEmvPayment.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelEmvPayment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param deviceId 
     * @param storeId 
     */
    public detachStoreFromTerminal (appId: string, deviceId: string, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/detach/{storeId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromTerminal.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param deviceType 
     * @param pageIndex 
     * @param pageSize 
     * @param storeId 
     * @param deviceName 
     * @param deviceSerial 
     */
    public getAttachedDevices (appId: string, deviceType: string, pageIndex?: number, pageSize?: number, storeId?: number, deviceName?: string, deviceSerial?: string) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/list'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceType' + '}', String(deviceType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevices.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevices.');
        }

        if (pageIndex !== undefined) {
            queryParameters['pageIndex'] = pageIndex;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (deviceName !== undefined) {
            queryParameters['deviceName'] = deviceName;
        }

        if (deviceSerial !== undefined) {
            queryParameters['deviceSerial'] = deviceSerial;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     */
    public getEMVTerminalDetails (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEMVTerminalDetails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param orderId 
     * @param appId 
     */
    public getEmvOrderState (orderId: number, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvorderstate/{orderId}'
            .replace('{' + 'orderId' + '}', String(orderId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmvOrderState.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEmvOrderState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public getRegistration () : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     */
    public getSettings () : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param emv 
     */
    public hydraCreateEmv (appId: string, emv: EmvTerminal) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraCreateEmv.');
        }

        // verify required parameter 'emv' is not null or undefined
        if (emv === null || emv === undefined) {
            throw new Error('Required parameter emv was null or undefined when calling hydraCreateEmv.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emv,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param id 
     */
    public hydraDeleteEmv (appId: string, id: number) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals/{id}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDeleteEmv.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hydraDeleteEmv.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List EMV terminals belonging to the given AppNameId
     * 
     * @param appId 
     */
    public hydraGetEmvsForAppId (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraGetEmvsForAppId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param deviceId 
     * @param hydraUserType 
     * @param serialNumber 
     */
    public loginWithDeviceId (deviceId: string, hydraUserType?: string, serialNumber?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling loginWithDeviceId.');
        }

        if (hydraUserType !== undefined) {
            queryParameters['hydraUserType'] = hydraUserType;
        }

        if (serialNumber !== undefined) {
            queryParameters['serialNumber'] = serialNumber;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param hydraRegistration 
     */
    public register (appId: string, hydraRegistration: HydraRegistrationRequest) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/registration'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling register.');
        }

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: hydraRegistration,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private]
     * 
     * @param appId 
     * @param deviceId 
     */
    public unAssign (appId: string, deviceId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/registration'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'deviceId' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unAssign.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unAssign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unassign the currently assigned EMV terminal from a kiosk
     * 
     * @param appId 
     * @param hydraConfigId 
     */
    public unassignEmv (appId: string, hydraConfigId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/unassign/{hydraConfigId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'hydraConfigId' + '}', String(hydraConfigId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling unassignEmv.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        this.authentications[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param storeId 
     */
    public lightspeedGenerateMenu (storeId: number) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param storeId 
     */
    public lightspeedGetStoreSettings (storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param storeId 
     * @param lightspeedSettings 
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: LightspeedSettings) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: lightspeedSettings,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        this.authentications[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create menu item option set item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuItemOptionSetItem,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu item option set item image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item option set item by identifier
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item option set items
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu item option set item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [Private API] Set Tax Rate on OptionSetItem
     * 
     * @param menuId Menu identifier
     * @param menuSectionId 
     * @param menuSectionItemId 
     * @param optionSetId 
     * @param menuItemOptionSetItemId Option set item identifier
     * @param taxRateId Tax Rate to use
     */
    public setOptionSetItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, taxRateId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId))
            .replace('{' + 'taxRateId' + '}', String(taxRateId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setOptionSetItemTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu item option set item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, undoAfter?: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            queryParameters['undoAfter'] = undoAfter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuItemOptionSetItem,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload menu item option set item image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param image Option set item image
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId))
            .replace('{' + 'menuItemOptionSetItemId' + '}', String(menuItemOptionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadOptionSetItemImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        this.authentications[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create menu item option set
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuItemOptionSet,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu item option set
     * 
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete option set image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item option set by identifier
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item option sets
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu item option set
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuItemOptionSet,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload menu item option set image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param image Option set image
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'optionSetId' + '}', String(optionSetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadOptionSetImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        this.authentications[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Clone menu section item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create menu section item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuSectionItem,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu section item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu section item image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item by identifier
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu items
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public getMenuItems (menuId: number, menuSectionId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Move an Item within a menu
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param destinationDisplayOrder New Display Order of item
     */
    public moveMenuItem (menuId: number, menuSectionId: number, menuSectionItemId: number, destinationDisplayOrder: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/setorder/{destinationDisplayOrder}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'destinationDisplayOrder' + '}', String(destinationDisplayOrder));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'destinationDisplayOrder' is not null or undefined
        if (destinationDisplayOrder === null || destinationDisplayOrder === undefined) {
            throw new Error('Required parameter destinationDisplayOrder was null or undefined when calling moveMenuItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Move an Item within a menu
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param taxRateId tax rate to be set against item
     */
    public setSectionItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, taxRateId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId))
            .replace('{' + 'taxRateId' + '}', String(taxRateId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setSectionItemTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu section item
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            queryParameters['undoAfter'] = undoAfter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuSectionItem,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload menu section item image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param image Menu section item image
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'menuSectionItemId' + '}', String(menuSectionItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        this.authentications[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Clone menu section
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public cloneMenuSection (menuId: number, menuSectionId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set/update menu section availability hours.
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek Day of the  week
     * @param businessHoursPeriod Menu section active hours, note: DayOfWeek property will be overriden by the path parameter.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: string, businessHoursPeriod: BusinessHoursPeriodBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId))
            .replace('{' + 'dayOfWeek' + '}', String(dayOfWeek));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: businessHoursPeriod,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create menu section
     * 
     * @param menuId Menu identifier
     * @param menuSection Menu section
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuSection,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create menu availability type
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability DisplayAlways, DisplayBasedOnTimes, DisplayAlwaysStartCollapsed, DisplayAlwaysStartCollapsedBasedOnTimes
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: MenuSectionAvailabilityBase) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuSectionAvailability,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu section
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public deleteMenuSection (menuId: number, menuSectionId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu section image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu section by identifier
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public getMenuSectionById (menuId: number, menuSectionId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu sections
     * 
     * @param menuId Menu identifier
     */
    public getMenuSections (menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Re-arrange Items within a Section
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param displayOrders Item Ids and their new display order
     */
    public menuSectionsSetItemDisplayOrders (menuId: number, menuSectionId: number, displayOrders: MenuObjectDisplayOrders) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitemdisplayorders'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: displayOrders,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu section
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase, undoAfter?: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            queryParameters['undoAfter'] = undoAfter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuSection,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload menu section image
     * 
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param image Menu section image
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'menuSectionId' + '}', String(menuSectionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadMenuSectionImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        this.authentications[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE API]Clone a menu, (without attaching stores)
     * 
     * @param menuId Menu identifier
     * @param newName Name of the new Menu
     */
    public createDraftMenuFromExistingMenu (menuId: number, newName: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone/{newName}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'newName' + '}', String(newName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        // verify required parameter 'newName' is not null or undefined
        if (newName === null || newName === undefined) {
            throw new Error('Required parameter newName was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new menu. If request body is empty, the system will create a menu with default items.
     * 
     * @param appId App identifier
     * @param menu Menu
     */
    public createNewMenuForApp (appId: string, menu: CreateFullMenu) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuForApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menu,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Mark a Menu as Deleted
     * 
     * @param menuId Menu Identifier
     */
    public deleteMenu (menuId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu image
     * 
     * @param menuId Menu identifier
     */
    public deleteMenuImage (menuId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete menu item metadata
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'menuItemId' + '}', String(menuItemId))
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all menu metadata by menu ID and store ID
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     */
    public getAllMenuMetadataByMenuIdAndStoreId (menuId: number, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu by identifier
     * 
     * @param menuId Menu identifier
     */
    public getMenuById (menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item metadata
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'menuItemId' + '}', String(menuItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item metadata by key
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'menuItemId' + '}', String(menuItemId))
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get menu item option set item metadata by key
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'optionSetItemId' + '}', String(optionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Get menus store names
     * 
     * @param menuId Menu identifier
     */
    public getMenuStoreNames (menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Get menus tax details
     * 
     * @param menuId Menu identifier
     */
    public getMenuTaxDetails (menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuTaxDetails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Get menus by appId
     * 
     * @param appId Get Menus for this appId
     */
    public getMenusByAppId (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Get a Menus Checkpoints
     * 
     * @param menuId Menu identifier
     */
    public getMenusCheckpoints (menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Remove a Menus Tax Rate, can only remove a tax rate that does not have items/optionSetItems attached
     * 
     * @param menuId Menu identifier
     * @param taxId Id of Menu Tax to be removed
     */
    public menusDeleteTaxRate (menuId: number, taxId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/{taxId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'taxId' + '}', String(taxId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusDeleteTaxRate.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling menusDeleteTaxRate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Set if tax shows for a Menu
     * 
     * @param menuId Menu identifier
     * @param show Boolean show or dont show tax (Exclusive tax type can only ever be TRUE)
     */
    public menusSetDisplayOnMenuTax (menuId: number, show: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/show/{show}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'show' + '}', String(show));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        // verify required parameter 'show' is not null or undefined
        if (show === null || show === undefined) {
            throw new Error('Required parameter show was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Re-arrange Sections within a Menu
     * 
     * @param menuId Menu identifier
     * @param displayOrders Section Ids and their new display order
     */
    public menusSetItemDisplayOrders (menuId: number, displayOrders: MenuObjectDisplayOrders) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sectiondisplayorders'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menusSetItemDisplayOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: displayOrders,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param menuId 
     * @param menuElements 
     * @param hide 
     * @param undoAfter 
     */
    public menusShowHideBulkItems (menuId: number, menuElements: Array<MenuElementHide>, hide: boolean, undoAfter: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'menuElements' is not null or undefined
        if (menuElements === null || menuElements === undefined) {
            throw new Error('Required parameter menuElements was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'hide' is not null or undefined
        if (hide === null || hide === undefined) {
            throw new Error('Required parameter hide was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'undoAfter' is not null or undefined
        if (undoAfter === null || undoAfter === undefined) {
            throw new Error('Required parameter undoAfter was null or undefined when calling menusShowHideBulkItems.');
        }

        if (hide !== undefined) {
            queryParameters['hide'] = hide;
        }

        if (undoAfter !== undefined) {
            queryParameters['undoAfter'] = undoAfter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menuElements,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Set the type of Tax on a Menu
     * 
     * @param menuId Menu identifier
     * @param type Type of Tax
     */
    public menusUpdateTaxType (menuId: number, type: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/type/{type}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'type' + '}', String(type));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpdateTaxType.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling menusUpdateTaxType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Add/Update a Tax Rate
     * 
     * @param menuId Menu identifier
     * @param taxRate Tax Rate to Add/Update
     */
    public menusUpsertTaxRate (menuId: number, taxRate: MenuTaxRate) : Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/taxrate'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpsertTaxRate.');
        }

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling menusUpsertTaxRate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxRate,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Restore a Menu to a checkpoint
     * 
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'checkpointId' + '}', String(checkpointId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu item metadata
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'menuItemId' + '}', String(menuItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: metadata,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu item option set item metadata
     * 
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', String(menuId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'optionSetItemId' + '}', String(optionSetItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: metadata,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Lock/Unlock a Menu for Editing
     * 
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     */
    public setMenuLock (menuId: number, locked: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: locked,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API]Set Menus Name
     * 
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     */
    public setMenuName (menuId: number, name: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: name,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update menu
     * 
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     */
    public updateMenu (menuId: number, menu: MenuBase) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: menu,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload menu image
     * 
     * @param menuId Menu identifier
     * @param image Menu image
     */
    public uploadMenuImage (menuId: number, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadMenuImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new menu from xlsx file.
     * 
     * @param appId App identifier
     * @param menu Uploaded xlsx menu
     */
    public uploadNewMenuForApp (appId: string, menu: any) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/xlsx'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling uploadNewMenuForApp.');
        }

        let useFormData = false;

        if (menu !== undefined) {
            formParams['Menu'] = menu;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        this.authentications[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create OAuth App redirect uri
     * 
     * @param oauthAppId OAuth App identifier
     * @param uri Redirect uri
     * @param appId 
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: uri,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create OAuth App
     * 
     * @param oAuthApp OAuth App
     * @param appId 
     */
    public createOAuthApp (oAuthApp: OAuthApp, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: oAuthApp,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete OAuth App
     * 
     * @param oauthAppId OAuth App identifier
     * @param appId 
     */
    public deleteOAuthApp (oauthAppId: string, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all OAuth Apps
     * 
     * @param appId 
     * @param oauthAppName 
     */
    public getOAuthApps (appId: string, oauthAppName?: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            queryParameters['oauthAppName'] = oauthAppName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get OAuth App by identifier
     * 
     * @param oauthAppId OAuth App identifier
     * @param appId 
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get OAuth App secret key
     * 
     * @param oauthAppId OAuth App identifier
     * @param appId 
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get OAuth access token for App
     * 
     * @param oauthAppId OAuth App identifier
     * @param appId 
     */
    public getOauthAccessToken (oauthAppId: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get OAuth App redirect uris
     * 
     * @param oauthAppId OAuth App identifier
     * @param appId 
     */
    public getRedirectUris (oauthAppId: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param appId 
     */
    public oAuthClientsGetApplications (appId: string) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete OAuth App redirect uri
     * 
     * @param oauthAppId OAuth App identifier
     * @param uriId Redirect uri identifier
     * @param appId 
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'uriId' + '}', String(uriId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update OAuth App
     * 
     * @param oauthAppId OAuth App identifier
     * @param oAuthApp OAuth App
     * @param appId 
     */
    public updateOAuthApp (oauthAppId: string, oAuthApp: OAuthApp, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateOAuthApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: oAuthApp,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        this.authentications[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Accept order
     * To accept an order, you create an &#x60;accept&#x60; object and send it to Flipdish API using HTTP POST method. &#x60;Id&#x60; path parameter identifies the order.
     * @param id Order identifier
     * @param acceptObject Order accept parameters (eg: EstimatedMinutesForDelivery)
     */
    public acceptOrder (id: number, acceptObject: Accept) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: acceptObject,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Dispatch order
     * To dispatch an order send a POST request with &#x60;Id&#x60; path parameter which identifies the order.
     * @param id Order identifier
     */
    public dispatchOrder (id: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get order by ID
     * 
     * @param id Order identifier
     */
    public getOrderById (id: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get orders by filter
     * 
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param from Order has been placed after this parameter value
     * @param to Order has been placed before this parameter value
     * @param page Requested page number
     * @param limit Requested page limit
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<string>, from?: Date, to?: Date, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (physicalRestaurantId !== undefined) {
            queryParameters['physicalRestaurantId'] = physicalRestaurantId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get summary of orders by filter
     * 
     * @param appId App Name Id
     * @param searchQuery Query string
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param orderByRequestedForTime 
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<string>, page?: number, limit?: number, orderByRequestedForTime?: boolean) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            queryParameters['searchQuery'] = searchQuery;
        }

        if (physicalRestaurantId !== undefined) {
            queryParameters['physicalRestaurantId'] = physicalRestaurantId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (orderByRequestedForTime !== undefined) {
            queryParameters['orderByRequestedForTime'] = orderByRequestedForTime;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refund order
     * To refund an order, you create a &#x60;refund&#x60; object and send it to Flipdish API using HTTP POST method. &#x60;Id&#x60; path parameter identifies the order.
     * @param id Order identifier
     * @param refundObject 
     */
    public refundOrder (id: number, refundObject: Refund) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: refundObject,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reject order
     * To reject an order, you create a &#x60;reject&#x60; object and send it to Flipdish API using HTTP POST method. &#x60;Id&#x60; path parameter identifies the order.
     * @param id Order identifier
     * @param rejectObject 
     */
    public rejectOrder (id: number, rejectObject: Reject) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rejectObject,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        this.authentications[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Returns payment refund information related to the order with the order id
     * 
     * @param orderId Order identifier
     */
    public getOrderPaymentInformation (orderId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payments/payment/{orderId}/refundable'
            .replace('{' + 'orderId' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderPaymentInformation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsApiApiKeys {
}

export class PayoutsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PayoutsApiApiKeys, value: string) {
        this.authentications[PayoutsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Export a list of payout&#39;s chargebacks as CSV
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     */
    public exportPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks/export'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutChargebacks.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export a list of payout&#39;s orders as CSV
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     */
    public exportPayoutOrders (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders/export'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOrders.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export a list of payout&#39;s other charges as CSV
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     */
    public exportPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges/export'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOtherCharges.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export a list of payout&#39;s refunds as CSV
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     */
    public exportPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds/export'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutRefunds.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export payout&#39;s details as CSV
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     */
    public exportPayoutStores (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/export'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutStores.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Payout details broken down by Store
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     */
    public getPayout (appId: string, bankAccountId: number, payoutId: number) : Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayout.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payout&#39;s chargebacks
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     */
    public getPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutChargebacks.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payout&#39;s orders
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     */
    public getPayoutOrders (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOrders.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payout&#39;s other charges
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     */
    public getPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOtherCharges.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payout&#39;s refunds
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     */
    public getPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId))
            .replace('{' + 'payoutId' + '}', String(payoutId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutRefunds.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payout summaries
     * BETA - this endpoint is under development, do not use it in your production system
     * @param appId 
     * @param bankAccountId 
     * @param payeeBankAccountDataId Deprecated
     * @param startDate 
     * @param endDate 
     * @param status 
     */
    public getPayoutSummaries (appId: string, bankAccountId?: number, payeeBankAccountDataId?: number, startDate?: Date, endDate?: Date, status?: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/summaries'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutSummaries.');
        }

        if (bankAccountId !== undefined) {
            queryParameters['bankAccountId'] = bankAccountId;
        }

        if (payeeBankAccountDataId !== undefined) {
            queryParameters['payeeBankAccountDataId'] = payeeBankAccountDataId;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of payouts
     * BETA - this endpoint is under development, do not use it in your production system
     * @param appId 
     * @param bankAccountId 
     * @param payeeBankAccountDataId Deprecated
     * @param startDate 
     * @param endDate 
     * @param status 
     * @param page 
     * @param limit 
     */
    public getPayouts (appId: string, bankAccountId?: number, payeeBankAccountDataId?: number, startDate?: Date, endDate?: Date, status?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayouts.');
        }

        if (bankAccountId !== undefined) {
            queryParameters['bankAccountId'] = bankAccountId;
        }

        if (payeeBankAccountDataId !== undefined) {
            queryParameters['payeeBankAccountDataId'] = payeeBankAccountDataId;
        }

        if (startDate !== undefined) {
            queryParameters['startDate'] = startDate;
        }

        if (endDate !== undefined) {
            queryParameters['endDate'] = endDate;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        this.authentications[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get processing fee configs by store identifiers
     * 
     * @param storeIds Store identifiers
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PushNotificationsApiApiKeys {
}

export class PushNotificationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PushNotificationsApiApiKeys, value: string) {
        this.authentications[PushNotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE] Push notification to cutomers
     * 
     * @param appId 
     * @param scheduledPushNotificationId ID of Scheduled push notifiaction to delete
     */
    public deletePushNotification (appId: string, scheduledPushNotificationId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'scheduledPushNotificationId' + '}', String(scheduledPushNotificationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling deletePushNotification.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Push notification to cutomers
     * 
     * @param appId 
     * @param page 
     * @param limit 
     */
    public getPushNotifications (appId: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPushNotifications.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Push notification to cutomers
     * 
     * @param appId Application Id
     * @param notification Notification to send
     */
    public schedulePushNotification (appId: string, notification: PushNotificationRequest) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling schedulePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling schedulePushNotification.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: notification,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE] Update the push notification
     * 
     * @param appId Application Id
     * @param scheduledPushNotificationId Notification Id
     * @param notification Notification to send
     */
    public updatePushNotification (appId: string, scheduledPushNotificationId: number, notification: PushNotificationRequest) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'scheduledPushNotificationId' + '}', String(scheduledPushNotificationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updatePushNotification.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: notification,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        this.authentications[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Creates a Store Group  It will be attached to an existing App
     * 
     * @param appNameId App Name Id
     * @param storeGroup Store group definition
     */
    public createStoreGroup (appNameId: string, storeGroup: StoreGroupBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', String(appNameId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: storeGroup,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a Store Groups
     * 
     * @param storeGroupId Store Group Id
     */
    public getStoreGroup (storeGroupId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', String(storeGroupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of Store Groups
     * 
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', String(appNameId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            queryParameters['searchQuery'] = searchQuery;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Returns a paginated list of Extended Store Groups
     * 
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param groupingRadius 
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', String(appNameId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            queryParameters['searchQuery'] = searchQuery;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (groupingRadius !== undefined) {
            queryParameters['groupingRadius'] = groupingRadius;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Store Group  Can only remove a store group if there is no stores attached to the group
     * 
     * @param storeGroupId Store Group Id
     */
    public removeStoreGroup (storeGroupId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', String(storeGroupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates Store Group
     * 
     * @param storeGroupId Store Group Id
     * @param storeGroup Store Group Delta
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: StoreGroupBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', String(storeGroupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: storeGroup,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreOrderCapacityApiApiKeys {
}

export class StoreOrderCapacityApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoreOrderCapacityApiApiKeys, value: string) {
        this.authentications[StoreOrderCapacityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get store&#39;s order capacity configuration
     * 
     * @param appId App Name Id
     * @param storeId Store Id
     * @param deliveryType Delivery / Pickup
     */
    public getStoreOrderCapacity (appId: string, storeId: number, deliveryType: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}/{deliveryType}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getStoreOrderCapacity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update a store&#39;s order capacity configuration
     * 
     * @param storeId Store identifier
     * @param deliveryType Delivery / Pickup
     * @param newOrderCapacityConfig new order capacity configuration
     * @param appId 
     */
    public updateStoreOrderCapacityConfig (storeId: number, deliveryType: string, newOrderCapacityConfig: StoreOrderCapacityConfigEditModel, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'newOrderCapacityConfig' is not null or undefined
        if (newOrderCapacityConfig === null || newOrderCapacityConfig === undefined) {
            throw new Error('Required parameter newOrderCapacityConfig was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        if (deliveryType !== undefined) {
            queryParameters['deliveryType'] = deliveryType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newOrderCapacityConfig,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        this.authentications[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Archive store
     * 
     * @param storeId Store identifier
     */
    public archiveStore (storeId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/archive'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling archiveStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Assign Menu to Store
     * 
     * @param storeId Store identifier
     * @param menuId Id of Menu to assign to store
     */
    public assignMenu (storeId: number, menuId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/menu/{menuId}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'menuId' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling assignMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clone store with store clone settings
     * 
     * @param storeId Store identifier
     * @param settings Settings for cloning the store
     */
    public cloneStore (storeId: number, settings: StoreCloneSettings) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: settings,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create Business Hours Override for a store
     * 
     * @param storeId Store identifier
     * @param businessHoursOverride Business Hours Override
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: BusinessHoursOverrideBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: businessHoursOverride,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create store with Store Group identifier
     * 
     * @param storeGroupId Store Group identifier
     * @param store Store
     */
    public createStore (storeGroupId: number, store: StoreCreateBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: store,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete Business Hours Override for a store
     * 
     * @param storeId 
     * @param businessHoursOverrideId 
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'businessHoursOverrideId' + '}', String(businessHoursOverrideId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Stores Bank Account Id
     * 
     * @param storeId Store identifier
     */
    public getBankAccountForStore (storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccountForStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Business hours
     * 
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     */
    public getBusinessHours (storeId: number, deliveryType: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get business hours overrides by store identifier
     * 
     * @param storeId Store identifier
     * @param after Return results that ended after this datetime. Default value is the current datetime.
     * @param page Requested page index
     * @param limit Requested page limit
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get store end of day report
     * 
     * @param storeId Store identifier
     * @param date Store identifier
     */
    public getEndOfDayReport (storeId: number, date?: Date) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/endofdayreport'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getEndOfDayReport.');
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the pre order config for a store, by type
     * 
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     */
    public getPreOrderConfig (storeId: number, deliveryType: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the Preview times of the pre-order configuration
     * 
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfigLeadTimeMinutes Lead Time in Minutes
     * @param preOrderConfigIntervalMinutes Interval in minutes
     * @param preOrderConfigMaxOrderAheadDays Max Days to order ahead
     * @param preOrderConfigIncludeAsap Show ASAP as option
     * @param preOrderConfigIncludeMoreGranularInitialTime Granual Init&#39; Time
     * @param preOrderConfigCutOffTimePreviousDayBasic Cut off time previous day
     * @param preOrderConfigCutOffTimeCurrentDayBasic Cut off time current day
     * @param preOrderConfigPreOrderTimeDisplayType Type of time displayed.
     * @param preOrderConfigAlwaysAppearOpen Specifies whether a customer can pre-order outside the store opening hours or not.
     * @param preOrderConfigRequireExplicitSelectAlways Force customer to select collection time.
     */
    public getPreOrderPreview (storeId: number, deliveryType: string, preOrderConfigLeadTimeMinutes?: number, preOrderConfigIntervalMinutes?: number, preOrderConfigMaxOrderAheadDays?: number, preOrderConfigIncludeAsap?: boolean, preOrderConfigIncludeMoreGranularInitialTime?: boolean, preOrderConfigCutOffTimePreviousDayBasic?: string, preOrderConfigCutOffTimeCurrentDayBasic?: string, preOrderConfigPreOrderTimeDisplayType?: string, preOrderConfigAlwaysAppearOpen?: boolean, preOrderConfigRequireExplicitSelectAlways?: boolean) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/preview'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderPreview.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderPreview.');
        }

        if (preOrderConfigLeadTimeMinutes !== undefined) {
            queryParameters['preOrderConfig.leadTimeMinutes'] = preOrderConfigLeadTimeMinutes;
        }

        if (preOrderConfigIntervalMinutes !== undefined) {
            queryParameters['preOrderConfig.intervalMinutes'] = preOrderConfigIntervalMinutes;
        }

        if (preOrderConfigMaxOrderAheadDays !== undefined) {
            queryParameters['preOrderConfig.maxOrderAheadDays'] = preOrderConfigMaxOrderAheadDays;
        }

        if (preOrderConfigIncludeAsap !== undefined) {
            queryParameters['preOrderConfig.includeAsap'] = preOrderConfigIncludeAsap;
        }

        if (preOrderConfigIncludeMoreGranularInitialTime !== undefined) {
            queryParameters['preOrderConfig.includeMoreGranularInitialTime'] = preOrderConfigIncludeMoreGranularInitialTime;
        }

        if (preOrderConfigCutOffTimePreviousDayBasic !== undefined) {
            queryParameters['preOrderConfig.cutOffTimePreviousDayBasic'] = preOrderConfigCutOffTimePreviousDayBasic;
        }

        if (preOrderConfigCutOffTimeCurrentDayBasic !== undefined) {
            queryParameters['preOrderConfig.cutOffTimeCurrentDayBasic'] = preOrderConfigCutOffTimeCurrentDayBasic;
        }

        if (preOrderConfigPreOrderTimeDisplayType !== undefined) {
            queryParameters['preOrderConfig.preOrderTimeDisplayType'] = preOrderConfigPreOrderTimeDisplayType;
        }

        if (preOrderConfigAlwaysAppearOpen !== undefined) {
            queryParameters['preOrderConfig.alwaysAppearOpen'] = preOrderConfigAlwaysAppearOpen;
        }

        if (preOrderConfigRequireExplicitSelectAlways !== undefined) {
            queryParameters['preOrderConfig.requireExplicitSelectAlways'] = preOrderConfigRequireExplicitSelectAlways;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get processing fee configs by store identifier
     * 
     * @param storeId Store identifier
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            queryParameters['appNameId'] = appNameId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get processing fee configs by store identifier
     * 
     * @param storeId Store identifier
     * @param paymentAccountType 
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: string, appNameId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'paymentAccountType' + '}', String(paymentAccountType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            queryParameters['appNameId'] = appNameId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get store by identifier
     * 
     * @param storeId Store identifier
     */
    public getStoreById (storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all stores by app name id
     * 
     * @param appId App Name Id
     * @param storeNameQuery 
     * @param page 
     * @param limit 
     */
    public getStoreHeadersByAppId (appId: string, storeNameQuery?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/header'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreHeadersByAppId.');
        }

        if (storeNameQuery !== undefined) {
            queryParameters['storeNameQuery'] = storeNameQuery;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get stores statistics by app name id and storeIds
     * 
     * @param appId App Name Id
     * @param storeId Store Ids
     */
    public getStoreNetSales (appId: string, storeId: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all stores, excluding archived ones
     * 
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeGroupId Store Group Id
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (searchQuery !== undefined) {
            queryParameters['searchQuery'] = searchQuery;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (storeGroupId !== undefined) {
            queryParameters['storeGroupId'] = storeGroupId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all stores by app name id
     * 
     * @param appId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            queryParameters['searchQuery'] = searchQuery;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publish store
     * 
     * @param storeId Store identifier
     */
    public publishStore (storeId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/publish'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling publishStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set Business hours
     * 
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param businessHoursPeriod Business Hours Period
     */
    public setBusinessHours (storeId: number, deliveryType: string, businessHoursPeriod: BusinessHoursPeriodBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: businessHoursPeriod,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * UPDATE pre order config for a store, by type
     * 
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param enabled Update pre order config values
     */
    public setPreOrdeEnabled (storeId: number, deliveryType: string, enabled: boolean) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/enabled'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'enabled' is not null or undefined
        if (enabled === null || enabled === undefined) {
            throw new Error('Required parameter enabled was null or undefined when calling setPreOrdeEnabled.');
        }

        if (enabled !== undefined) {
            queryParameters['enabled'] = enabled;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublish store
     * 
     * @param storeId Store identifier
     */
    public unpublishStore (storeId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/unpublish'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unpublishStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * UPDATE pre order config for a store, by type
     * 
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig Update pre order config values
     */
    public updatePreOrderConfig (storeId: number, deliveryType: string, preOrderConfig: PreOrderConfig) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', String(storeId))
            .replace('{' + 'deliveryType' + '}', String(deliveryType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'preOrderConfig' is not null or undefined
        if (preOrderConfig === null || preOrderConfig === undefined) {
            throw new Error('Required parameter preOrderConfig was null or undefined when calling updatePreOrderConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: preOrderConfig,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update store by identifier
     * 
     * @param storeId Store Group identifier
     * @param store Store
     */
    public updateStore (storeId: number, store: StoreBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: store,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update store address
     * 
     * @param storeId Store identifier
     * @param storeAddress Store address
     */
    public updateStoreAddress (storeId: number, storeAddress: StoreAddressBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: storeAddress,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update store address coordinates
     * 
     * @param storeId Store identifier
     * @param coordinates Store address coordinates
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: Coordinates, appNameId?: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            queryParameters['appNameId'] = appNameId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: coordinates,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectApiApiKeys {
}

export class StripeCustomConnectApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StripeCustomConnectApiApiKeys, value: string) {
        this.authentications[StripeCustomConnectApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create a new Bank Account and Stripe connected account
     * 
     * @param appId App Name
     * @param account Account to be created
     */
    public createBankAccountAndConnectedAccount (appId: string, account: BankAccountCreate) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: account,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update a Stripe connected account associated with the bank account of bankAccountId
     * 
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     */
    public createStripeConnectedAccount (appId: string, bankAccountId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/create-update-account'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling createStripeConnectedAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets a single-use Stripe URL for the given account
     * 
     * @param appId App Name
     * @param stripeConnectedAccountId Stripe Connected Account Id
     * @param stripeAccountLinkRequest 
     */
    public createStripeConnectedAccountLink (appId: string, stripeConnectedAccountId: string, stripeAccountLinkRequest: StripeAccountLinkRequest) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{stripeConnectedAccountId}/create-account-link'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'stripeConnectedAccountId' + '}', String(stripeConnectedAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeAccountLinkRequest' is not null or undefined
        if (stripeAccountLinkRequest === null || stripeAccountLinkRequest === undefined) {
            throw new Error('Required parameter stripeAccountLinkRequest was null or undefined when calling createStripeConnectedAccountLink.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stripeAccountLinkRequest,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the current verification status of the given connected account
     * 
     * @param appId 
     * @param stripeConnectedAccountId 
     */
    public getVerificationStatus (appId: string, stripeConnectedAccountId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/verification-status'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVerificationStatus.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling getVerificationStatus.');
        }

        if (stripeConnectedAccountId !== undefined) {
            queryParameters['stripeConnectedAccountId'] = stripeConnectedAccountId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update bank account&#39;s BusinessType and create a Stripe Connected Account
     * 
     * @param appId App Name
     * @param bankAccountId Bank Account Id
     * @param businessType Bank Account business type
     */
    public setBankAccountBusinessType (appId: string, bankAccountId: number, businessType: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account/{bankAccountId}/businesstype'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'businessType' is not null or undefined
        if (businessType === null || businessType === undefined) {
            throw new Error('Required parameter businessType was null or undefined when calling setBankAccountBusinessType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: businessType,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param linkRequestId 
     * @param appId 
     */
    public stripeCustomConnectRefresh (linkRequestId: number, appId: string) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/refresh-link'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'linkRequestId' is not null or undefined
        if (linkRequestId === null || linkRequestId === undefined) {
            throw new Error('Required parameter linkRequestId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        if (linkRequestId !== undefined) {
            queryParameters['linkRequestId'] = linkRequestId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update bank account details
     * 
     * @param appId App Name Id
     * @param bankAccountId Bank Account Id
     * @param updateRequest fields to be updated
     */
    public updateBankAccountDetails (appId: string, bankAccountId: number, updateRequest: BankAccountDetailsUpdateRequest) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/update-bank-account-details'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'bankAccountId' + '}', String(bankAccountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'updateRequest' is not null or undefined
        if (updateRequest === null || updateRequest === undefined) {
            throw new Error('Required parameter updateRequest was null or undefined when calling updateBankAccountDetails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateRequest,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        this.authentications[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Cancel a stuart job
     * 
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     */
    public stuartCancelJob (jobId: number, storeId: number) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', String(jobId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get start job details
     * 
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     */
    public stuartGetJob (jobId: number, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', String(jobId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get stuart settings for a store
     * 
     * @param storeId Store Identifier
     */
    public stuartGetStuartSettings (storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set stuart settings for a store
     * 
     * @param storeId Store Identifier
     * @param stuartSettings Stuart settings model
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: StuartSettings) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stuartSettings,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        this.authentications[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create teammate and send an invite.
     * 
     * @param appId Application identifier
     * @param teammate teammate model
     */
    public createTeammate (appId: string, teammate: CreateTeammate) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: teammate,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete teammate
     * 
     * @param appId 
     * @param id 
     */
    public deleteTeammate (appId: string, id: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a teammates by email address
     * 
     * @param appId 
     * @param id 
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all teammates
     * 
     * @param appId 
     */
    public getTeammatesByAppId (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Redeem one-time code from invitation
     * 
     * @param otc 
     * @param appId 
     */
    public redeemInvitation (otc: string, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', String(otc))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update teammates (this method does not support Deltas!)
     * 
     * @param appId Application identifier
     * @param id teammate identifier
     * @param teammate teammate model
     */
    public updateTeammate (appId: string, id: string, teammate: TeammateBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: teammate,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        this.authentications[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param userId 
     * @param storeId 
     */
    public getPreviousOrderCountForStore (userId: number, storeId: number) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/{userId}/previousordercount/{storeId}'
            .replace('{' + 'userId' + '}', String(userId))
            .replace('{' + 'storeId' + '}', String(storeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get role names
     * 
     */
    public getRoles () : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        this.authentications[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * [PRIVATE API] Create voucher
     * 
     * @param appId App Name Id
     * @param voucher Voucher Details
     */
    public createVoucher (appId: string, voucher: CreateVoucher) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: voucher,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get voucher by identifier
     * 
     * @param voucherId Id of the voucher
     */
    public getVoucherById (voucherId: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', String(voucherId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get voucher stats by identifier
     * 
     * @param voucherId Id of the voucher
     * @param aggregateDataBy Aggregate data by day \\ week \\ month
     * @param dataPointLimit Amount of data points per request
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: string, dataPointLimit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', String(voucherId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            queryParameters['aggregateDataBy'] = aggregateDataBy;
        }

        if (dataPointLimit !== undefined) {
            queryParameters['dataPointLimit'] = dataPointLimit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Get vouchers summaries for App Id
     * 
     * @param appId Application Id
     * @param pageIndex Page Number
     * @param pageSize Page Size
     * @param searchCodes Search by Voucher Code\\s
     * @param statusSearch Search by Status
     * @param typeSearch Search by Type
     * @param subTypeSearch Search by Sub Type
     * @param storeIds Search by Store Ids
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<string>, typeSearch?: Array<string>, subTypeSearch?: Array<string>, storeIds?: Array<number>) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            queryParameters['pageIndex'] = pageIndex;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (searchCodes !== undefined) {
            queryParameters['searchCodes'] = searchCodes;
        }

        if (statusSearch !== undefined) {
            queryParameters['statusSearch'] = statusSearch;
        }

        if (typeSearch !== undefined) {
            queryParameters['typeSearch'] = typeSearch;
        }

        if (subTypeSearch !== undefined) {
            queryParameters['subTypeSearch'] = subTypeSearch;
        }

        if (storeIds !== undefined) {
            queryParameters['storeIds'] = storeIds;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [PRIVATE API] Updates voucher
     * 
     * @param voucherId Id of the voucher
     * @param voucher Updated details for the voucher
     * @param storeId 
     * @param percentValue Percent voucher value (can have 1 of 3)
     * @param lumpValue Lump voucher value (can have 1 of 3)
     * @param freeItemId Free Item Id (can have 1 of 3)
     */
    public updateVoucher (voucherId: number, voucher: VoucherBase, storeId?: Array<number>, percentValue?: number, lumpValue?: number, freeItemId?: number) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', String(voucherId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            queryParameters['storeId'] = storeId;
        }

        if (percentValue !== undefined) {
            queryParameters['percentValue'] = percentValue;
        }

        if (lumpValue !== undefined) {
            queryParameters['lumpValue'] = lumpValue;
        }

        if (freeItemId !== undefined) {
            queryParameters['freeItemId'] = freeItemId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: voucher,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        this.authentications[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create a webhook subscription for you Oauth App
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     */
    public craeteWebhookSubscription (oauthAppId: string, webhookSubscription: WebhookSubscription, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling craeteWebhookSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhookSubscription,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add event name to your webhook subscription
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'eventName' + '}', String(eventName))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete you webhook subscription
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove event name to your webhook subscription
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'eventName' + '}', String(eventName))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all webhook subscription event names
     * 
     * @param appId 
     */
    public getWebhookEventNames (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get your webhook subscriptions selected event names
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a sample event from a webhook subscription
     * 
     * @param eventName 
     * @param appId 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param version 
     */
    public getWebhookEventSample (eventName: string, appId: string, oauthAppId: string, webhookSubscriptionId: string, version?: string) : Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}/test'
            .replace('{' + 'eventName' + '}', String(eventName))
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventSample.');
        }

        if (version !== undefined) {
            queryParameters['version'] = version;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get logs for your webhook subscription
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param appId 
     * @param page Page number
     * @param limit Page size
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all webhook subscriptions by your Oauth App id
     * 
     * @param oauthAppId Oauth App identifier
     * @param appId 
     * @param page 
     * @param limit 
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, page?: number, limit?: number) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a webhook subscription object
     * 
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription, appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', String(oauthAppId))
            .replace('{' + 'webhookSubscriptionId' + '}', String(webhookSubscriptionId))
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhookSubscription,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebsiteApiApiKeys {
}

export class WebsiteApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebsiteApiApiKeys, value: string) {
        this.authentications[WebsiteApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Add a testimonial
     * 
     * @param appId Application identifier
     * @param testimonial Testimonial to be added
     */
    public addTestimonial (appId: string, testimonial: WebsiteTestimonialBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling addTestimonial.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: testimonial,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a testimonial
     * 
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to delete
     */
    public deleteTestimonial (appId: string, testimonialId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'testimonialId' + '}', String(testimonialId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling deleteTestimonial.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete Website Image
     * 
     * @param appId Application identifier
     * @param imageId Id of the image
     */
    public deleteWebsiteImage (appId: string, imageId: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'imageId' + '}', String(imageId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebsiteImage.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling deleteWebsiteImage.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a testimonial
     * 
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to edit
     * @param testimonial New values of the testimonial
     */
    public editTestimonial (appId: string, testimonialId: number, testimonial: WebsiteTestimonialBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'testimonialId' + '}', String(testimonialId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling editTestimonial.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: testimonial,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Index Configuration
     * 
     * @param appId Application identifier
     */
    public getIndexConfiguration (appId: string) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getIndexConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set Index Configuration
     * 
     * @param appId Application identifier
     * @param indexPage New index page definition
     */
    public setIndexConfiguration (appId: string, indexPage: IndexPageBase) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setIndexConfiguration.');
        }

        // verify required parameter 'indexPage' is not null or undefined
        if (indexPage === null || indexPage === undefined) {
            throw new Error('Required parameter indexPage was null or undefined when calling setIndexConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: indexPage,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload Website Image
     * 
     * @param appId Application identifier
     * @param imageLocation Section for which to upload the image
     * @param image App Logo
     */
    public uploadWebsiteImage (appId: string, imageLocation: string, image: any) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageLocation}'
            .replace('{' + 'appId' + '}', String(appId))
            .replace('{' + 'imageLocation' + '}', String(imageLocation));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'imageLocation' is not null or undefined
        if (imageLocation === null || imageLocation === undefined) {
            throw new Error('Required parameter imageLocation was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling uploadWebsiteImage.');
        }

        let useFormData = false;

        if (image !== undefined) {
            formParams['Image'] = image;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Triggers a Check DNS Process
     * 
     * @param appId 
     */
    public websiteCheckNow (appId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/dnscheck'
            .replace('{' + 'appId' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling websiteCheckNow.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
