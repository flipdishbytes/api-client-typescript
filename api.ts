/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Account details
*/
export class FlipdishPublicModelsV1AccountsAccountDetail {
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Signup steps
    */
    'SignupSteps'?: Array<FlipdishPublicModelsV1AccountsSignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified'?: boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser'?: boolean;
    /**
    * Accounts Id
    */
    'AccountId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SignupSteps",
            "baseName": "SignupSteps",
            "type": "Array<FlipdishPublicModelsV1AccountsSignupStep>"
        },
        {
            "name": "IsVerified",
            "baseName": "IsVerified",
            "type": "boolean"
        },
        {
            "name": "IsSelfServeUser",
            "baseName": "IsSelfServeUser",
            "type": "boolean"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsAccountDetail.attributeTypeMap;
    }
}

/**
* Account Details Base
*/
export class FlipdishPublicModelsV1AccountsAccountDetailBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsAccountDetailBase.attributeTypeMap;
    }
}

/**
* Change password model
*/
export class FlipdishPublicModelsV1AccountsChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsChangePasswordModel.attributeTypeMap;
    }
}

/**
* Create account model
*/
export class FlipdishPublicModelsV1AccountsCreateAccountModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;
    /**
    * Referral ID
    */
    'Rid'?: number;
    /**
    * Campaign ID
    */
    'Cid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "Rid",
            "baseName": "Rid",
            "type": "number"
        },
        {
            "name": "Cid",
            "baseName": "Cid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsCreateAccountModel.attributeTypeMap;
    }
}

/**
* Driver Login model
*/
export class FlipdishPublicModelsV1AccountsDriverLoginModel {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Code
    */
    'Code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsDriverLoginModel.attributeTypeMap;
    }
}

/**
* Driver Request Login Pin model
*/
export class FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel {
    /**
    * Email address
    */
    'PhoneNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Represents a localised time zone
*/
export class FlipdishPublicModelsV1AccountsLocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId'?: string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId'?: string;
    /**
    * Display name in users language
    */
    'DisplayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TimeZoneId",
            "baseName": "TimeZoneId",
            "type": "string"
        },
        {
            "name": "IanaTimeZoneId",
            "baseName": "IanaTimeZoneId",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsLocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Login model
*/
export class FlipdishPublicModelsV1AccountsLoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsLoginModel.attributeTypeMap;
    }
}

/**
* Login with PIN model
*/
export class FlipdishPublicModelsV1AccountsLoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsLoginWithPinModel.attributeTypeMap;
    }
}

/**
* Password reset model
*/
export class FlipdishPublicModelsV1AccountsPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "PasswordConfirmation",
            "baseName": "PasswordConfirmation",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsPasswordResetModel.attributeTypeMap;
    }
}

/**
* Predefined answer
*/
export class FlipdishPublicModelsV1AccountsPredefinedAnswer {
    /**
    * Identifier
    */
    'Id'?: number;
    /**
    * Text
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsPredefinedAnswer.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class FlipdishPublicModelsV1AccountsRequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsRequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class FlipdishPublicModelsV1AccountsRequestLoginPinResposne {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LoginPinSentViaEmail",
            "baseName": "LoginPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsRequestLoginPinResposne.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1AccountsRequestPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsRequestPasswordResetModel.attributeTypeMap;
    }
}

/**
* Set password with PIN model
*/
export class FlipdishPublicModelsV1AccountsSetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsSetPasswordWithPinModel.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1AccountsSignupStep {
    /**
    * Action needs to take
    */
    'Action'?: FlipdishPublicModelsV1AccountsSignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question'?: string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers'?: Array<FlipdishPublicModelsV1AccountsPredefinedAnswer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Action",
            "baseName": "Action",
            "type": "FlipdishPublicModelsV1AccountsSignupStep.ActionEnum"
        },
        {
            "name": "Question",
            "baseName": "Question",
            "type": "string"
        },
        {
            "name": "PredefinedAnswers",
            "baseName": "PredefinedAnswers",
            "type": "Array<FlipdishPublicModelsV1AccountsPredefinedAnswer>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsSignupStep.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1AccountsSignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription'
    }
}
/**
* UpdateDriver Push Notification Token
*/
export class FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken {
    /**
    * Push notifications token, cannot be null
    */
    'PushNotificationsToken': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PushNotificationsToken",
            "baseName": "PushNotificationsToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken.attributeTypeMap;
    }
}

/**
* Update Driver Profile
*/
export class FlipdishPublicModelsV1AccountsUpdateDriverProfileModel {
    /**
    * The new name of the Driver.
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AccountsUpdateDriverProfileModel.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1AllMetadataResult {
    /**
    * Menu item metadata
    */
    'MenuItemMetadata'?: Array<FlipdishPublicModelsV1Metadata>;
    /**
    * Menu item optionset item metadata
    */
    'MenuItemOptionSetItemMetadata'?: Array<FlipdishPublicModelsV1Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemMetadata",
            "baseName": "MenuItemMetadata",
            "type": "Array<FlipdishPublicModelsV1Metadata>"
        },
        {
            "name": "MenuItemOptionSetItemMetadata",
            "baseName": "MenuItemOptionSetItemMetadata",
            "type": "Array<FlipdishPublicModelsV1Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AllMetadataResult.attributeTypeMap;
    }
}

/**
* Http Request and Response Log
*/
export class FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog {
    /**
    * Id of the log
    */
    'Guid'?: string;
    /**
    * Verb associated with the HTTP call.
    */
    'Verb'?: string;
    /**
    * Http request URI.
    */
    'RequestUri'?: string;
    /**
    * Http response status code.
    */
    'StatusCode'?: number;
    /**
    * Http response status line.
    */
    'ReasonPhrase'?: string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds'?: number;
    /**
    * Identity of the caller.
    */
    'UserId'?: string;
    /**
    * Ip address of the caller
    */
    'IpAddress'?: string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime'?: string;
    /**
    * Http request headers.
    */
    'RequestHeaders'?: { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody'?: string;
    /**
    * Http request content-length
    */
    'RequestLength'?: number;
    /**
    * Http response headers.
    */
    'ResponseHeaders'?: { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody'?: string;
    /**
    * Http response content-length
    */
    'ResponseLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Guid",
            "baseName": "Guid",
            "type": "string"
        },
        {
            "name": "Verb",
            "baseName": "Verb",
            "type": "string"
        },
        {
            "name": "RequestUri",
            "baseName": "RequestUri",
            "type": "string"
        },
        {
            "name": "StatusCode",
            "baseName": "StatusCode",
            "type": "number"
        },
        {
            "name": "ReasonPhrase",
            "baseName": "ReasonPhrase",
            "type": "string"
        },
        {
            "name": "CallDurationInMilliseconds",
            "baseName": "CallDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        },
        {
            "name": "CreatedDateTime",
            "baseName": "CreatedDateTime",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "RequestLength",
            "baseName": "RequestLength",
            "type": "number"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "ResponseLength",
            "baseName": "ResponseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1AccountsLocalisedTimeZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1AccountsLocalisedTimeZone>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1AllMetadataResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1AllMetadataResult>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ApmApmCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ApmApmCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ApmApmDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ApmApmDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ApmApmHourlyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ApmApmHourlyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1AppsSupportedCountry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1AppsSupportedCountry>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1BankAccountBankAccountSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1BankAccountBankAccountSummary>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1DeliveryTrackingDriver>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1DeliveryTrackingDriver>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1DeliveryTrackingDriverStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1DeliveryTrackingDriverStore>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1HomeHomeAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1HomeHomeAction>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1HydraEmvTerminalWithAssignments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1HydraEmvTerminalWithAssignments>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuCheckpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuCheckpoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuItemOptionSet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuItemOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuSection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuStoreNames>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuStoreNames>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuSummary>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1MenusMenuTaxDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1MenusMenuTaxDetails>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1OAuthClientsOAuthApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1OAuthClientsOAuthApp>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ProcessingFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ProcessingFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresDeliveryZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresDeliveryZone>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresPreOrderTime>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresPreOrderTime>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresStoreStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStoreStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1TeammatesTeammate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1TeammatesTeammate>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1VouchersVoucherDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1VouchersVoucherDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api default response
*/
export class FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse {
    /**
    * Data string
    */
    'Data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api error result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Stack trace
    */
    'StackTrace'?: string;
    /**
    * List of errors grouped by field name
    */
    'Errors'?: Array<FlipdishPublicModelsV1ApiResultsValidationErrorResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "StackTrace",
            "baseName": "StackTrace",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<FlipdishPublicModelsV1ApiResultsValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiErrorResult.attributeTypeMap;
    }
}

/**
* Rest Api Forbidden Result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiForbiddenResult.attributeTypeMap;
    }
}

/**
* Rest api integer result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1AppsApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1AppsApp>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1HydraHydraDeviceDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1HydraHydraDeviceDetails>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1OAuthClientsOAuthTokenModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1OAuthClientsOAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1OrdersOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1OrdersOrder>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1OrdersOrderSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1OrdersOrderSummary>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1PhoneCall>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1PhoneCall>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1PushNotificationsPushNotificationResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1PushNotificationsPushNotificationResponse>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresBusinessHoursOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresBusinessHoursOverride>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStore>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresStoreGroupExtended>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStoreGroupExtended>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresStoreGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStoreGroup>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1StoresStoreHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStoreHeader>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1VouchersVoucherSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1VouchersVoucherSummary>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1WebhooksWebhookLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1WebhooksWebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<FlipdishPublicModelsV1WebhooksWebhookSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1WebhooksWebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1AccountsAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1AccountsAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1ApmApmStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1ApmApmStatistics"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1AppsApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1AppsApp"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1AppsDnsRecordInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1AppsDnsRecordInformation"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1BankAccountAssignedBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1BankAccountAssignedBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1BankAccountBankAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1BankAccountBankAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1BusinessHoursPeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1BusinessHoursPeriod"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1DeliveryTrackingDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1DeliveryTrackingDriver"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1HomeHomeStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1HomeHomeStatistics"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1HydraHydraConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1HydraHydraConfig"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1HydraHydraStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1HydraHydraStatus"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1HydraPaymentTerminalDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1HydraPaymentTerminalDetails"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1LightspeedLightspeedSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1LightspeedLightspeedSettings"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenu;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenu"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenuItemOptionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenuItemOptionSetItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionAvailabilityFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenuSectionAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenuSectionAvailability"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionAvailabilityFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenuSection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenuSection"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1MenusMenuSectionItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1Metadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1Metadata"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1OAuthClientsOAuthApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1OAuthClientsOAuthApp"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1OrdersOrder;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1ProcessingFeeConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1ProcessingFeeConfig"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1PushNotificationsPushNotificationResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1PushNotificationsPushNotificationResponse"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresBusinessHoursOverride;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverride"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresDeliveryZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresDeliveryZone"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresPreOrderConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresPreOrderConfig"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresStoreAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresStoreAddress"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresStoreEndOfDayReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresStoreEndOfDayReport"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresStore;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresStore"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresStoreGroupBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresStoreGroupBase"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StoresStoreGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StoresStoreGroup"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StuartJobResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StuartJobResponse"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1StuartStuartSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1StuartStuartSettings"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1TeammatesRedeemInvitationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1TeammatesRedeemInvitationResult"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1TeammatesTeammate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1TeammatesTeammate"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1VouchersVoucherWithStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1VouchersVoucherWithStats"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1WebsiteIndexPageBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1WebsiteIndexPageBase"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1WebsiteIndexPage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1WebsiteIndexPage"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1WebsiteWebsiteImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1WebsiteWebsiteImage"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull {
    /**
    * Generic data object.
    */
    'Data': FlipdishPublicModelsV1WebsiteWebsiteTestimonial;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1WebsiteWebsiteTestimonial"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull.attributeTypeMap;
    }
}

/**
* Rest api string array result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult.attributeTypeMap;
    }
}

/**
* Rest api string result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiStringResult {
    /**
    * Data string
    */
    'Data': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiStringResult.attributeTypeMap;
    }
}

/**
* Rest api unauthorized result
*/
export class FlipdishPublicModelsV1ApiResultsRestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsRestApiUnauthorizedResult.attributeTypeMap;
    }
}

/**
* Validation error result
*/
export class FlipdishPublicModelsV1ApiResultsValidationErrorResult {
    /**
    * Field name
    */
    'FieldName'?: string;
    /**
    * List of errors relates to field
    */
    'Errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FieldName",
            "baseName": "FieldName",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApiResultsValidationErrorResult.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class FlipdishPublicModelsV1ApmApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The values of this data point
    */
    'CurrencyData'?: Array<FlipdishPublicModelsV1ApmCurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<FlipdishPublicModelsV1ApmCurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class FlipdishPublicModelsV1ApmApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmApmDataPoint.attributeTypeMap;
    }
}

/**
* Provides an average value for a single hour of day of the week
*/
export class FlipdishPublicModelsV1ApmApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day'?: FlipdishPublicModelsV1ApmApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour'?: number;
    /**
    * Total Value
    */
    'TotalValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "FlipdishPublicModelsV1ApmApmHourlyDataPoint.DayEnum"
        },
        {
            "name": "Hour",
            "baseName": "Hour",
            "type": "number"
        },
        {
            "name": "TotalValue",
            "baseName": "TotalValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmApmHourlyDataPoint.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1ApmApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class FlipdishPublicModelsV1ApmApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved'?: number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved'?: number;
    /**
    * Currency based data
    */
    'CurrencyData'?: Array<FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesSaved",
            "baseName": "EstimatedMinutesSaved",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesCouldSaved",
            "baseName": "EstimatedMinutesCouldSaved",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmApmStatistics.attributeTypeMap;
    }
}

/**
* A single currency data piece, with no date
*/
export class FlipdishPublicModelsV1ApmCurrencyData {
    /**
    * Currency
    */
    'Currency'?: FlipdishPublicModelsV1ApmCurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1ApmCurrencyData.CurrencyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmCurrencyData.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1ApmCurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* A single currency data point, with no date
*/
export class FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency'?: FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount'?: number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount'?: number;
    /**
    * Value of orders for this currency
    */
    'OrderValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint.CurrencyEnum"
        },
        {
            "name": "UserCount",
            "baseName": "UserCount",
            "type": "number"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* App
*/
export class FlipdishPublicModelsV1AppsApp {
    /**
    * App Identifier
    */
    'AppId'?: string;
    /**
    * Has iOS app in store
    */
    'HasIosApp'?: boolean;
    /**
    * Has Android app in play store
    */
    'HasAndroidApp'?: boolean;
    /**
    * Country identifier
    */
    'CountryId'?: string;
    /**
    * Application Logo
    */
    'LogoImageUrl'?: string;
    /**
    * Languages to be available in the application
    */
    'Languages'?: Array<FlipdishPublicModelsV1AppsLanguage>;
    /**
    * Available Languages for Apps\\Staff
    */
    'AvailableAppLanguages'?: Array<FlipdishPublicModelsV1AppsLanguage>;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel'?: FlipdishPublicModelsV1AppsApp.AppAccessLevelEnum;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet'?: Array<FlipdishPublicModelsV1AppsApp.AppResourceSetEnum>;
    /**
    * Feature flags
    */
    'Features'?: Array<string>;
    /**
    * Center of the map coordinates
    */
    'MapCenter'?: FlipdishPublicModelsV1Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates
    */
    'MapNorthEast'?: FlipdishPublicModelsV1Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates
    */
    'MapSouthWest'?: FlipdishPublicModelsV1Coordinates;
    /**
    * App name
    */
    'Name'?: string;
    /**
    * HostName on which the app is allowed to be hosted
    */
    'HostName'?: string;
    /**
    * Main color of the web \\ android \\ ios applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: FlipdishPublicModelsV1AppsApp.ApplicationCategoryEnum;
    /**
    * Is Panacea Enabled
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "HasIosApp",
            "baseName": "HasIosApp",
            "type": "boolean"
        },
        {
            "name": "HasAndroidApp",
            "baseName": "HasAndroidApp",
            "type": "boolean"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "LogoImageUrl",
            "baseName": "LogoImageUrl",
            "type": "string"
        },
        {
            "name": "Languages",
            "baseName": "Languages",
            "type": "Array<FlipdishPublicModelsV1AppsLanguage>"
        },
        {
            "name": "AvailableAppLanguages",
            "baseName": "AvailableAppLanguages",
            "type": "Array<FlipdishPublicModelsV1AppsLanguage>"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "FlipdishPublicModelsV1AppsApp.AppAccessLevelEnum"
        },
        {
            "name": "AppResourceSet",
            "baseName": "AppResourceSet",
            "type": "Array<FlipdishPublicModelsV1AppsApp.AppResourceSetEnum>"
        },
        {
            "name": "Features",
            "baseName": "Features",
            "type": "Array<string>"
        },
        {
            "name": "MapCenter",
            "baseName": "MapCenter",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "MapNorthEast",
            "baseName": "MapNorthEast",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "MapSouthWest",
            "baseName": "MapSouthWest",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "FlipdishPublicModelsV1AppsApp.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AppsApp.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1AppsApp {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum AppResourceSetEnum {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        EditAppAssets = <any> 'EditAppAssets',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        EditStoreKioskSettings = <any> 'EditStoreKioskSettings',
        EditStoreOrderCapacity = <any> 'EditStoreOrderCapacity',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        UpdateVouchersExtendDisable = <any> 'UpdateVouchersExtendDisable',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewWebsiteDnsVerified = <any> 'ViewWebsiteDnsVerified',
        ViewWebsiteCertificateCreated = <any> 'ViewWebsiteCertificateCreated',
        ViewWebsiteCertificateRenewed = <any> 'ViewWebsiteCertificateRenewed',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        VerifyBankAccounts = <any> 'VerifyBankAccounts',
        ViewFeesConfigurations = <any> 'ViewFeesConfigurations',
        EditFeesConfigurations = <any> 'EditFeesConfigurations',
        ViewHydraConfig = <any> 'ViewHydraConfig',
        UpdateHydraConfigManage = <any> 'UpdateHydraConfigManage',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        ViewHydraAuditLogs = <any> 'ViewHydraAuditLogs',
        ViewPushNotificationAuditLogs = <any> 'ViewPushNotificationAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer',
        InviteDriverToApp = <any> 'InviteDriverToApp',
        GetDriverForApp = <any> 'GetDriverForApp',
        RemoveDriverFromApp = <any> 'RemoveDriverFromApp',
        AssignDriverToOrder = <any> 'AssignDriverToOrder',
        UnassignDriverFromOrder = <any> 'UnassignDriverFromOrder',
        UpdateOrdersDeliveryTrackingStatus = <any> 'UpdateOrdersDeliveryTrackingStatus'
    }
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application configuration
*/
export class FlipdishPublicModelsV1AppsAppConfigUpdateModel {
    /**
    * App name
    */
    'Name'?: string;
    /**
    * HostName on which the app is allowed to be hosted
    */
    'HostName'?: string;
    /**
    * Main color of the web \\ android \\ ios applications
    */
    'MainColor'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: FlipdishPublicModelsV1AppsAppConfigUpdateModel.ApplicationCategoryEnum;
    /**
    * Is Panacea Enabled
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "FlipdishPublicModelsV1AppsAppConfigUpdateModel.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AppsAppConfigUpdateModel.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1AppsAppConfigUpdateModel {
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Holds the information for the A and CNAME Records of a domain.
*/
export class FlipdishPublicModelsV1AppsDnsRecordInformation {
    /**
    * indicates whether the CNAME record is ready or not.
    */
    'IsCNameReady'?: boolean;
    /**
    * indicates whether the A record is ready or not.
    */
    'IsAReady'?: boolean;
    /**
    * indicates whether the API CNAME record is ready or not.
    */
    'IsApiCNameReady'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCNameReady",
            "baseName": "IsCNameReady",
            "type": "boolean"
        },
        {
            "name": "IsAReady",
            "baseName": "IsAReady",
            "type": "boolean"
        },
        {
            "name": "IsApiCNameReady",
            "baseName": "IsApiCNameReady",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AppsDnsRecordInformation.attributeTypeMap;
    }
}

/**
* Sorted Language
*/
export class FlipdishPublicModelsV1AppsLanguage {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId'?: string;
    /**
    * Display Order
    */
    'DisplayOrder'?: number;
    /**
    * Language Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AppsLanguage.attributeTypeMap;
    }
}

/**
* Describes a supported country
*/
export class FlipdishPublicModelsV1AppsSupportedCountry {
    /**
    * Country code
    */
    'CountryCode'?: string;
    /**
    * Nice display name for a country
    */
    'Name'?: string;
    /**
    * Country phone code
    */
    'PhoneCode'?: number;
    /**
    * Language code
    */
    'LanguageCode'?: string;
    /**
    * Language name
    */
    'LanguageName'?: string;
    /**
    * One time phone number
    */
    'OtpNumber'?: string;
    /**
    * Support phone number
    */
    'SupportNumber'?: string;
    /**
    * Address layout
    */
    'AddressLayout'?: FlipdishPublicModelsV1AppsSupportedCountry.AddressLayoutEnum;
    /**
    * Post code type
    */
    'PostCodeType'?: FlipdishPublicModelsV1AppsSupportedCountry.PostCodeTypeEnum;
    /**
    * Supported region
    */
    'SupportRegion'?: FlipdishPublicModelsV1AppsSupportedCountry.SupportRegionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PhoneCode",
            "baseName": "PhoneCode",
            "type": "number"
        },
        {
            "name": "LanguageCode",
            "baseName": "LanguageCode",
            "type": "string"
        },
        {
            "name": "LanguageName",
            "baseName": "LanguageName",
            "type": "string"
        },
        {
            "name": "OtpNumber",
            "baseName": "OtpNumber",
            "type": "string"
        },
        {
            "name": "SupportNumber",
            "baseName": "SupportNumber",
            "type": "string"
        },
        {
            "name": "AddressLayout",
            "baseName": "AddressLayout",
            "type": "FlipdishPublicModelsV1AppsSupportedCountry.AddressLayoutEnum"
        },
        {
            "name": "PostCodeType",
            "baseName": "PostCodeType",
            "type": "FlipdishPublicModelsV1AppsSupportedCountry.PostCodeTypeEnum"
        },
        {
            "name": "SupportRegion",
            "baseName": "SupportRegion",
            "type": "FlipdishPublicModelsV1AppsSupportedCountry.SupportRegionEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1AppsSupportedCountry.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1AppsSupportedCountry {
    export enum AddressLayoutEnum {
        BuildingFirst = <any> 'BuildingFirst',
        AddressFirst = <any> 'AddressFirst',
        FullStreetAddressFirst = <any> 'FullStreetAddressFirst'
    }
    export enum PostCodeTypeEnum {
        None = <any> 'None',
        PostCode = <any> 'PostCode',
        Zip = <any> 'Zip'
    }
    export enum SupportRegionEnum {
        Default = <any> 'Default',
        Spain = <any> 'Spain',
        Benelux = <any> 'Benelux'
    }
}
/**
* Assigned to Store Bank Account
*/
export class FlipdishPublicModelsV1BankAccountAssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id'?: number;
    /**
    * Name of Bank Account
    */
    'BankAccountName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "BankAccountName",
            "baseName": "BankAccountName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BankAccountAssignedBankAccount.attributeTypeMap;
    }
}

/**
* BANK ACCOUNT
*/
export class FlipdishPublicModelsV1BankAccountBankAccount {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * Status of Account
    */
    'AccountState'?: FlipdishPublicModelsV1BankAccountBankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "FlipdishPublicModelsV1BankAccountBankAccount.AccountStateEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BankAccountBankAccount.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BankAccountBankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1BankAccountBankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: FlipdishPublicModelsV1BankAccountBankAccountCreate.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "FlipdishPublicModelsV1BankAccountBankAccountCreate.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BankAccountBankAccountCreate.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BankAccountBankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1BankAccountBankAccountDetail {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: FlipdishPublicModelsV1BankAccountBankAccountDetail.AccountStateEnum;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: FlipdishPublicModelsV1BankAccountBankAccountDetail.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "FlipdishPublicModelsV1BankAccountBankAccountDetail.AccountStateEnum"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "FlipdishPublicModelsV1BankAccountBankAccountDetail.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BankAccountBankAccountDetail.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BankAccountBankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1BankAccountBankAccountSummary {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: FlipdishPublicModelsV1BankAccountBankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "FlipdishPublicModelsV1BankAccountBankAccountSummary.AccountStateEnum"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BankAccountBankAccountSummary.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BankAccountBankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* Business hours period
*/
export class FlipdishPublicModelsV1BusinessHoursPeriod {
    /**
    * Early
    */
    'Early'?: FlipdishPublicModelsV1Range;
    /**
    * Late
    */
    'Late'?: FlipdishPublicModelsV1Range;
    /**
    * Ranges
    */
    'Ranges'?: Array<FlipdishPublicModelsV1Range>;
    /**
    * Day of week
    */
    'DayOfWeek'?: FlipdishPublicModelsV1BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Early",
            "baseName": "Early",
            "type": "FlipdishPublicModelsV1Range"
        },
        {
            "name": "Late",
            "baseName": "Late",
            "type": "FlipdishPublicModelsV1Range"
        },
        {
            "name": "Ranges",
            "baseName": "Ranges",
            "type": "Array<FlipdishPublicModelsV1Range>"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "FlipdishPublicModelsV1BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class FlipdishPublicModelsV1BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek'?: FlipdishPublicModelsV1BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "FlipdishPublicModelsV1BusinessHoursPeriodBase.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1BusinessHoursPeriodBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* The loyalty campaign
*/
export class FlipdishPublicModelsV1CampaignsLoyaltyCampaign {
    /**
    * Date and time of campaign beginning
    */
    'From'?: Date;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1CampaignsLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* RetentionCampaign
*/
export class FlipdishPublicModelsV1CampaignsRetentionCampaign {
    /**
    * Date and time of campaign beginning
    */
    'From'?: Date;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1CampaignsRetentionCampaign.attributeTypeMap;
    }
}

/**
* Coordinates
*/
export class FlipdishPublicModelsV1Coordinates {
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1Coordinates.attributeTypeMap;
    }
}

/**
* Create metadata
*/
export class FlipdishPublicModelsV1CreateMetadata {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1CreateMetadata.attributeTypeMap;
    }
}

/**
* Customer summary
*/
export class FlipdishPublicModelsV1CustomersCustomerSummary {
    /**
    * Customer identifier
    */
    'Id'?: number;
    /**
    * Customer name
    */
    'Name'?: string;
    /**
    * Customer email address
    */
    'EmailAddress'?: string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat'?: string;
    /**
    * Customer phone number
    */
    'PhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "PhoneNumberLocalFormat",
            "baseName": "PhoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1CustomersCustomerSummary.attributeTypeMap;
    }
}

/**
* Delivery location
*/
export class FlipdishPublicModelsV1DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates'?: FlipdishPublicModelsV1Coordinates;
    /**
    * Building
    */
    'Building'?: string;
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Town
    */
    'Town'?: string;
    /**
    * Post code
    */
    'PostCode'?: string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions'?: string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "Building",
            "baseName": "Building",
            "type": "string"
        },
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Town",
            "baseName": "Town",
            "type": "string"
        },
        {
            "name": "PostCode",
            "baseName": "PostCode",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "PrettyAddressString",
            "baseName": "PrettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1DeliveryLocation.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1DeliveryTrackingDriver {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * 
    */
    'Stores'?: Array<FlipdishPublicModelsV1DeliveryTrackingDriverStore>;
    /**
    * Profile image url
    */
    'ProfileImageUrl'?: string;
    /**
    * Driver Key
    */
    'DriverKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<FlipdishPublicModelsV1DeliveryTrackingDriverStore>"
        },
        {
            "name": "ProfileImageUrl",
            "baseName": "ProfileImageUrl",
            "type": "string"
        },
        {
            "name": "DriverKey",
            "baseName": "DriverKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1DeliveryTrackingDriver.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1DeliveryTrackingDriverInvitation {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * Driver's name
    */
    'Name'?: string;
    /**
    * Assigned store IDs
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1DeliveryTrackingDriverInvitation.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1DeliveryTrackingDriverStore {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Presence
    */
    'Presence'?: FlipdishPublicModelsV1DeliveryTrackingDriverStore.PresenceEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Presence",
            "baseName": "Presence",
            "type": "FlipdishPublicModelsV1DeliveryTrackingDriverStore.PresenceEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1DeliveryTrackingDriverStore.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1DeliveryTrackingDriverStore {
    export enum PresenceEnum {
        Offline = <any> 'Offline',
        Online = <any> 'Online'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Sequence for delivery
    */
    'Sequence'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Sequence",
            "baseName": "Sequence",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber.attributeTypeMap;
    }
}

/**
* Client Analytics event
*/
export class FlipdishPublicModelsV1EventsAnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Type of the event
    */
    'EventType'?: string;
    /**
    * Type of the app the event is coming from
    */
    'AppType'?: string;
    /**
    * JSON Metadata
    */
    'Metadata'?: string;
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * Latitude of the event
    */
    'Latitude'?: number;
    /**
    * Longitude of the event
    */
    'Longitude'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsAnalyticsClientEvent.attributeTypeMap;
    }
}

/**
* Application created event
*/
export class FlipdishPublicModelsV1EventsAppCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsAppCreatedEvent.attributeTypeMap;
    }
}

/**
* Application updated event
*/
export class FlipdishPublicModelsV1EventsAppUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * A summary of changes made
    */
    'Changes'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Changes",
            "baseName": "Changes",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsAppUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: FlipdishPublicModelsV1BankAccountBankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "FlipdishPublicModelsV1BankAccountBankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: FlipdishPublicModelsV1BankAccountBankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "FlipdishPublicModelsV1BankAccountBankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: FlipdishPublicModelsV1BankAccountBankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "FlipdishPublicModelsV1BankAccountBankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class FlipdishPublicModelsV1EventsCertificateCreatedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsCertificateCreatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class FlipdishPublicModelsV1EventsCertificateRenewedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsCertificateRenewedEvent.attributeTypeMap;
    }
}

/**
* Customer consent updated
*/
export class FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Customer User info
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

/**
* Customer created event
*/
export class FlipdishPublicModelsV1EventsCustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsCustomerCreatedEvent.attributeTypeMap;
    }
}

/**
* Customer updated event
*/
export class FlipdishPublicModelsV1EventsCustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsCustomerUpdatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Created Event
*/
export class FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone'?: FlipdishPublicModelsV1StoresDeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "FlipdishPublicModelsV1StoresDeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Deleted Event
*/
export class FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone'?: FlipdishPublicModelsV1StoresDeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "FlipdishPublicModelsV1StoresDeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Updated Event
*/
export class FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone'?: FlipdishPublicModelsV1StoresDeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "FlipdishPublicModelsV1StoresDeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class FlipdishPublicModelsV1EventsDnsVerifiedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsDnsVerifiedEvent.attributeTypeMap;
    }
}

/**
* Order Terminal Notification
*/
export class FlipdishPublicModelsV1EventsEmvNotificationEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Notification Sent
    */
    'Notification'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * TerminalId
    */
    'TerminalId'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Expirey Date
    */
    'ExpDate'?: string;
    /**
    * Card Type
    */
    'CardType'?: string;
    /**
    * Payment Method
    */
    'PaymentMethod'?: string;
    /**
    * Masked Account Number
    */
    'AccountNumber'?: string;
    /**
    * Auth Code
    */
    'AuthCode'?: string;
    /**
    * Payment Provider Message
    */
    'ProviderMessage'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Notification",
            "baseName": "Notification",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ExpDate",
            "baseName": "ExpDate",
            "type": "string"
        },
        {
            "name": "CardType",
            "baseName": "CardType",
            "type": "string"
        },
        {
            "name": "PaymentMethod",
            "baseName": "PaymentMethod",
            "type": "string"
        },
        {
            "name": "AccountNumber",
            "baseName": "AccountNumber",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "ProviderMessage",
            "baseName": "ProviderMessage",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsEmvNotificationEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsEventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent'?: Array<FlipdishPublicModelsV1EventsAppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsAppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent'?: Array<FlipdishPublicModelsV1EventsAnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent'?: Array<FlipdishPublicModelsV1EventsOrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent'?: Array<FlipdishPublicModelsV1EventsOrderDispatchedEvent>;
    /**
    * Order delivery tracking created events
    */
    'OrderCustomerTrackingCreatedEvent'?: Array<FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent>;
    /**
    * Order delivery tracking updated events
    */
    'OrderDeliveryTrackingStatusUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent'?: Array<FlipdishPublicModelsV1EventsOrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent'?: Array<FlipdishPublicModelsV1EventsOrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent'?: Array<FlipdishPublicModelsV1EventsOrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsOrderTipUpdatedEvent>;
    /**
    * Order Terminal Notification events
    */
    'OrderTerminalNotifications'?: Array<FlipdishPublicModelsV1EventsEmvNotificationEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent'?: Array<FlipdishPublicModelsV1EventsStoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent>;
    /**
    * Store kiosk setting updated events
    */
    'StoreKioskSettingUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent'?: Array<FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent'?: Array<FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreMenuAssignedEvent'?: Array<FlipdishPublicModelsV1EventsStoreMenuAssignedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent'?: Array<FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store archived events
    */
    'StoreArchivedEvent'?: Array<FlipdishPublicModelsV1EventsStoreArchivedEvent>;
    /**
    * Store unarchived events
    */
    'StoreUnarchivedEvent'?: Array<FlipdishPublicModelsV1EventsStoreUnarchivedEvent>;
    /**
    * Store published events
    */
    'StorePublishedEvent'?: Array<FlipdishPublicModelsV1EventsStorePublishedEvent>;
    /**
    * Store unpublished events
    */
    'StoreUnpublishedEvent'?: Array<FlipdishPublicModelsV1EventsStoreUnpublishedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreUpdatedEvent>;
    /**
    * Store updated events
    */
    'StorePreOrderConfigUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent>;
    /**
    * Store logo created events
    */
    'StoreLogoCreatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreLogoCreatedEvent>;
    /**
    * Store logo updated events
    */
    'StoreLogoUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent>;
    /**
    * Store logo deleted events
    */
    'StoreLogoDeletedEvent'?: Array<FlipdishPublicModelsV1EventsStoreLogoDeletedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuCreatedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuUpdatedEvent>;
    /**
    * Menu uploaded events
    */
    'MenuUploadedEvent'?: Array<FlipdishPublicModelsV1EventsMenuUploadedEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent>;
    /**
    * Menu checkpoint created event
    */
    'MenuCheckpointCreatedEvent'?: Array<FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent'?: Array<FlipdishPublicModelsV1EventsStoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent'?: Array<FlipdishPublicModelsV1EventsCustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsCustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent'?: Array<FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent'?: Array<FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent'?: Array<FlipdishPublicModelsV1EventsPrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent'?: Array<FlipdishPublicModelsV1EventsPrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent'?: Array<FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent'?: Array<FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent'?: Array<FlipdishPublicModelsV1EventsPhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent'?: Array<FlipdishPublicModelsV1EventsPhoneCallEndedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent'?: Array<FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent'?: Array<FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent'?: Array<FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent'?: Array<FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent'?: Array<FlipdishPublicModelsV1EventsSmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent'?: Array<FlipdishPublicModelsV1EventsUserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent'?: Array<FlipdishPublicModelsV1EventsUserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsUserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent'?: Array<FlipdishPublicModelsV1EventsUserDeletedEvent>;
    /**
    * User password created event
    */
    'UserCreatedPasswordEvent'?: Array<FlipdishPublicModelsV1EventsUserPasswordCreatedEvent>;
    /**
    * User answered signup questions event
    */
    'UserAnsweredSignupQuestionsEvent'?: Array<FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent'?: Array<FlipdishPublicModelsV1EventsVoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsVoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent'?: Array<FlipdishPublicModelsV1EventsVoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent'?: Array<FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent'?: Array<FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent'?: Array<FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent'?: Array<FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent'?: Array<FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent>;
    /**
    * Hydra assigned event
    */
    'HydraAssignedEvent'?: Array<FlipdishPublicModelsV1EventsHydraHydraAssignedEvent>;
    /**
    * Hydra reset requested event
    */
    'HydraRequestResetEvent'?: Array<FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent>;
    /**
    * Hydra settings changed event
    */
    'HydraSettingChangedEvent'?: Array<FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent>;
    /**
    * Hydra un-assigned event
    */
    'HydraUnAssignedEvent'?: Array<FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent>;
    /**
    * Hydra connection state change
    */
    'HydraConnectionStatusChangedEvent'?: Array<FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent>;
    /**
    * Push notification scheduled event
    */
    'PushNotificationScheduledEvent'?: Array<FlipdishPublicModelsV1EventsPushNotificationScheduledEvent>;
    /**
    * Push notification sent event
    */
    'PushNotificationSentEvent'?: Array<FlipdishPublicModelsV1EventsPushNotificationSentEvent>;
    /**
    * Push notification deleted event
    */
    'PushNotificationDeletedEvent'?: Array<FlipdishPublicModelsV1EventsPushNotificationDeletedEvent>;
    /**
    * DNS Verified
    */
    'DnsVerifiedEvent'?: Array<FlipdishPublicModelsV1EventsDnsVerifiedEvent>;
    /**
    * Certificate created
    */
    'CertificateCreatedEvent'?: Array<FlipdishPublicModelsV1EventsCertificateCreatedEvent>;
    /**
    * Certificate renewed
    */
    'CertificateRenewedEvent'?: Array<FlipdishPublicModelsV1EventsCertificateRenewedEvent>;
    /**
    * Panacea vanity url updated
    */
    'WebsiteVanityUrlUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent>;
    /**
    * Website updated
    */
    'WebsiteUpdatedEvent'?: Array<FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppCreatedEvent",
            "baseName": "AppCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsAppCreatedEvent>"
        },
        {
            "name": "AppUpdatedEvent",
            "baseName": "AppUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsAppUpdatedEvent>"
        },
        {
            "name": "AnalyticsClientEvent",
            "baseName": "AnalyticsClientEvent",
            "type": "Array<FlipdishPublicModelsV1EventsAnalyticsClientEvent>"
        },
        {
            "name": "OrderAcceptedEvent",
            "baseName": "OrderAcceptedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderAcceptedEvent>"
        },
        {
            "name": "OrderDispatchedEvent",
            "baseName": "OrderDispatchedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderDispatchedEvent>"
        },
        {
            "name": "OrderCustomerTrackingCreatedEvent",
            "baseName": "OrderCustomerTrackingCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent>"
        },
        {
            "name": "OrderDeliveryTrackingStatusUpdatedEvent",
            "baseName": "OrderDeliveryTrackingStatusUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent>"
        },
        {
            "name": "OrderCreatedEvent",
            "baseName": "OrderCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderCreatedEvent>"
        },
        {
            "name": "OrderRatingUpdatedEvent",
            "baseName": "OrderRatingUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent>"
        },
        {
            "name": "OrderRefundedEvent",
            "baseName": "OrderRefundedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderRefundedEvent>"
        },
        {
            "name": "OrderRejectedEvent",
            "baseName": "OrderRejectedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderRejectedEvent>"
        },
        {
            "name": "OrderTipUpdatedEvent",
            "baseName": "OrderTipUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsOrderTipUpdatedEvent>"
        },
        {
            "name": "OrderTerminalNotifications",
            "baseName": "OrderTerminalNotifications",
            "type": "Array<FlipdishPublicModelsV1EventsEmvNotificationEvent>"
        },
        {
            "name": "StoreCreatedEvent",
            "baseName": "StoreCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreCreatedEvent>"
        },
        {
            "name": "StoreDeletedEvent",
            "baseName": "StoreDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreDeletedEvent>"
        },
        {
            "name": "StoreAddressUpdatedEvent",
            "baseName": "StoreAddressUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent>"
        },
        {
            "name": "StoreKioskSettingUpdatedEvent",
            "baseName": "StoreKioskSettingUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneCreatedEvent",
            "baseName": "DeliveryZoneCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent>"
        },
        {
            "name": "DeliveryZoneUpdatedEvent",
            "baseName": "DeliveryZoneUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneDeletedEvent",
            "baseName": "DeliveryZoneDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent>"
        },
        {
            "name": "StoreOpeningHoursUpdatedEvent",
            "baseName": "StoreOpeningHoursUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "StoreMenuAssignedEvent",
            "baseName": "StoreMenuAssignedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreMenuAssignedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideCreatedEvent",
            "baseName": "StoreBusinessHoursOverrideCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideDeletedEvent",
            "baseName": "StoreBusinessHoursOverrideDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent>"
        },
        {
            "name": "StoreArchivedEvent",
            "baseName": "StoreArchivedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreArchivedEvent>"
        },
        {
            "name": "StoreUnarchivedEvent",
            "baseName": "StoreUnarchivedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreUnarchivedEvent>"
        },
        {
            "name": "StorePublishedEvent",
            "baseName": "StorePublishedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStorePublishedEvent>"
        },
        {
            "name": "StoreUnpublishedEvent",
            "baseName": "StoreUnpublishedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreUnpublishedEvent>"
        },
        {
            "name": "StoreUpdatedEvent",
            "baseName": "StoreUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreUpdatedEvent>"
        },
        {
            "name": "StorePreOrderConfigUpdatedEvent",
            "baseName": "StorePreOrderConfigUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent>"
        },
        {
            "name": "StoreLogoCreatedEvent",
            "baseName": "StoreLogoCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreLogoCreatedEvent>"
        },
        {
            "name": "StoreLogoUpdatedEvent",
            "baseName": "StoreLogoUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent>"
        },
        {
            "name": "StoreLogoDeletedEvent",
            "baseName": "StoreLogoDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreLogoDeletedEvent>"
        },
        {
            "name": "MenuCreatedEvent",
            "baseName": "MenuCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuCreatedEvent>"
        },
        {
            "name": "MenuUpdatedEvent",
            "baseName": "MenuUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuUpdatedEvent>"
        },
        {
            "name": "MenuUploadedEvent",
            "baseName": "MenuUploadedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuUploadedEvent>"
        },
        {
            "name": "MenuSectionCreatedEvent",
            "baseName": "MenuSectionCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent>"
        },
        {
            "name": "MenuSectionUpdatedEvent",
            "baseName": "MenuSectionUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent>"
        },
        {
            "name": "MenuSectionDeletedEvent",
            "baseName": "MenuSectionDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent>"
        },
        {
            "name": "MenuSectionItemCreatedEvent",
            "baseName": "MenuSectionItemCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent>"
        },
        {
            "name": "MenuSectionItemUpdatedEvent",
            "baseName": "MenuSectionItemUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent>"
        },
        {
            "name": "MenuSectionItemDeletedEvent",
            "baseName": "MenuSectionItemDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetCreatedEvent",
            "baseName": "MenuItemOptionSetCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetUpdatedEvent",
            "baseName": "MenuItemOptionSetUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetDeletedEvent",
            "baseName": "MenuItemOptionSetDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemCreatedEvent",
            "baseName": "MenuItemOptionSetItemCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemUpdatedEvent",
            "baseName": "MenuItemOptionSetItemUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemDeletedEvent",
            "baseName": "MenuItemOptionSetItemDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent>"
        },
        {
            "name": "MenuCheckpointCreatedEvent",
            "baseName": "MenuCheckpointCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent>"
        },
        {
            "name": "StoreGroupCreatedEvent",
            "baseName": "StoreGroupCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreGroupCreatedEvent>"
        },
        {
            "name": "StoreGroupUpdatedEvent",
            "baseName": "StoreGroupUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent>"
        },
        {
            "name": "StoreGroupDeletedEvent",
            "baseName": "StoreGroupDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsStoreGroupDeletedEvent>"
        },
        {
            "name": "CustomerCreatedEvent",
            "baseName": "CustomerCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsCustomerCreatedEvent>"
        },
        {
            "name": "CustomerUpdatedEvent",
            "baseName": "CustomerUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsCustomerUpdatedEvent>"
        },
        {
            "name": "CustomerConsentUpdatedEvent",
            "baseName": "CustomerConsentUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionCreatedEvent",
            "baseName": "WebhookSubscriptionCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "WebhookSubscriptionUpdatedEvent",
            "baseName": "WebhookSubscriptionUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionDeletedEvent",
            "baseName": "WebhookSubscriptionDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent>"
        },
        {
            "name": "PrinterTurnedOnEvent",
            "baseName": "PrinterTurnedOnEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPrinterTurnedOnEvent>"
        },
        {
            "name": "PrinterTurnedOffEvent",
            "baseName": "PrinterTurnedOffEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPrinterTurnedOffEvent>"
        },
        {
            "name": "PrinterAssignedToStoreEvent",
            "baseName": "PrinterAssignedToStoreEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent>"
        },
        {
            "name": "PrinterUnassignedFromStoreEvent",
            "baseName": "PrinterUnassignedFromStoreEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent>"
        },
        {
            "name": "PhoneCallStartedEvent",
            "baseName": "PhoneCallStartedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPhoneCallStartedEvent>"
        },
        {
            "name": "PhoneCallEndedEvent",
            "baseName": "PhoneCallEndedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPhoneCallEndedEvent>"
        },
        {
            "name": "LoyaltyCampaignCreatedEvent",
            "baseName": "LoyaltyCampaignCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent>"
        },
        {
            "name": "LoyaltyCampaignDeletedEvent",
            "baseName": "LoyaltyCampaignDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent>"
        },
        {
            "name": "LoyaltyCampaignUpdatedEvent",
            "baseName": "LoyaltyCampaignUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent>"
        },
        {
            "name": "RetentionCampaignCreatedEvent",
            "baseName": "RetentionCampaignCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent>"
        },
        {
            "name": "RetentionCampaignDeletedEvent",
            "baseName": "RetentionCampaignDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent>"
        },
        {
            "name": "RetentionCampaignUpdatedEvent",
            "baseName": "RetentionCampaignUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent>"
        },
        {
            "name": "SmsReceivedEvent",
            "baseName": "SmsReceivedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsSmsReceivedEvent>"
        },
        {
            "name": "UserLoginEvent",
            "baseName": "UserLoginEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserLoginEvent>"
        },
        {
            "name": "UserCreatedEvent",
            "baseName": "UserCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserCreatedEvent>"
        },
        {
            "name": "UserUpdatedEvent",
            "baseName": "UserUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserUpdatedEvent>"
        },
        {
            "name": "UserDeletedEvent",
            "baseName": "UserDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserDeletedEvent>"
        },
        {
            "name": "UserCreatedPasswordEvent",
            "baseName": "UserCreatedPasswordEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserPasswordCreatedEvent>"
        },
        {
            "name": "UserAnsweredSignupQuestionsEvent",
            "baseName": "UserAnsweredSignupQuestionsEvent",
            "type": "Array<FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent>"
        },
        {
            "name": "VoucherCreatedEvent",
            "baseName": "VoucherCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsVoucherCreatedEvent>"
        },
        {
            "name": "VoucherUpdatedEvent",
            "baseName": "VoucherUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsVoucherUpdatedEvent>"
        },
        {
            "name": "VoucherDeletedEvent",
            "baseName": "VoucherDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsVoucherDeletedEvent>"
        },
        {
            "name": "TeammateInviteSentEvent",
            "baseName": "TeammateInviteSentEvent",
            "type": "Array<FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent>"
        },
        {
            "name": "TeammateInviteAcceptedEvent",
            "baseName": "TeammateInviteAcceptedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent>"
        },
        {
            "name": "TeammateUpdatedEvent",
            "baseName": "TeammateUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent>"
        },
        {
            "name": "TeammateDeletedEvent",
            "baseName": "TeammateDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent>"
        },
        {
            "name": "BankAccountCreatedEvent",
            "baseName": "BankAccountCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent>"
        },
        {
            "name": "BankAccountUpdatedEvent",
            "baseName": "BankAccountUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent>"
        },
        {
            "name": "BankAccountDeletedEvent",
            "baseName": "BankAccountDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent>"
        },
        {
            "name": "HydraAssignedEvent",
            "baseName": "HydraAssignedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsHydraHydraAssignedEvent>"
        },
        {
            "name": "HydraRequestResetEvent",
            "baseName": "HydraRequestResetEvent",
            "type": "Array<FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent>"
        },
        {
            "name": "HydraSettingChangedEvent",
            "baseName": "HydraSettingChangedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent>"
        },
        {
            "name": "HydraUnAssignedEvent",
            "baseName": "HydraUnAssignedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent>"
        },
        {
            "name": "HydraConnectionStatusChangedEvent",
            "baseName": "HydraConnectionStatusChangedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent>"
        },
        {
            "name": "PushNotificationScheduledEvent",
            "baseName": "PushNotificationScheduledEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPushNotificationScheduledEvent>"
        },
        {
            "name": "PushNotificationSentEvent",
            "baseName": "PushNotificationSentEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPushNotificationSentEvent>"
        },
        {
            "name": "PushNotificationDeletedEvent",
            "baseName": "PushNotificationDeletedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsPushNotificationDeletedEvent>"
        },
        {
            "name": "DnsVerifiedEvent",
            "baseName": "DnsVerifiedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsDnsVerifiedEvent>"
        },
        {
            "name": "CertificateCreatedEvent",
            "baseName": "CertificateCreatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsCertificateCreatedEvent>"
        },
        {
            "name": "CertificateRenewedEvent",
            "baseName": "CertificateRenewedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsCertificateRenewedEvent>"
        },
        {
            "name": "WebsiteVanityUrlUpdatedEvent",
            "baseName": "WebsiteVanityUrlUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent>"
        },
        {
            "name": "WebsiteUpdatedEvent",
            "baseName": "WebsiteUpdatedEvent",
            "type": "Array<FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsEventSearchResult.attributeTypeMap;
    }
}

/**
* Hydra assigned event
*/
export class FlipdishPublicModelsV1EventsHydraHydraAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: FlipdishPublicModelsV1HydraHydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "FlipdishPublicModelsV1HydraHydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsHydraHydraAssignedEvent.attributeTypeMap;
    }
}

/**
* Hydra Connection Status Changed Event
*/
export class FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent {
    /**
    * Hydra Device Id
    */
    'DeviceId'?: string;
    /**
    * Hydra Device Status
    */
    'HydraDeviceStatus'?: FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent.HydraDeviceStatusEnum;
    /**
    * Hydra Last Poll Time
    */
    'PollTime'?: Date;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "HydraDeviceStatus",
            "baseName": "HydraDeviceStatus",
            "type": "FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent.HydraDeviceStatusEnum"
        },
        {
            "name": "PollTime",
            "baseName": "PollTime",
            "type": "Date"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent {
    export enum HydraDeviceStatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra request reset event
*/
export class FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent {
    /**
    * User who initiated the change
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent.attributeTypeMap;
    }
}

/**
* Hydra settings changed
*/
export class FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent {
    /**
    * User who made the change
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Hydra configuration
    */
    'HydraConfig'?: FlipdishPublicModelsV1HydraHydraConfig;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "HydraConfig",
            "baseName": "HydraConfig",
            "type": "FlipdishPublicModelsV1HydraHydraConfig"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent.attributeTypeMap;
    }
}

/**
* Hydra unassigned event
*/
export class FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: FlipdishPublicModelsV1HydraHydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "FlipdishPublicModelsV1HydraHydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign created event
*/
export class FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: FlipdishPublicModelsV1CampaignsLoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "FlipdishPublicModelsV1CampaignsLoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign deleted event
*/
export class FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: FlipdishPublicModelsV1CampaignsLoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "FlipdishPublicModelsV1CampaignsLoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign updated event
*/
export class FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: FlipdishPublicModelsV1CampaignsLoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "FlipdishPublicModelsV1CampaignsLoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu created event
*/
export class FlipdishPublicModelsV1EventsMenuCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: FlipdishPublicModelsV1MenusMenu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "FlipdishPublicModelsV1MenusMenu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Menu identifier
    */
    'Menu'?: FlipdishPublicModelsV1MenusMenu;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "FlipdishPublicModelsV1MenusMenu"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet'?: FlipdishPublicModelsV1MenusMenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet'?: FlipdishPublicModelsV1MenusMenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem'?: FlipdishPublicModelsV1MenusMenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem'?: FlipdishPublicModelsV1MenusMenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem'?: FlipdishPublicModelsV1MenusMenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet'?: FlipdishPublicModelsV1MenusMenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection'?: FlipdishPublicModelsV1MenusMenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "FlipdishPublicModelsV1MenusMenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection'?: FlipdishPublicModelsV1MenusMenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "FlipdishPublicModelsV1MenusMenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem'?: FlipdishPublicModelsV1MenusMenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Deleted by user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem'?: FlipdishPublicModelsV1MenusMenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem'?: FlipdishPublicModelsV1MenusMenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection'?: FlipdishPublicModelsV1MenusMenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "FlipdishPublicModelsV1MenusMenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu updated event
*/
export class FlipdishPublicModelsV1EventsMenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: FlipdishPublicModelsV1MenusMenu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "FlipdishPublicModelsV1MenusMenu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu uploaded event
*/
export class FlipdishPublicModelsV1EventsMenuUploadedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has uploaded the menu
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: FlipdishPublicModelsV1MenusMenu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "FlipdishPublicModelsV1MenusMenu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsMenuUploadedEvent.attributeTypeMap;
    }
}

/**
* Order Accepted Event
*/
export class FlipdishPublicModelsV1EventsOrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime'?: Date;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderAcceptedTime",
            "baseName": "OrderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderAcceptedEvent.attributeTypeMap;
    }
}

/**
* Order Created Event
*/
export class FlipdishPublicModelsV1EventsOrderCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime'?: Date;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCreatedTime",
            "baseName": "OrderCreatedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Dispatched Event
*/
export class FlipdishPublicModelsV1EventsOrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime'?: Date;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderDispatchedTime",
            "baseName": "OrderDispatchedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderDispatchedEvent.attributeTypeMap;
    }
}

/**
* Order Rating Update Event
*/
export class FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * New User Rating
    */
    'Rating'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Rating",
            "baseName": "Rating",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Refunded Event
*/
export class FlipdishPublicModelsV1EventsOrderRefundedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The amount refunded
    */
    'RefundedAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderRefundedEvent.attributeTypeMap;
    }
}

/**
* Order Rejected Event
*/
export class FlipdishPublicModelsV1EventsOrderRejectedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime'?: Date;
    /**
    * Reason for Rejection
    */
    'Reason'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderRejectedTime",
            "baseName": "OrderRejectedTime",
            "type": "Date"
        },
        {
            "name": "Reason",
            "baseName": "Reason",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderRejectedEvent.attributeTypeMap;
    }
}

/**
* Order Tip Update Event
*/
export class FlipdishPublicModelsV1EventsOrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Tip Amount
    */
    'TipAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: FlipdishPublicModelsV1OrdersOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "FlipdishPublicModelsV1OrdersOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsOrderTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Phone call ended event
*/
export class FlipdishPublicModelsV1EventsPhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: FlipdishPublicModelsV1PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "FlipdishPublicModelsV1PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPhoneCallEndedEvent.attributeTypeMap;
    }
}

/**
* Phone call started event
*/
export class FlipdishPublicModelsV1EventsPhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: FlipdishPublicModelsV1PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "FlipdishPublicModelsV1PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPhoneCallStartedEvent.attributeTypeMap;
    }
}

/**
* Printer assigned to store event
*/
export class FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: FlipdishPublicModelsV1Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "FlipdishPublicModelsV1Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent.attributeTypeMap;
    }
}

/**
* Printer turned off event
*/
export class FlipdishPublicModelsV1EventsPrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: FlipdishPublicModelsV1Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "FlipdishPublicModelsV1Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPrinterTurnedOffEvent.attributeTypeMap;
    }
}

/**
* Printer turned on event
*/
export class FlipdishPublicModelsV1EventsPrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: FlipdishPublicModelsV1Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "FlipdishPublicModelsV1Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPrinterTurnedOnEvent.attributeTypeMap;
    }
}

/**
* Printer assigned from store event
*/
export class FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: FlipdishPublicModelsV1Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "FlipdishPublicModelsV1Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsPushNotificationDeletedEvent {
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: FlipdishPublicModelsV1PushNotificationsPushNotificationRequest;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPushNotificationDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsPushNotificationScheduledEvent {
    /**
    * 
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: FlipdishPublicModelsV1PushNotificationsPushNotificationRequest;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPushNotificationScheduledEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsPushNotificationSentEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: FlipdishPublicModelsV1PushNotificationsPushNotificationRequest;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsPushNotificationSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': FlipdishPublicModelsV1EventsEventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FlipdishPublicModelsV1EventsEventSearchResult"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

/**
* Retention campaign created event
*/
export class FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: FlipdishPublicModelsV1CampaignsRetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "FlipdishPublicModelsV1CampaignsRetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign deleted event
*/
export class FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: FlipdishPublicModelsV1CampaignsRetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "FlipdishPublicModelsV1CampaignsRetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign updated event
*/
export class FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: FlipdishPublicModelsV1CampaignsRetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "FlipdishPublicModelsV1CampaignsRetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Search Criteria for Audit Logs
*/
export class FlipdishPublicModelsV1EventsSearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit'?: number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page'?: number;
    /**
    * Start date
    */
    'Start'?: Date;
    /**
    * End date
    */
    'End'?: Date;
    /**
    * Events that have Order Id
    */
    'OrderId'?: number;
    /**
    * Events that have Store Id
    */
    'StoreId'?: number;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Events that have User Id
    */
    'UserId'?: number;
    /**
    * Events that have User Email
    */
    'UserEmail'?: string;
    /**
    * Events that have User Name
    */
    'UserName'?: string;
    /**
    * Events that have voucher code
    */
    'VoucherCode'?: string;
    /**
    * Events that have event type\\s
    */
    'EventType'?: Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "Array<string>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsSearchCriteria.attributeTypeMap;
    }
}

/**
* Sms received event
*/
export class FlipdishPublicModelsV1EventsSmsReceivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The sms info
    */
    'SmsInfo'?: FlipdishPublicModelsV1SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SmsInfo",
            "baseName": "SmsInfo",
            "type": "FlipdishPublicModelsV1SmsInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsSmsReceivedEvent.attributeTypeMap;
    }
}

/**
* Store Address Updated Event
*/
export class FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store address
    */
    'StoreAddress'?: FlipdishPublicModelsV1StoresStoreAddress;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreAddress",
            "baseName": "StoreAddress",
            "type": "FlipdishPublicModelsV1StoresStoreAddress"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Archived Event
*/
export class FlipdishPublicModelsV1EventsStoreArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which archived this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Archived Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreArchivedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Created
*/
export class FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: FlipdishPublicModelsV1StoresBusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Deleted
*/
export class FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: FlipdishPublicModelsV1StoresBusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Created Event
*/
export class FlipdishPublicModelsV1EventsStoreCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which created this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Deleted Event
*/
export class FlipdishPublicModelsV1EventsStoreDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Created Event
*/
export class FlipdishPublicModelsV1EventsStoreGroupCreatedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created this store group
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created store group
    */
    'StoreGroup'?: FlipdishPublicModelsV1StoresStoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "FlipdishPublicModelsV1StoresStoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Group Deleted Event
*/
export class FlipdishPublicModelsV1EventsStoreGroupDeletedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store group
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted store group
    */
    'StoreGroup'?: FlipdishPublicModelsV1StoresStoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "FlipdishPublicModelsV1StoresStoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreGroupDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Updated Event
*/
export class FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store group
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store group
    */
    'StoreGroup'?: FlipdishPublicModelsV1StoresStoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "FlipdishPublicModelsV1StoresStoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store kiosk setting updated
*/
export class FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store kiosk settings
    */
    'StoreKioskSetting'?: FlipdishPublicModelsV1StoresStoreKioskSetting;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreKioskSetting",
            "baseName": "StoreKioskSetting",
            "type": "FlipdishPublicModelsV1StoresStoreKioskSetting"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store logo created
*/
export class FlipdishPublicModelsV1EventsStoreLogoCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who added the logo
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreLogoCreatedEvent.attributeTypeMap;
    }
}

/**
* Store logo deleted
*/
export class FlipdishPublicModelsV1EventsStoreLogoDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who removed the logo
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreLogoDeletedEvent.attributeTypeMap;
    }
}

/**
* Store logo updated
*/
export class FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who updated the logo
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Assigned To Store Event
*/
export class FlipdishPublicModelsV1EventsStoreMenuAssignedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * MenuId Id
    */
    'MenuId'?: number;
    /**
    * User who assigned the menu to the store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreMenuAssignedEvent.attributeTypeMap;
    }
}

/**
* Store Opening Hours Updated Event
*/
export class FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated opening hours for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Type of opening hours Delivery / Pickup
    */
    'DeliveryType'?: FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent.DeliveryTypeEnum;
    /**
    * The period that was updated
    */
    'BusinessHoursPeriodOld'?: FlipdishPublicModelsV1BusinessHoursPeriod;
    /**
    * The new values of the period
    */
    'BusinessHoursPeriod'?: FlipdishPublicModelsV1BusinessHoursPeriod;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent.DeliveryTypeEnum"
        },
        {
            "name": "BusinessHoursPeriodOld",
            "baseName": "BusinessHoursPeriodOld",
            "type": "FlipdishPublicModelsV1BusinessHoursPeriod"
        },
        {
            "name": "BusinessHoursPeriod",
            "baseName": "BusinessHoursPeriod",
            "type": "FlipdishPublicModelsV1BusinessHoursPeriod"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Store Pre order config updated
*/
export class FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Pre Order Configuration
    */
    'PreOrderConfig'?: FlipdishPublicModelsV1StoresPreOrderConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PreOrderConfig",
            "baseName": "PreOrderConfig",
            "type": "FlipdishPublicModelsV1StoresPreOrderConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Published Event
*/
export class FlipdishPublicModelsV1EventsStorePublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which published this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Published Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStorePublishedEvent.attributeTypeMap;
    }
}

/**
* Store Unarchived Event
*/
export class FlipdishPublicModelsV1EventsStoreUnarchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unarchived this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unarchived Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreUnarchivedEvent.attributeTypeMap;
    }
}

/**
* Store Unpublished Event
*/
export class FlipdishPublicModelsV1EventsStoreUnpublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unpublished this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unpublished Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreUnpublishedEvent.attributeTypeMap;
    }
}

/**
* Store Updated Event
*/
export class FlipdishPublicModelsV1EventsStoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Store
    */
    'Store'?: FlipdishPublicModelsV1StoresStore;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStore"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsStoreUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: FlipdishPublicModelsV1TeammatesTeammate;
    /**
    * User who deleted the teammate
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "FlipdishPublicModelsV1TeammatesTeammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: FlipdishPublicModelsV1TeammatesTeammate;
    /**
    * User who accepted the invitation
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "FlipdishPublicModelsV1TeammatesTeammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: FlipdishPublicModelsV1TeammatesTeammate;
    /**
    * User who sent the invitation
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "FlipdishPublicModelsV1TeammatesTeammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: FlipdishPublicModelsV1TeammatesTeammate;
    /**
    * User who updated the teammate
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "FlipdishPublicModelsV1TeammatesTeammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent.attributeTypeMap;
    }
}

/**
* User answered signup questions event
*/
export class FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The users answers
    */
    'SignupAnswers'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "SignupAnswers",
            "baseName": "SignupAnswers",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent.attributeTypeMap;
    }
}

/**
* User created event
*/
export class FlipdishPublicModelsV1EventsUserCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserCreatedEvent.attributeTypeMap;
    }
}

/**
* User deleted event
*/
export class FlipdishPublicModelsV1EventsUserDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserDeletedEvent.attributeTypeMap;
    }
}

/**
* User login event
*/
export class FlipdishPublicModelsV1EventsUserLoginEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserLoginEvent.attributeTypeMap;
    }
}

/**
* User created password event
*/
export class FlipdishPublicModelsV1EventsUserPasswordCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserPasswordCreatedEvent.attributeTypeMap;
    }
}

/**
* User updated event
*/
export class FlipdishPublicModelsV1EventsUserUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsUserUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher Created Event
*/
export class FlipdishPublicModelsV1EventsVoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which created this voucher
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created voucher
    */
    'Voucher'?: FlipdishPublicModelsV1VouchersVoucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "FlipdishPublicModelsV1VouchersVoucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsVoucherCreatedEvent.attributeTypeMap;
    }
}

/**
* Voucher Deleted Event
*/
export class FlipdishPublicModelsV1EventsVoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which deleted this voucher
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted voucher
    */
    'Voucher'?: FlipdishPublicModelsV1VouchersVoucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "FlipdishPublicModelsV1VouchersVoucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsVoucherDeletedEvent.attributeTypeMap;
    }
}

/**
* Voucher Updated Event
*/
export class FlipdishPublicModelsV1EventsVoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which updated this voucher
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated voucher
    */
    'Voucher'?: FlipdishPublicModelsV1VouchersVoucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "FlipdishPublicModelsV1VouchersVoucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsVoucherUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId'?: number;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Webhook callback url
    */
    'CallbackUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "WebhookSubscriptionId",
            "baseName": "WebhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}

/**
* WebsiteUpdatedEvent
*/
export class FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent {
    /**
    * App Name id of the whitelabel of the website
    */
    'AppNameId'?: string;
    /**
    * User updating the website
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * Description of event
    */
    'Description'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppNameId",
            "baseName": "AppNameId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent.attributeTypeMap;
    }
}

/**
* Website vanity url
*/
export class FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the url
    */
    'User'?: FlipdishPublicModelsV1UserEventInfo;
    /**
    * New vanity url
    */
    'VanityUrl'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "FlipdishPublicModelsV1UserEventInfo"
        },
        {
            "name": "VanityUrl",
            "baseName": "VanityUrl",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent.attributeTypeMap;
    }
}

/**
* Fee Summary
*/
export class FlipdishPublicModelsV1FeesFeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount'?: number;
    /**
    * Percentage rate
    */
    'PercentageRate'?: number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeAmount",
            "baseName": "FeeAmount",
            "type": "number"
        },
        {
            "name": "PercentageRate",
            "baseName": "PercentageRate",
            "type": "number"
        },
        {
            "name": "PerTransactionFee",
            "baseName": "PerTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1FeesFeeSummary.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1HomeHomeAction {
    /**
    * 
    */
    'HomeActionId'?: number;
    /**
    * Type of Action
    */
    'HomeActionType'?: FlipdishPublicModelsV1HomeHomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order'?: number;
    /**
    * 
    */
    'TitleKey'?: string;
    /**
    * 
    */
    'ActionKey'?: string;
    /**
    * 
    */
    'DescriptionKey'?: string;
    /**
    * 
    */
    'Action'?: string;
    /**
    * 
    */
    'Dismissible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HomeActionId",
            "baseName": "HomeActionId",
            "type": "number"
        },
        {
            "name": "HomeActionType",
            "baseName": "HomeActionType",
            "type": "FlipdishPublicModelsV1HomeHomeAction.HomeActionTypeEnum"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "number"
        },
        {
            "name": "TitleKey",
            "baseName": "TitleKey",
            "type": "string"
        },
        {
            "name": "ActionKey",
            "baseName": "ActionKey",
            "type": "string"
        },
        {
            "name": "DescriptionKey",
            "baseName": "DescriptionKey",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "Dismissible",
            "baseName": "Dismissible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HomeHomeAction.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1HomeHomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class FlipdishPublicModelsV1HomeHomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved'?: Array<FlipdishPublicModelsV1ApmCurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalMoneySaved",
            "baseName": "TotalMoneySaved",
            "type": "Array<FlipdishPublicModelsV1ApmCurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HomeHomeStatistics.attributeTypeMap;
    }
}

/**
* Device settings for Hydra
*/
export class FlipdishPublicModelsV1HydraDeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Volume",
            "baseName": "Volume",
            "type": "number"
        },
        {
            "name": "FontSize",
            "baseName": "FontSize",
            "type": "number"
        },
        {
            "name": "Brightness",
            "baseName": "Brightness",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraDeviceSettings.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class FlipdishPublicModelsV1HydraEmvTerminal {
    /**
    * Flipdish Identifier of Terminal
    */
    'EmvTerminalId'?: number;
    /**
    * External Identifier of Terminal
    */
    'TerminalId'?: string;
    /**
    * URL at which terminal can be accessed
    */
    'Url'?: string;
    /**
    * TOKEN required to access terminal
    */
    'Token'?: string;
    /**
    * Identifies us to Provider
    */
    'SoftwareHouseId'?: string;
    /**
    * Identifies installer of terminal
    */
    'InstallerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "number"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "SoftwareHouseId",
            "baseName": "SoftwareHouseId",
            "type": "string"
        },
        {
            "name": "InstallerId",
            "baseName": "InstallerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraEmvTerminal.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class FlipdishPublicModelsV1HydraEmvTerminalWithAssignments {
    /**
    * Flipdish Internal identifier of the Terminal
    */
    'EmvTerminalId'?: string;
    /**
    * External Identifier of the Terminal
    */
    'TerminalId'?: string;
    /**
    * true if the terminal is assigned to a hydra device (e.g. a kiosk)
    */
    'IsAssignedToHydraDevice'?: boolean;
    /**
    * hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraConfigId'?: number;
    /**
    * external hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraDeviceId'?: string;
    /**
    * hydra device name (null if the terminal is not assigned to any hydra device)
    */
    'HydraName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "string"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "IsAssignedToHydraDevice",
            "baseName": "IsAssignedToHydraDevice",
            "type": "boolean"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "HydraDeviceId",
            "baseName": "HydraDeviceId",
            "type": "string"
        },
        {
            "name": "HydraName",
            "baseName": "HydraName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraEmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* Hydra configuration
*/
export class FlipdishPublicModelsV1HydraHydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': Array<FlipdishPublicModelsV1HydraHydraConfig.PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': FlipdishPublicModelsV1HydraDeviceSettings;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinimumVersion",
            "baseName": "MinimumVersion",
            "type": "string"
        },
        {
            "name": "PaymentOptions",
            "baseName": "PaymentOptions",
            "type": "Array<FlipdishPublicModelsV1HydraHydraConfig.PaymentOptionsEnum>"
        },
        {
            "name": "DeviceSettings",
            "baseName": "DeviceSettings",
            "type": "FlipdishPublicModelsV1HydraDeviceSettings"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraHydraConfig.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1HydraHydraConfig {
    export enum PaymentOptionsEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hydra device details
*/
export class FlipdishPublicModelsV1HydraHydraDeviceDetails {
    /**
    * Flipdish internal device identifier
    */
    'HydraConfigId'?: number;
    /**
    * Device Id or Serial Number
    */
    'DeviceId'?: string;
    /**
    * Type of the device
    */
    'DeviceType'?: FlipdishPublicModelsV1HydraHydraDeviceDetails.DeviceTypeEnum;
    /**
    * Status of the device
    */
    'Status'?: FlipdishPublicModelsV1HydraHydraDeviceDetails.StatusEnum;
    /**
    * Device Name
    */
    'DeviceName'?: string;
    /**
    * Store Names
    */
    'StoreNames'?: Array<FlipdishPublicModelsV1HydraHydraStoreData>;
    /**
    * Last poll time in UTC
    */
    'LastPollUtc'?: Date;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "FlipdishPublicModelsV1HydraHydraDeviceDetails.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "FlipdishPublicModelsV1HydraHydraDeviceDetails.StatusEnum"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<FlipdishPublicModelsV1HydraHydraStoreData>"
        },
        {
            "name": "LastPollUtc",
            "baseName": "LastPollUtc",
            "type": "Date"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraHydraDeviceDetails.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1HydraHydraDeviceDetails {
    export enum DeviceTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
    export enum StatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra registration result
*/
export class FlipdishPublicModelsV1HydraHydraRegistrationRequest {
    /**
    * Stores to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraHydraRegistrationRequest.attributeTypeMap;
    }
}

/**
* Hydra status
*/
export class FlipdishPublicModelsV1HydraHydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreIds'?: Array<number>;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;
    /**
    * Hydra images (covers)
    */
    'Images'?: Array<string>;
    /**
    * Hydra User Type
    */
    'UserType'?: FlipdishPublicModelsV1HydraHydraStatus.UserTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "IsRegistered",
            "baseName": "IsRegistered",
            "type": "boolean"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<string>"
        },
        {
            "name": "UserType",
            "baseName": "UserType",
            "type": "FlipdishPublicModelsV1HydraHydraStatus.UserTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraHydraStatus.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1HydraHydraStatus {
    export enum UserTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
}
/**
* Store Data
*/
export class FlipdishPublicModelsV1HydraHydraStoreData {
    /**
    * Id of the store
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraHydraStoreData.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal
*/
export class FlipdishPublicModelsV1HydraPaymentTerminalDetails {
    /**
    * Terminal Id (tid)
    */
    'TerminalId'?: string;
    /**
    * Status of Terminal
    */
    'Status'?: string;
    /**
    * Currency configured on the terminal
    */
    'Currency'?: string;
    /**
    * Location to Device
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraPaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal Transaction
*/
export class FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails {
    /**
    * Card Type
    */
    'CardSchemeName'?: string;
    /**
    * Expirey Date on Card
    */
    'DateOfExpiry'?: string;
    /**
    * AuthCode
    */
    'AuthCode'?: string;
    /**
    * State of Request, \"PENDING\" is not yet completed
    */
    'TransactionResult'?: string;
    /**
    * Masked PAN
    */
    'PrimaryAccountNumber'?: string;
    /**
    * Type of Verification.
    */
    'CardholderVerificationMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CardSchemeName",
            "baseName": "CardSchemeName",
            "type": "string"
        },
        {
            "name": "DateOfExpiry",
            "baseName": "DateOfExpiry",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "TransactionResult",
            "baseName": "TransactionResult",
            "type": "string"
        },
        {
            "name": "PrimaryAccountNumber",
            "baseName": "PrimaryAccountNumber",
            "type": "string"
        },
        {
            "name": "CardholderVerificationMethod",
            "baseName": "CardholderVerificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Ligthspeed store settings
*/
export class FlipdishPublicModelsV1LightspeedLightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection'?: number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation'?: string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment'?: boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId'?: string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId'?: string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId'?: string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType'?: FlipdishPublicModelsV1LightspeedLightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId'?: number;
    /**
    * Collection Table ID to send orders
    */
    'CollectionTableId'?: number;
    /**
    * Delivery Table ID to send orders
    */
    'DeliveryTableId'?: number;
    /**
    * Collection Table IDs to send orders to
    */
    'CollectionTableIds'?: { [key: string]: string; };
    /**
    * Delivery Table IDs to send orders to
    */
    'DeliveryTableIds'?: { [key: string]: string; };
    /**
    * Exclude tax
    */
    'UseTaxInclusivePrices'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CompanyId",
            "baseName": "CompanyId",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesForCollection",
            "baseName": "EstimatedMinutesForCollection",
            "type": "number"
        },
        {
            "name": "GeographicLocation",
            "baseName": "GeographicLocation",
            "type": "string"
        },
        {
            "name": "Establishment",
            "baseName": "Establishment",
            "type": "boolean"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "string"
        },
        {
            "name": "DeliveryFeeId",
            "baseName": "DeliveryFeeId",
            "type": "string"
        },
        {
            "name": "ProcessingFeeId",
            "baseName": "ProcessingFeeId",
            "type": "string"
        },
        {
            "name": "PriceType",
            "baseName": "PriceType",
            "type": "FlipdishPublicModelsV1LightspeedLightspeedSettings.PriceTypeEnum"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "CollectionTableId",
            "baseName": "CollectionTableId",
            "type": "number"
        },
        {
            "name": "DeliveryTableId",
            "baseName": "DeliveryTableId",
            "type": "number"
        },
        {
            "name": "CollectionTableIds",
            "baseName": "CollectionTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "DeliveryTableIds",
            "baseName": "DeliveryTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UseTaxInclusivePrices",
            "baseName": "UseTaxInclusivePrices",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1LightspeedLightspeedSettings.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1LightspeedLightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Create menu object
*/
export class FlipdishPublicModelsV1MenusCreateFullMenu {
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<FlipdishPublicModelsV1MenusCreateFullMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<FlipdishPublicModelsV1MenusCreateMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: FlipdishPublicModelsV1MenusCreateFullMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: FlipdishPublicModelsV1MenusCreateFullMenu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<FlipdishPublicModelsV1MenusCreateFullMenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<FlipdishPublicModelsV1MenusCreateMenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateFullMenu.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusCreateFullMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Create menu item option set
*/
export class FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet {
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem>;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu item option set item
*/
export class FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem {
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<FlipdishPublicModelsV1CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<FlipdishPublicModelsV1CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu section
*/
export class FlipdishPublicModelsV1MenusCreateFullMenuSection {
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: FlipdishPublicModelsV1MenusMenuSectionAvailability;
    /**
    * Menu items
    */
    'MenuItems'?: Array<FlipdishPublicModelsV1MenusCreateFullMenuSectionItem>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "FlipdishPublicModelsV1MenusMenuSectionAvailability"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<FlipdishPublicModelsV1MenusCreateFullMenuSectionItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateFullMenuSection.attributeTypeMap;
    }
}

/**
* Create menu section item
*/
export class FlipdishPublicModelsV1MenusCreateFullMenuSectionItem {
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet>;
    /**
    * List of metadata
    */
    'Metadata'?: Array<FlipdishPublicModelsV1CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<FlipdishPublicModelsV1CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusCreateFullMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class FlipdishPublicModelsV1MenusCreateMenuTaxRate {
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusCreateMenuTaxRate.attributeTypeMap;
    }
}

/**
* Menu
*/
export class FlipdishPublicModelsV1MenusMenu {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<FlipdishPublicModelsV1MenusMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<FlipdishPublicModelsV1MenusMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: FlipdishPublicModelsV1MenusMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: FlipdishPublicModelsV1MenusMenu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<FlipdishPublicModelsV1MenusMenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<FlipdishPublicModelsV1MenusMenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "FlipdishPublicModelsV1MenusMenu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "FlipdishPublicModelsV1MenusMenu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenu.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu base
*/
export class FlipdishPublicModelsV1MenusMenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: FlipdishPublicModelsV1MenusMenuBase.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: FlipdishPublicModelsV1MenusMenuBase.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "FlipdishPublicModelsV1MenusMenuBase.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "FlipdishPublicModelsV1MenusMenuBase.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu Checkpoint
*/
export class FlipdishPublicModelsV1MenusMenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId'?: number;
    /**
    * Time of creation of checkpoint
    */
    'Time'?: Date;
    /**
    * Name of checkpoint
    */
    'Name'?: string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCheckpointId",
            "baseName": "MenuCheckpointId",
            "type": "number"
        },
        {
            "name": "Time",
            "baseName": "Time",
            "type": "Date"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuCheckpoint.attributeTypeMap;
    }
}

/**
* Menu item option set
*/
export class FlipdishPublicModelsV1MenusMenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<FlipdishPublicModelsV1MenusMenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<FlipdishPublicModelsV1MenusMenuItemOptionSetItem>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuItemOptionSet.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class FlipdishPublicModelsV1MenusMenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class FlipdishPublicModelsV1MenusMenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<FlipdishPublicModelsV1CreateMetadata>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuItemOptionSetItem.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<FlipdishPublicModelsV1CreateMetadata>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Collection of Display Orders for a Menu Object (Menu Section / Menu Items / Option Sets etc)
*/
export class FlipdishPublicModelsV1MenusMenuObjectDisplayOrders {
    /**
    * List of Objects and their new Display Orders
    */
    'DisplayOrders'?: Array<FlipdishPublicModelsV1MenusObjectDisplayOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplayOrders",
            "baseName": "DisplayOrders",
            "type": "Array<FlipdishPublicModelsV1MenusObjectDisplayOrder>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuObjectDisplayOrders.attributeTypeMap;
    }
}

/**
* Menu section
*/
export class FlipdishPublicModelsV1MenusMenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu items
    */
    'MenuItems'?: Array<FlipdishPublicModelsV1MenusMenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: FlipdishPublicModelsV1MenusMenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<FlipdishPublicModelsV1MenusMenuSectionItem>"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "FlipdishPublicModelsV1MenusMenuSectionAvailability"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSection.attributeTypeMap;
    }
}

/**
* Menu section availability
*/
export class FlipdishPublicModelsV1MenusMenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes'?: Array<FlipdishPublicModelsV1BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode'?: FlipdishPublicModelsV1MenusMenuSectionAvailability.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailableTimes",
            "baseName": "AvailableTimes",
            "type": "Array<FlipdishPublicModelsV1BusinessHoursPeriod>"
        },
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "FlipdishPublicModelsV1MenusMenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSectionAvailability.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode'?: FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class FlipdishPublicModelsV1MenusMenuSectionBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSectionBase.attributeTypeMap;
    }
}

/**
* Menu item
*/
export class FlipdishPublicModelsV1MenusMenuSectionItem {
    /**
    * Menu item identifier. This ID may change at any time. Use `PublicId` if you need a perminant reference to the item.
    */
    'MenuItemId'?: number;
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<FlipdishPublicModelsV1MenusMenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours'?: Array<FlipdishPublicModelsV1BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<FlipdishPublicModelsV1CreateMetadata>;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: FlipdishPublicModelsV1MenusMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ActualPrice",
            "baseName": "ActualPrice",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<FlipdishPublicModelsV1MenusMenuItemOptionSet>"
        },
        {
            "name": "DailySpecialHours",
            "baseName": "DailySpecialHours",
            "type": "Array<FlipdishPublicModelsV1BusinessHoursPeriod>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<FlipdishPublicModelsV1CreateMetadata>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSectionItem.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class FlipdishPublicModelsV1MenusMenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: FlipdishPublicModelsV1MenusMenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: FlipdishPublicModelsV1MenusMenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "FlipdishPublicModelsV1MenusMenuSectionItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSectionItemBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu Store Names
*/
export class FlipdishPublicModelsV1MenusMenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuStoreNames.attributeTypeMap;
    }
}

/**
* Menu Summary
*/
export class FlipdishPublicModelsV1MenusMenuSummary {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuSummary.attributeTypeMap;
    }
}

/**
* Tax information for Menu
*/
export class FlipdishPublicModelsV1MenusMenuTaxDetails {
    /**
    * Tax Rates
    */
    'TaxRates'?: Array<FlipdishPublicModelsV1MenusMenuTaxRate>;
    /**
    * Display tax for Menu
    */
    'DisplayTax'?: boolean;
    /**
    * TaxType
    */
    'TaxType'?: FlipdishPublicModelsV1MenusMenuTaxDetails.TaxTypeEnum;
    /**
    * ItemIds and TaxIds
    */
    'ItemTaxes'?: { [key: string]: number; };
    /**
    * SetItemIds and TaxIds
    */
    'SetItemTaxes'?: { [key: string]: number; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<FlipdishPublicModelsV1MenusMenuTaxRate>"
        },
        {
            "name": "DisplayTax",
            "baseName": "DisplayTax",
            "type": "boolean"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "FlipdishPublicModelsV1MenusMenuTaxDetails.TaxTypeEnum"
        },
        {
            "name": "ItemTaxes",
            "baseName": "ItemTaxes",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "SetItemTaxes",
            "baseName": "SetItemTaxes",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuTaxDetails.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1MenusMenuTaxDetails {
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class FlipdishPublicModelsV1MenusMenuTaxRate {
    /**
    * Id of Tax Rate
    */
    'TaxRateId'?: number;
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusMenuTaxRate.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1MenusObjectDisplayOrder {
    /**
    * ID of object to be ordered
    */
    'Id'?: number;
    /**
    * New Display order
    */
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1MenusObjectDisplayOrder.attributeTypeMap;
    }
}

/**
* Metadata
*/
export class FlipdishPublicModelsV1Metadata {
    /**
    * Menu entity identifier (eg: MenuItemId, MenuItemOptionSetItemId)
    */
    'MenuEntityId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuEntityId",
            "baseName": "MenuEntityId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1Metadata.attributeTypeMap;
    }
}

/**
* Oauth client (also knowns as 'app')
*/
export class FlipdishPublicModelsV1OAuthClientsOAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId'?: string;
    /**
    * OAuth App Name
    */
    'OauthAppName'?: string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * OAuth App logo uri
    */
    'LogoUri'?: string;
    /**
    * Supported OpenID Connect flows
    */
    'Flow'?: FlipdishPublicModelsV1OAuthClientsOAuthApp.FlowEnum;
    /**
    * ReUse: the refresh token handle will stay the same when refreshing tokens   OneTime: the refresh token handle will be updated when refreshing tokens
    */
    'RefreshTokenUsage'?: FlipdishPublicModelsV1OAuthClientsOAuthApp.RefreshTokenUsageEnum;
    /**
    * Timem it takes for the IdentityToken to expire in seconds
    */
    'AccessTokenLifetime'?: number;
    /**
    * Maximum lifetime of a refresh token in seconds
    */
    'AbsoluteRefreshTokenLifetime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OauthAppId",
            "baseName": "OauthAppId",
            "type": "string"
        },
        {
            "name": "OauthAppName",
            "baseName": "OauthAppName",
            "type": "string"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Flow",
            "baseName": "Flow",
            "type": "FlipdishPublicModelsV1OAuthClientsOAuthApp.FlowEnum"
        },
        {
            "name": "RefreshTokenUsage",
            "baseName": "RefreshTokenUsage",
            "type": "FlipdishPublicModelsV1OAuthClientsOAuthApp.RefreshTokenUsageEnum"
        },
        {
            "name": "AccessTokenLifetime",
            "baseName": "AccessTokenLifetime",
            "type": "number"
        },
        {
            "name": "AbsoluteRefreshTokenLifetime",
            "baseName": "AbsoluteRefreshTokenLifetime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OAuthClientsOAuthApp.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OAuthClientsOAuthApp {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        Hybrid = <any> 'Hybrid',
        ClientCredentials = <any> 'ClientCredentials'
    }
    export enum RefreshTokenUsageEnum {
        ReUse = <any> 'ReUse',
        OneTimeOnly = <any> 'OneTimeOnly'
    }
}
/**
* OAuth token model
*/
export class FlipdishPublicModelsV1OAuthClientsOAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key'?: string;
    /**
    * Token type
    */
    'TokenType'?: string;
    /**
    * Oauth subject identifier
    */
    'SubjectId'?: string;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Token expiry
    */
    'Expiry'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "TokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "SubjectId",
            "baseName": "SubjectId",
            "type": "string"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "Expiry",
            "baseName": "Expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OAuthClientsOAuthTokenModel.attributeTypeMap;
    }
}

/**
* OAuth client redirect uri
*/
export class FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id'?: number;
    /**
    * Redirect uri
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Represents one store's order capacity configuration
*/
export class FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Signifies whether the order capacity configuration is for Delivery / Pickup
    */
    'DeliveryType'?: FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig.DeliveryTypeEnum;
    /**
    * Store Interval - time between orders, e.g. 10 minutes between each order time available to customer
    */
    'StoreIntervalInMinutes'?: number;
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig.DeliveryTypeEnum"
        },
        {
            "name": "StoreIntervalInMinutes",
            "baseName": "StoreIntervalInMinutes",
            "type": "number"
        },
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration edit
*/
export class FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel {
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel.attributeTypeMap;
    }
}

/**
* Represents a single order capacity period
*/
export class FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod {
    /**
    * The maximum number of orders per each store order interval in this order capacity period.  E.g. for a period from 9:00 till 11:00, if the store's interval is 10 minutes, and MaxOrderNumberPerStoreInterval is set to 5,  it means that within each 10-minute interval between 9:00 and 11:00 (i.e. 9:00-9:10, 9:10-9:20, .. , 10:50-11:00) it will be possible to  request at most 5 orders.
    */
    'MaxOrderNumberPerStoreInterval'?: number;
    /**
    * Day of the week the period pertains to
    */
    'DayOfTheWeek'?: FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod.DayOfTheWeekEnum;
    /**
    * The hour the period starts at
    */
    'PeriodStartHour'?: number;
    /**
    * The minutes after the hour the period starts at
    */
    'PeriodStartMinutes'?: number;
    /**
    * The hour the period ends at
    */
    'PeriodEndHour'?: number;
    /**
    * The minutes after the hour the period ends at
    */
    'PeriodEndMinutes'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxOrderNumberPerStoreInterval",
            "baseName": "MaxOrderNumberPerStoreInterval",
            "type": "number"
        },
        {
            "name": "DayOfTheWeek",
            "baseName": "DayOfTheWeek",
            "type": "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod.DayOfTheWeekEnum"
        },
        {
            "name": "PeriodStartHour",
            "baseName": "PeriodStartHour",
            "type": "number"
        },
        {
            "name": "PeriodStartMinutes",
            "baseName": "PeriodStartMinutes",
            "type": "number"
        },
        {
            "name": "PeriodEndHour",
            "baseName": "PeriodEndHour",
            "type": "number"
        },
        {
            "name": "PeriodEndMinutes",
            "baseName": "PeriodEndMinutes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod {
    export enum DayOfTheWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Accept
*/
export class FlipdishPublicModelsV1OrdersAccept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersAccept.attributeTypeMap;
    }
}

/**
* Represents a masked phone number
*/
export class FlipdishPublicModelsV1OrdersMaskedPhoneNumber {
    /**
    * Defines if the feature is enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Defines the phone number to call
    */
    'PhoneNumber'?: string;
    /**
    * Defines the code to enter
    */
    'Code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersMaskedPhoneNumber.attributeTypeMap;
    }
}

/**
* Order
*/
export class FlipdishPublicModelsV1OrdersOrder {
    /**
    * Store summary
    */
    'Store'?: FlipdishPublicModelsV1StoresStoreSummary;
    /**
    * Customer summary
    */
    'Customer'?: FlipdishPublicModelsV1CustomersCustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher'?: FlipdishPublicModelsV1VouchersOrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees'?: FlipdishPublicModelsV1FeesFeeSummary;
    /**
    * Ordered items
    */
    'OrderItems'?: Array<FlipdishPublicModelsV1OrdersOrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation'?: FlipdishPublicModelsV1DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation'?: FlipdishPublicModelsV1Coordinates;
    /**
    * Represents customers masked phone number
    */
    'MaskedPhoneNumber'?: FlipdishPublicModelsV1OrdersMaskedPhoneNumber;
    /**
    * Represents table service drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * Id of user who rejected order, if available
    */
    'RejectedByUserId'?: number;
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * Delivery type
    */
    'DeliveryType'?: FlipdishPublicModelsV1OrdersOrder.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: FlipdishPublicModelsV1OrdersOrder.PickupLocationTypeEnum;
    /**
    * Pickup location type
    */
    'TableServiceCatagory'?: FlipdishPublicModelsV1OrdersOrder.TableServiceCatagoryEnum;
    /**
    * Tip amount
    */
    'TipAmount'?: number;
    /**
    * Delivery amount
    */
    'DeliveryAmount'?: number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount'?: number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount'?: number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: FlipdishPublicModelsV1OrdersOrder.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription'?: string;
    /**
    * Order state
    */
    'OrderState'?: FlipdishPublicModelsV1OrdersOrder.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder'?: boolean;
    /**
    * Order placed time
    */
    'PlacedTime'?: Date;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Chef note
    */
    'ChefNote'?: string;
    /**
    * Used app type
    */
    'AppType'?: FlipdishPublicModelsV1OrdersOrder.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating'?: number;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: FlipdishPublicModelsV1OrdersOrder.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason'?: FlipdishPublicModelsV1OrdersOrder.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount'?: number;
    /**
    * Delivery tracking status
    */
    'DeliveryTrackingStatus'?: FlipdishPublicModelsV1OrdersOrder.DeliveryTrackingStatusEnum;
    /**
    * Assigned driver identifier
    */
    'DriverId'?: number;
    /**
    * Total tax applied to order
    */
    'TotalTax'?: number;
    /**
    * Unique, 6 character long alpha numeric code for tracking.
    */
    'OrderTrackingCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Store",
            "baseName": "Store",
            "type": "FlipdishPublicModelsV1StoresStoreSummary"
        },
        {
            "name": "Customer",
            "baseName": "Customer",
            "type": "FlipdishPublicModelsV1CustomersCustomerSummary"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "FlipdishPublicModelsV1VouchersOrderVoucherSummary"
        },
        {
            "name": "Fees",
            "baseName": "Fees",
            "type": "FlipdishPublicModelsV1FeesFeeSummary"
        },
        {
            "name": "OrderItems",
            "baseName": "OrderItems",
            "type": "Array<FlipdishPublicModelsV1OrdersOrderItem>"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "FlipdishPublicModelsV1DeliveryLocation"
        },
        {
            "name": "CustomerLocation",
            "baseName": "CustomerLocation",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "MaskedPhoneNumber",
            "baseName": "MaskedPhoneNumber",
            "type": "FlipdishPublicModelsV1OrdersMaskedPhoneNumber"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "RejectedByUserId",
            "baseName": "RejectedByUserId",
            "type": "number"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1OrdersOrder.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "FlipdishPublicModelsV1OrdersOrder.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "FlipdishPublicModelsV1OrdersOrder.TableServiceCatagoryEnum"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "OrderItemsAmount",
            "baseName": "OrderItemsAmount",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "FlipdishPublicModelsV1OrdersOrder.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentAccountDescription",
            "baseName": "PaymentAccountDescription",
            "type": "string"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "FlipdishPublicModelsV1OrdersOrder.OrderStateEnum"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "PlacedTime",
            "baseName": "PlacedTime",
            "type": "Date"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "FlipdishPublicModelsV1OrdersOrder.AppTypeEnum"
        },
        {
            "name": "UserRating",
            "baseName": "UserRating",
            "type": "number"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "FlipdishPublicModelsV1OrdersOrder.PaymentStatusEnum"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "FlipdishPublicModelsV1OrdersOrder.RejectionReasonEnum"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "DeliveryTrackingStatus",
            "baseName": "DeliveryTrackingStatus",
            "type": "FlipdishPublicModelsV1OrdersOrder.DeliveryTrackingStatusEnum"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "TotalTax",
            "baseName": "TotalTax",
            "type": "number"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersOrder.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrdersOrder {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
    export enum DeliveryTrackingStatusEnum {
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order item
*/
export class FlipdishPublicModelsV1OrdersOrderItem {
    /**
    * Option list
    */
    'OrderItemOptions'?: Array<FlipdishPublicModelsV1OrdersOrderItemOption>;
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId'?: string;
    /**
    * Menu section name
    */
    'MenuSectionName'?: string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems'?: number;
    /**
    * Menu item identifier
    */
    'MenuItemId'?: number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderItemOptions",
            "baseName": "OrderItemOptions",
            "type": "Array<FlipdishPublicModelsV1OrdersOrderItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "MenuItemDisplayOrder",
            "baseName": "MenuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersOrderItem.attributeTypeMap;
    }
}

/**
* Order item option
*/
export class FlipdishPublicModelsV1OrdersOrderItemOption {
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId'?: string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId'?: number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder'?: number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemOptionPublicId",
            "baseName": "MenuItemOptionPublicId",
            "type": "string"
        },
        {
            "name": "MenuItemOptionId",
            "baseName": "MenuItemOptionId",
            "type": "number"
        },
        {
            "name": "IsMasterOptionSetItem",
            "baseName": "IsMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "MenuItemOptionDisplayOrder",
            "baseName": "MenuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetDisplayOrder",
            "baseName": "MenuItemOptionSetDisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersOrderItemOption.attributeTypeMap;
    }
}

/**
* Order summary
*/
export class FlipdishPublicModelsV1OrdersOrderSummary {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: FlipdishPublicModelsV1OrdersOrderSummary.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: FlipdishPublicModelsV1OrdersOrderSummary.PickupLocationTypeEnum;
    /**
    * Table service category
    */
    'TableServiceCatagory'?: FlipdishPublicModelsV1OrdersOrderSummary.TableServiceCatagoryEnum;
    /**
    * Order state
    */
    'OrderState'?: FlipdishPublicModelsV1OrdersOrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone'?: string;
    /**
    * Name of the customer
    */
    'CustomerName'?: string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber'?: string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Payment Account
    */
    'PaymentAccountType'?: FlipdishPublicModelsV1OrdersOrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: FlipdishPublicModelsV1OrdersOrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency'?: FlipdishPublicModelsV1OrdersOrderSummary.CurrencyEnum;
    /**
    * Type of app end user is on
    */
    'AppType'?: FlipdishPublicModelsV1OrdersOrderSummary.AppTypeEnum;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * id of the collection/drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.TableServiceCatagoryEnum"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.OrderStateEnum"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreIanaTimeZone",
            "baseName": "StoreIanaTimeZone",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "CustomerPhoneNumber",
            "baseName": "CustomerPhoneNumber",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.PaymentStatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.CurrencyEnum"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "FlipdishPublicModelsV1OrdersOrderSummary.AppTypeEnum"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersOrderSummary.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrdersOrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
}
/**
* Refund
*/
export class FlipdishPublicModelsV1OrdersRefund {
    /**
    * Refund reason
    */
    'RefundReason'?: string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If true, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RefundReason",
            "baseName": "RefundReason",
            "type": "string"
        },
        {
            "name": "RefundAmount",
            "baseName": "RefundAmount",
            "type": "number"
        },
        {
            "name": "NotifyCustomer",
            "baseName": "NotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersRefund.attributeTypeMap;
    }
}

/**
* Reject
*/
export class FlipdishPublicModelsV1OrdersReject {
    /**
    * Reject reason.
    */
    'RejectReason': FlipdishPublicModelsV1OrdersReject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RejectReason",
            "baseName": "RejectReason",
            "type": "FlipdishPublicModelsV1OrdersReject.RejectReasonEnum"
        },
        {
            "name": "DoNotNotifyCustomer",
            "baseName": "DoNotNotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersReject.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrdersReject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Defines the order data required for customer driver tracking
*/
export class FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Pretified address string in country format
    */
    'Address'?: string;
    /**
    * Delivery Notes
    */
    'DeliveryNotes'?: string;
    /**
    * Phone number of the store
    */
    'StorePhoneNumber'?: string;
    /**
    * App Icon of the store
    */
    'AppIconUrl'?: string;
    /**
    * Order Tracking Code
    */
    'OrderTrackingCode'?: string;
    /**
    * Payment method description i.e Cash/Card/iDeal/Paypal
    */
    'PaymentMethodDescription'?: string;
    /**
    * Last 4 digits of the card if applicable otherwise null
    */
    'LastFourDigits'?: string;
    /**
    * Order lines of the order
    */
    'OrderLines'?: Array<FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine>;
    /**
    * Total amount for the order including tax
    */
    'TotalAmount'?: number;
    /**
    * Currency
    */
    'Currency'?: FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder.CurrencyEnum;
    /**
    * Customer Location Latitude
    */
    'Latitude'?: number;
    /**
    * Customer Location Longitude
    */
    'Longitude'?: number;
    /**
    * Order placed time
    */
    'Placed'?: Date;
    /**
    * Order requested for
    */
    'RequestedFor'?: Date;
    /**
    * Driver Id
    */
    'DriverId'?: number;
    /**
    * Driver Name
    */
    'DriverName'?: string;
    /**
    * Driver Image
    */
    'DriverImage'?: string;
    /**
    * 
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "DeliveryNotes",
            "baseName": "DeliveryNotes",
            "type": "string"
        },
        {
            "name": "StorePhoneNumber",
            "baseName": "StorePhoneNumber",
            "type": "string"
        },
        {
            "name": "AppIconUrl",
            "baseName": "AppIconUrl",
            "type": "string"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        },
        {
            "name": "PaymentMethodDescription",
            "baseName": "PaymentMethodDescription",
            "type": "string"
        },
        {
            "name": "LastFourDigits",
            "baseName": "LastFourDigits",
            "type": "string"
        },
        {
            "name": "OrderLines",
            "baseName": "OrderLines",
            "type": "Array<FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine>"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder.CurrencyEnum"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Placed",
            "baseName": "Placed",
            "type": "Date"
        },
        {
            "name": "RequestedFor",
            "baseName": "RequestedFor",
            "type": "Date"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "DriverName",
            "baseName": "DriverName",
            "type": "string"
        },
        {
            "name": "DriverImage",
            "baseName": "DriverImage",
            "type": "string"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Defines an order line for driver tracking
*/
export class FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine {
    /**
    * Item name from the order
    */
    'ItemName'?: string;
    /**
    * Selected option names
    */
    'SelectedOptions'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "SelectedOptions",
            "baseName": "SelectedOptions",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class FlipdishPublicModelsV1PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId'?: number;
    /**
    * Time of the call
    */
    'TimeOfCall'?: Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal'?: Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId'?: number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName'?: string;
    /**
    * Name of the caller
    */
    'CallerName'?: string;
    /**
    * UserID of the caller
    */
    'CallerUserId'?: number;
    /**
    * Phone number of the caller
    */
    'CallerNumber'?: string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds'?: number;
    /**
    * The status of the call
    */
    'CallStatus'?: FlipdishPublicModelsV1PhoneCall.CallStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneCallId",
            "baseName": "PhoneCallId",
            "type": "number"
        },
        {
            "name": "TimeOfCall",
            "baseName": "TimeOfCall",
            "type": "Date"
        },
        {
            "name": "TimeOfCallLocal",
            "baseName": "TimeOfCallLocal",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "CallerName",
            "baseName": "CallerName",
            "type": "string"
        },
        {
            "name": "CallerUserId",
            "baseName": "CallerUserId",
            "type": "number"
        },
        {
            "name": "CallerNumber",
            "baseName": "CallerNumber",
            "type": "string"
        },
        {
            "name": "CallLengthInSeconds",
            "baseName": "CallLengthInSeconds",
            "type": "number"
        },
        {
            "name": "CallStatus",
            "baseName": "CallStatus",
            "type": "FlipdishPublicModelsV1PhoneCall.CallStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1PhoneCall.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Printer
*/
export class FlipdishPublicModelsV1Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber'?: string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "LastPollTime",
            "baseName": "LastPollTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1Printer.attributeTypeMap;
    }
}

/**
* Processing fee config
*/
export class FlipdishPublicModelsV1ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: FlipdishPublicModelsV1ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee'?: number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "FlipdishPublicModelsV1ProcessingFeeConfig.PaymentAccountTypeEnum"
        },
        {
            "name": "PercentFee",
            "baseName": "PercentFee",
            "type": "number"
        },
        {
            "name": "FixedFee",
            "baseName": "FixedFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1ProcessingFeeConfig.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal'
    }
}
/**
* Push Notification Details
*/
export class FlipdishPublicModelsV1PushNotificationsPushNotificationRequest {
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1PushNotificationsPushNotificationRequest.attributeTypeMap;
    }
}

/**
* Push Notification
*/
export class FlipdishPublicModelsV1PushNotificationsPushNotificationResponse {
    /**
    * Sent
    */
    'Sent'?: boolean;
    /**
    * Push notification identifier
    */
    'ScheduledPushNotificationId'?: number;
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sent",
            "baseName": "Sent",
            "type": "boolean"
        },
        {
            "name": "ScheduledPushNotificationId",
            "baseName": "ScheduledPushNotificationId",
            "type": "number"
        },
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1PushNotificationsPushNotificationResponse.attributeTypeMap;
    }
}

/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class FlipdishPublicModelsV1Range {
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Day of week
    */
    'DayOfWeek'?: FlipdishPublicModelsV1Range.DayOfWeekEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "FlipdishPublicModelsV1Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1Range.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Sms Info
*/
export class FlipdishPublicModelsV1SmsInfo {
    /**
    * Origin phone number
    */
    'From'?: string;
    /**
    * Destination phone number
    */
    'To'?: string;
    /**
    * Text message
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "string"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "string"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1SmsInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class FlipdishPublicModelsV1StoresBusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId'?: number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: FlipdishPublicModelsV1StoresBusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: FlipdishPublicModelsV1StoresBusinessHoursOverride.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BusinessHoursOverrideId",
            "baseName": "BusinessHoursOverrideId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverride.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverride.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresBusinessHoursOverride.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresBusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1StoresBusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresBusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Delivery Zone
*/
export class FlipdishPublicModelsV1StoresDeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id'?: number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresDeliveryZone.attributeTypeMap;
    }
}

/**
* Delivery Zone Base
*/
export class FlipdishPublicModelsV1StoresDeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresDeliveryZoneBase.attributeTypeMap;
    }
}

/**
* Describes coordinates that have a group
*/
export class FlipdishPublicModelsV1StoresGroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude'?: number;
    /**
    * Longitude of this coordinate
    */
    'Longitude'?: number;
    /**
    * Count of members in the group
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresGroupedCoordinates.attributeTypeMap;
    }
}

/**
* Pre Order Config
*/
export class FlipdishPublicModelsV1StoresPreOrderConfig {
    /**
    * Lead Time in Minutes
    */
    'LeadTimeMinutes'?: number;
    /**
    * Interval in minutes
    */
    'IntervalMinutes'?: number;
    /**
    * Max Days to order ahead
    */
    'MaxOrderAheadDays'?: number;
    /**
    * Show ASAP as option
    */
    'IncludeAsap'?: boolean;
    /**
    * Granual Init' Time
    */
    'IncludeMoreGranularInitialTime'?: boolean;
    /**
    * Cut off time previous day
    */
    'CutOffTimePreviousDayBasic'?: string;
    /**
    * Cut off time current day
    */
    'CutOffTimeCurrentDayBasic'?: string;
    /**
    * Type of time displayed.
    */
    'PreOrderTimeDisplayType'?: FlipdishPublicModelsV1StoresPreOrderConfig.PreOrderTimeDisplayTypeEnum;
    /**
    * Specifies whether a customer can pre-order outside the store opening hours or not.
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * Force customer to select collection time.
    */
    'RequireExplicitSelectAlways'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "number"
        },
        {
            "name": "IntervalMinutes",
            "baseName": "IntervalMinutes",
            "type": "number"
        },
        {
            "name": "MaxOrderAheadDays",
            "baseName": "MaxOrderAheadDays",
            "type": "number"
        },
        {
            "name": "IncludeAsap",
            "baseName": "IncludeAsap",
            "type": "boolean"
        },
        {
            "name": "IncludeMoreGranularInitialTime",
            "baseName": "IncludeMoreGranularInitialTime",
            "type": "boolean"
        },
        {
            "name": "CutOffTimePreviousDayBasic",
            "baseName": "CutOffTimePreviousDayBasic",
            "type": "string"
        },
        {
            "name": "CutOffTimeCurrentDayBasic",
            "baseName": "CutOffTimeCurrentDayBasic",
            "type": "string"
        },
        {
            "name": "PreOrderTimeDisplayType",
            "baseName": "PreOrderTimeDisplayType",
            "type": "FlipdishPublicModelsV1StoresPreOrderConfig.PreOrderTimeDisplayTypeEnum"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "RequireExplicitSelectAlways",
            "baseName": "RequireExplicitSelectAlways",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresPreOrderConfig.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresPreOrderConfig {
    export enum PreOrderTimeDisplayTypeEnum {
        SingleTime = <any> 'SingleTime',
        StartAndEndTime = <any> 'StartAndEndTime',
        DayOnly = <any> 'DayOnly'
    }
}
/**
* Time order can be placed
*/
export class FlipdishPublicModelsV1StoresPreOrderTime {
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresPreOrderTime.attributeTypeMap;
    }
}

/**
* Store
*/
export class FlipdishPublicModelsV1StoresStore {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId'?: number;
    /**
    * Store address
    */
    'Address'?: FlipdishPublicModelsV1StoresStoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones'?: Array<FlipdishPublicModelsV1StoresDeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber'?: string;
    /**
    * Pickup hours
    */
    'PickupHours'?: Array<FlipdishPublicModelsV1BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours'?: Array<FlipdishPublicModelsV1BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery'?: string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup'?: string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType'?: FlipdishPublicModelsV1StoresStore.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes'?: Array<FlipdishPublicModelsV1StoresStoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone'?: string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone'?: string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency'?: FlipdishPublicModelsV1StoresStore.CurrencyEnum;
    /**
    * Is PerOrder Enabled for Delivery
    */
    'PreOrderDeliveryEnabled'?: boolean;
    /**
    * Is PerOrder Enabled for Pickup
    */
    'PreOrderPickupEnabled'?: boolean;
    /**
    * Url for logo image
    */
    'LogoUrl'?: string;
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "FlipdishPublicModelsV1StoresStoreAddress"
        },
        {
            "name": "DeliveryZones",
            "baseName": "DeliveryZones",
            "type": "Array<FlipdishPublicModelsV1StoresDeliveryZone>"
        },
        {
            "name": "ApmPhoneNumber",
            "baseName": "ApmPhoneNumber",
            "type": "string"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "Array<FlipdishPublicModelsV1BusinessHoursPeriod>"
        },
        {
            "name": "DeliveryHours",
            "baseName": "DeliveryHours",
            "type": "Array<FlipdishPublicModelsV1BusinessHoursPeriod>"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "OrderConfirmationMessageOverrideDelivery",
            "baseName": "OrderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "OrderConfirmationMessageOverridePickup",
            "baseName": "OrderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "PrintoutLayoutType",
            "baseName": "PrintoutLayoutType",
            "type": "FlipdishPublicModelsV1StoresStore.PrintoutLayoutTypeEnum"
        },
        {
            "name": "StoreNotes",
            "baseName": "StoreNotes",
            "type": "Array<FlipdishPublicModelsV1StoresStoreNote>"
        },
        {
            "name": "MicrosoftTimeZone",
            "baseName": "MicrosoftTimeZone",
            "type": "string"
        },
        {
            "name": "IanaTimeZone",
            "baseName": "IanaTimeZone",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStore.CurrencyEnum"
        },
        {
            "name": "PreOrderDeliveryEnabled",
            "baseName": "PreOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "PreOrderPickupEnabled",
            "baseName": "PreOrderPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "LogoUrl",
            "baseName": "LogoUrl",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStore.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStore {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store address
*/
export class FlipdishPublicModelsV1StoresStoreAddress {
    /**
    * Address identifier
    */
    'AddressId'?: number;
    /**
    * Coordinate
    */
    'Coordinates'?: FlipdishPublicModelsV1Coordinates;
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressId",
            "baseName": "AddressId",
            "type": "number"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreAddress.attributeTypeMap;
    }
}

/**
* Store address base
*/
export class FlipdishPublicModelsV1StoresStoreAddressBase {
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreAddressBase.attributeTypeMap;
    }
}

/**
* Store Base
*/
export class FlipdishPublicModelsV1StoresStoreBase {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreBase.attributeTypeMap;
    }
}

/**
* Settings for cloning a store
*/
export class FlipdishPublicModelsV1StoresStoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TargetStoreGroupId",
            "baseName": "TargetStoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreCloneSettings.attributeTypeMap;
    }
}

/**
* Store Create Base
*/
export class FlipdishPublicModelsV1StoresStoreCreateBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreCreateBase.attributeTypeMap;
    }
}

/**
* Store Data Point
*/
export class FlipdishPublicModelsV1StoresStoreDataPoint {
    /**
    * Day
    */
    'Day'?: Date;
    /**
    * Value for the day
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "Date"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreDataPoint.attributeTypeMap;
    }
}

/**
* Store end of day report
*/
export class FlipdishPublicModelsV1StoresStoreEndOfDayReport {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Currency
    */
    'Currency'?: FlipdishPublicModelsV1StoresStoreEndOfDayReport.CurrencyEnum;
    /**
    * Order Count
    */
    'OrderCount'?: number;
    /**
    * Order Value
    */
    'OrderValue'?: number;
    /**
    * Order Value Excluding Delivery Fees
    */
    'OrderValueExcludingDeliveryFees'?: number;
    /**
    * Collection Order Count
    */
    'CollectionOrderCount'?: number;
    /**
    * Collection Cash Order Count
    */
    'CollectionCashOrderCount'?: number;
    /**
    * Collection Paid Online Order Count
    */
    'CollectionPaidOnlineOrderCount'?: number;
    /**
    * Collection Order Value
    */
    'CollectionOrderValue'?: number;
    /**
    * Collection Cash Order Value
    */
    'CollectionCashOrderValue'?: number;
    /**
    * Collection Paid Online Order Value
    */
    'CollectionPaidOnlineOrderValue'?: number;
    /**
    * Delivery Order Count
    */
    'DeliveryOrderCount'?: number;
    /**
    * Delivery Cash Order Count
    */
    'DeliveryCashOrderCount'?: number;
    /**
    * Delivery Paid Online Order Count
    */
    'DeliveryPaidOnlineOrderCount'?: number;
    /**
    * Delivery Order Value
    */
    'DeliveryOrderValue'?: number;
    /**
    * Delivery Cash Order Value
    */
    'DeliveryCashOrderValue'?: number;
    /**
    * Delivery Paid Online Order Value
    */
    'DeliveryPaidOnlineOrderValue'?: number;
    /**
    * Paid Online Order Count
    */
    'PaidOnlineOrderCount'?: number;
    /**
    * Cash Order Count
    */
    'CashOrderCount'?: number;
    /**
    * Paid Online Order Value
    */
    'PaidOnlineOrderValue'?: number;
    /**
    * Cash Order Value
    */
    'CashOrderValue'?: number;
    /**
    * Paid Online Order Value Excluding Delivery Fees
    */
    'PaidOnlineOrderValueExcludingDeliveryFees'?: number;
    /**
    * Cash Order Value Excluding Delivery Fees
    */
    'CashOrderValueExcludingDeliveryFees'?: number;
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStoreEndOfDayReport.CurrencyEnum"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        },
        {
            "name": "OrderValueExcludingDeliveryFees",
            "baseName": "OrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CollectionOrderCount",
            "baseName": "CollectionOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderCount",
            "baseName": "CollectionCashOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderCount",
            "baseName": "CollectionPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionOrderValue",
            "baseName": "CollectionOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderValue",
            "baseName": "CollectionCashOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderValue",
            "baseName": "CollectionPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryOrderCount",
            "baseName": "DeliveryOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderCount",
            "baseName": "DeliveryCashOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderCount",
            "baseName": "DeliveryPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryOrderValue",
            "baseName": "DeliveryOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderValue",
            "baseName": "DeliveryCashOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderValue",
            "baseName": "DeliveryPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderCount",
            "baseName": "PaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CashOrderCount",
            "baseName": "CashOrderCount",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValue",
            "baseName": "PaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "CashOrderValue",
            "baseName": "CashOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValueExcludingDeliveryFees",
            "baseName": "PaidOnlineOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CashOrderValueExcludingDeliveryFees",
            "baseName": "CashOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreEndOfDayReport.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStoreEndOfDayReport {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store Group
*/
export class FlipdishPublicModelsV1StoresStoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: FlipdishPublicModelsV1StoresStoreGroup.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStoreGroup.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreGroup.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Update Store Group
*/
export class FlipdishPublicModelsV1StoresStoreGroupBase {
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: FlipdishPublicModelsV1StoresStoreGroupBase.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStoreGroupBase.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreGroupBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store Group Extended
*/
export class FlipdishPublicModelsV1StoresStoreGroupExtended {
    /**
    * Total Amount of Stores
    */
    'TotalStores'?: number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates'?: Array<FlipdishPublicModelsV1StoresGroupedCoordinates>;
    /**
    * Store Headers associated with Store Group
    */
    'StoreHeaders'?: Array<FlipdishPublicModelsV1StoresStoreHeader>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: FlipdishPublicModelsV1StoresStoreGroupExtended.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalStores",
            "baseName": "TotalStores",
            "type": "number"
        },
        {
            "name": "GroupedCoordinates",
            "baseName": "GroupedCoordinates",
            "type": "Array<FlipdishPublicModelsV1StoresGroupedCoordinates>"
        },
        {
            "name": "StoreHeaders",
            "baseName": "StoreHeaders",
            "type": "Array<FlipdishPublicModelsV1StoresStoreHeader>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStoreGroupExtended.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreGroupExtended.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Represents the most basic store information, used mostly for searches
*/
export class FlipdishPublicModelsV1StoresStoreHeader {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreHeader.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class FlipdishPublicModelsV1StoresStoreKioskSetting {
    /**
    * Kiosk setting id
    */
    'KioskSettingId'?: number;
    /**
    * Store kiosk name
    */
    'KioskName'?: string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName'?: boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber'?: boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOption'?: boolean;
    /**
    * Physical restaurant id
    */
    'PhysicalRestaurantId'?: number;
    /**
    * Hydra config id
    */
    'HydraConfigId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskSettingId",
            "baseName": "KioskSettingId",
            "type": "number"
        },
        {
            "name": "KioskName",
            "baseName": "KioskName",
            "type": "string"
        },
        {
            "name": "RequireCustomerName",
            "baseName": "RequireCustomerName",
            "type": "boolean"
        },
        {
            "name": "RequestTableNumber",
            "baseName": "RequestTableNumber",
            "type": "boolean"
        },
        {
            "name": "OfferDineInOrTakeawayOption",
            "baseName": "OfferDineInOrTakeawayOption",
            "type": "boolean"
        },
        {
            "name": "PhysicalRestaurantId",
            "baseName": "PhysicalRestaurantId",
            "type": "number"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreKioskSetting.attributeTypeMap;
    }
}

/**
* Store note
*/
export class FlipdishPublicModelsV1StoresStoreNote {
    /**
    * User identifier
    */
    'UserId'?: number;
    /**
    * Create time
    */
    'CreateTime'?: Date;
    /**
    * Note
    */
    'Note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Note",
            "baseName": "Note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreNote.attributeTypeMap;
    }
}

/**
* Store statistics
*/
export class FlipdishPublicModelsV1StoresStoreStatistics {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Data Points
    */
    'Data'?: Array<FlipdishPublicModelsV1StoresStoreDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FlipdishPublicModelsV1StoresStoreDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreStatistics.attributeTypeMap;
    }
}

/**
* Store summary
*/
export class FlipdishPublicModelsV1StoresStoreSummary {
    /**
    * Store identifier
    */
    'Id'?: number;
    /**
    * Store name
    */
    'Name'?: string;
    /**
    * Stores menu identifier
    */
    'MenuId'?: number;
    /**
    * Store metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency'?: FlipdishPublicModelsV1StoresStoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates'?: FlipdishPublicModelsV1Coordinates;
    /**
    * Timezone of store
    */
    'StoreTimezone'?: string;
    /**
    * Store group id of store
    */
    'StoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1StoresStoreSummary.CurrencyEnum"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "FlipdishPublicModelsV1Coordinates"
        },
        {
            "name": "StoreTimezone",
            "baseName": "StoreTimezone",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StoresStoreSummary.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StoresStoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Job Address
*/
export class FlipdishPublicModelsV1StuartJobAddress {
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country
    */
    'Country'?: string;
    /**
    * Zone
    */
    'Zone'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Country",
            "baseName": "Country",
            "type": "string"
        },
        {
            "name": "Zone",
            "baseName": "Zone",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobAddress.attributeTypeMap;
    }
}

/**
* Job Cancellation
*/
export class FlipdishPublicModelsV1StuartJobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy'?: string;
    /**
    * Reason Key
    */
    'ReasonKey'?: string;
    /**
    * Comment
    */
    'Comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanceledBy",
            "baseName": "CanceledBy",
            "type": "string"
        },
        {
            "name": "ReasonKey",
            "baseName": "ReasonKey",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobCancellation.attributeTypeMap;
    }
}

/**
* Job Contact
*/
export class FlipdishPublicModelsV1StuartJobContact {
    /**
    * Firstname
    */
    'Firstname'?: string;
    /**
    * Lastname
    */
    'Lastname'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Company
    */
    'Company'?: string;
    /**
    * Company Name
    */
    'CompanyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Firstname",
            "baseName": "Firstname",
            "type": "string"
        },
        {
            "name": "Lastname",
            "baseName": "Lastname",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Company",
            "baseName": "Company",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobContact.attributeTypeMap;
    }
}

/**
* Job Delivery
*/
export class FlipdishPublicModelsV1StuartJobDelivery {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Picked At
    */
    'PickedAt'?: string;
    /**
    * Delivered At
    */
    'DeliveredAt'?: string;
    /**
    * Tracking Url
    */
    'TrackingUrl'?: string;
    /**
    * Client Reference
    */
    'ClientReference'?: string;
    /**
    * Package Description
    */
    'PackageDescription'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Pickup
    */
    'Pickup'?: FlipdishPublicModelsV1StuartJobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff'?: FlipdishPublicModelsV1StuartJobDeliveryDetail;
    /**
    * Eta
    */
    'Eta'?: FlipdishPublicModelsV1StuartJobEta;
    /**
    * Cancellation
    */
    'Cancellation'?: FlipdishPublicModelsV1StuartJobCancellation;
    /**
    * Proof
    */
    'Proof'?: FlipdishPublicModelsV1StuartJobProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PickedAt",
            "baseName": "PickedAt",
            "type": "string"
        },
        {
            "name": "DeliveredAt",
            "baseName": "DeliveredAt",
            "type": "string"
        },
        {
            "name": "TrackingUrl",
            "baseName": "TrackingUrl",
            "type": "string"
        },
        {
            "name": "ClientReference",
            "baseName": "ClientReference",
            "type": "string"
        },
        {
            "name": "PackageDescription",
            "baseName": "PackageDescription",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "FlipdishPublicModelsV1StuartJobDeliveryDetail"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "FlipdishPublicModelsV1StuartJobDeliveryDetail"
        },
        {
            "name": "Eta",
            "baseName": "Eta",
            "type": "FlipdishPublicModelsV1StuartJobEta"
        },
        {
            "name": "Cancellation",
            "baseName": "Cancellation",
            "type": "FlipdishPublicModelsV1StuartJobCancellation"
        },
        {
            "name": "Proof",
            "baseName": "Proof",
            "type": "FlipdishPublicModelsV1StuartJobProof"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobDelivery.attributeTypeMap;
    }
}

/**
* Job Delivery Detail
*/
export class FlipdishPublicModelsV1StuartJobDeliveryDetail {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Address
    */
    'Address'?: FlipdishPublicModelsV1StuartJobAddress;
    /**
    * Contact
    */
    'Contact'?: FlipdishPublicModelsV1StuartJobContact;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "FlipdishPublicModelsV1StuartJobAddress"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "FlipdishPublicModelsV1StuartJobContact"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobDeliveryDetail.attributeTypeMap;
    }
}

/**
* Job Driver
*/
export class FlipdishPublicModelsV1StuartJobDriver {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Display Name
    */
    'DisplayName'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Picture Url
    */
    'PictureUrl'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "PictureUrl",
            "baseName": "PictureUrl",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobDriver.attributeTypeMap;
    }
}

/**
* Job Eta
*/
export class FlipdishPublicModelsV1StuartJobEta {
    /**
    * Pickup
    */
    'Pickup'?: string;
    /**
    * Dropoff
    */
    'Dropoff'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "string"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobEta.attributeTypeMap;
    }
}

/**
* Job Pricing
*/
export class FlipdishPublicModelsV1StuartJobPricing {
    /**
    * Currency
    */
    'Currency'?: string;
    /**
    * Tax Percentage
    */
    'TaxPercentage'?: number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded'?: number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded'?: number;
    /**
    * Tax Amount
    */
    'TaxAmount'?: number;
    /**
    * Invoice Url
    */
    'InvoiceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "TaxPercentage",
            "baseName": "TaxPercentage",
            "type": "number"
        },
        {
            "name": "PriceTaxIncluded",
            "baseName": "PriceTaxIncluded",
            "type": "number"
        },
        {
            "name": "PriceTaxExcluded",
            "baseName": "PriceTaxExcluded",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "InvoiceUrl",
            "baseName": "InvoiceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobPricing.attributeTypeMap;
    }
}

/**
* Job Proof
*/
export class FlipdishPublicModelsV1StuartJobProof {
    /**
    * Signature Url
    */
    'SignatureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SignatureUrl",
            "baseName": "SignatureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobProof.attributeTypeMap;
    }
}

/**
* Job Response
*/
export class FlipdishPublicModelsV1StuartJobResponse {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Created At
    */
    'CreatedAt'?: Date;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Assignment Code
    */
    'AssignmentCode'?: string;
    /**
    * Pickup At
    */
    'PickupAt'?: string;
    /**
    * Dropoff At
    */
    'DropoffAt'?: string;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Distance
    */
    'Distance'?: number;
    /**
    * Duration
    */
    'Duration'?: number;
    /**
    * Deliveries
    */
    'Deliveries'?: Array<FlipdishPublicModelsV1StuartJobDelivery>;
    /**
    * Pricing
    */
    'Pricing'?: FlipdishPublicModelsV1StuartJobPricing;
    /**
    * Driver
    */
    'Driver'?: FlipdishPublicModelsV1StuartJobDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "CreatedAt",
            "baseName": "CreatedAt",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "AssignmentCode",
            "baseName": "AssignmentCode",
            "type": "string"
        },
        {
            "name": "PickupAt",
            "baseName": "PickupAt",
            "type": "string"
        },
        {
            "name": "DropoffAt",
            "baseName": "DropoffAt",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Distance",
            "baseName": "Distance",
            "type": "number"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "number"
        },
        {
            "name": "Deliveries",
            "baseName": "Deliveries",
            "type": "Array<FlipdishPublicModelsV1StuartJobDelivery>"
        },
        {
            "name": "Pricing",
            "baseName": "Pricing",
            "type": "FlipdishPublicModelsV1StuartJobPricing"
        },
        {
            "name": "Driver",
            "baseName": "Driver",
            "type": "FlipdishPublicModelsV1StuartJobDriver"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartJobResponse.attributeTypeMap;
    }
}

/**
* Stuart settings
*/
export class FlipdishPublicModelsV1StuartStuartSettings {
    /**
    * Client Id
    */
    'ClientId'?: string;
    /**
    * Client Secret
    */
    'ClientSecret'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication'?: string;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime'?: number;
    /**
    * Package type
    */
    'PackageType'?: FlipdishPublicModelsV1StuartStuartSettings.PackageTypeEnum;
    /**
    * Transport type
    */
    'TransportType'?: FlipdishPublicModelsV1StuartStuartSettings.TransportTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "ClientSecret",
            "baseName": "ClientSecret",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "WebhookUrlBasicAuthentication",
            "baseName": "WebhookUrlBasicAuthentication",
            "type": "string"
        },
        {
            "name": "MinutesToPickupBeforeThanDeliveryTime",
            "baseName": "MinutesToPickupBeforeThanDeliveryTime",
            "type": "number"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "FlipdishPublicModelsV1StuartStuartSettings.PackageTypeEnum"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "FlipdishPublicModelsV1StuartStuartSettings.TransportTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1StuartStuartSettings.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1StuartStuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
    export enum TransportTypeEnum {
        Bike = <any> 'Bike',
        Cargobike = <any> 'Cargobike',
        Cargobikexl = <any> 'Cargobikexl',
        Motorbike = <any> 'Motorbike',
        Motorbikexl = <any> 'Motorbikexl',
        Car = <any> 'Car',
        Van = <any> 'Van'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1TeammatesCreateTeammate {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: FlipdishPublicModelsV1TeammatesCreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "FlipdishPublicModelsV1TeammatesCreateTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1TeammatesCreateTeammate.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1TeammatesCreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1TeammatesRedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: FlipdishPublicModelsV1TeammatesRedeemInvitationResult.InvitationStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "FlipdishPublicModelsV1TeammatesRedeemInvitationResult.InvitationStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1TeammatesRedeemInvitationResult.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1TeammatesRedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1TeammatesTeammate {
    /**
    * Unique indentifier
    */
    'TeammateId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Last activity
    */
    'LastActivity'?: Date;
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: FlipdishPublicModelsV1TeammatesTeammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: FlipdishPublicModelsV1TeammatesTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TeammateId",
            "baseName": "TeammateId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "LastActivity",
            "baseName": "LastActivity",
            "type": "Date"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "FlipdishPublicModelsV1TeammatesTeammate.InvitationStatusEnum"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "FlipdishPublicModelsV1TeammatesTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1TeammatesTeammate.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1TeammatesTeammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class FlipdishPublicModelsV1TeammatesTeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel'?: FlipdishPublicModelsV1TeammatesTeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "FlipdishPublicModelsV1TeammatesTeammateBase.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1TeammatesTeammateBase.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1TeammatesTeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* User Event Info
*/
export class FlipdishPublicModelsV1UserEventInfo {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * User Email
    */
    'UserEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1UserEventInfo.attributeTypeMap;
    }
}

/**
* Add item details
*/
export class FlipdishPublicModelsV1VouchersAddItemDetails {
    /**
    * Promotional Item Id
    */
    'PromotionalItemId'?: number;
    /**
    * Promotional Item Name
    */
    'PromotionalItemName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionalItemId",
            "baseName": "PromotionalItemId",
            "type": "number"
        },
        {
            "name": "PromotionalItemName",
            "baseName": "PromotionalItemName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersAddItemDetails.attributeTypeMap;
    }
}

/**
* Voucher
*/
export class FlipdishPublicModelsV1VouchersCreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType'?: FlipdishPublicModelsV1VouchersCreateVoucher.VoucherTypeEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Add item details
    */
    'AddItemDetails'?: FlipdishPublicModelsV1VouchersAddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: FlipdishPublicModelsV1VouchersCreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: FlipdishPublicModelsV1VouchersLumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: FlipdishPublicModelsV1VouchersPercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "FlipdishPublicModelsV1VouchersCreateVoucher.VoucherTypeEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "FlipdishPublicModelsV1VouchersAddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "FlipdishPublicModelsV1VouchersCreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersLumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersPercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersCreateVoucher.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1VouchersCreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
}
/**
* Credit note details
*/
export class FlipdishPublicModelsV1VouchersCreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RemainingCredit",
            "baseName": "RemainingCredit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersCreditNoteDetails.attributeTypeMap;
    }
}

/**
* Lump discount details
*/
export class FlipdishPublicModelsV1VouchersLumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DiscountAmount",
            "baseName": "DiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersLumpDiscountDetails.attributeTypeMap;
    }
}

/**
* Voucher summary
*/
export class FlipdishPublicModelsV1VouchersOrderVoucherSummary {
    /**
    * Voucher name
    */
    'Name'?: string;
    /**
    * Voucher description
    */
    'Description'?: string;
    /**
    * Voucher code
    */
    'Code'?: string;
    /**
    * Voucher amount
    */
    'Amount'?: number;
    /**
    * Voucher type
    */
    'Type'?: FlipdishPublicModelsV1VouchersOrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType'?: FlipdishPublicModelsV1VouchersOrderVoucherSummary.SubTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "FlipdishPublicModelsV1VouchersOrderVoucherSummary.TypeEnum"
        },
        {
            "name": "SubType",
            "baseName": "SubType",
            "type": "FlipdishPublicModelsV1VouchersOrderVoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersOrderVoucherSummary.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1VouchersOrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Percent discount details
*/
export class FlipdishPublicModelsV1VouchersPercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PercentageDiscount",
            "baseName": "PercentageDiscount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersPercentDiscountDetails.attributeTypeMap;
    }
}

/**
* Voucher
*/
export class FlipdishPublicModelsV1VouchersVoucher {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: FlipdishPublicModelsV1VouchersVoucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: FlipdishPublicModelsV1VouchersVoucher.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: FlipdishPublicModelsV1VouchersVoucher.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: FlipdishPublicModelsV1VouchersVoucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: FlipdishPublicModelsV1VouchersAddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: FlipdishPublicModelsV1VouchersCreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: FlipdishPublicModelsV1VouchersLumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: FlipdishPublicModelsV1VouchersPercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "FlipdishPublicModelsV1VouchersVoucher.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "FlipdishPublicModelsV1VouchersVoucher.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "FlipdishPublicModelsV1VouchersVoucher.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1VouchersVoucher.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "FlipdishPublicModelsV1VouchersAddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "FlipdishPublicModelsV1VouchersCreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersLumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersPercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersVoucher.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1VouchersVoucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Voucher Base
*/
export class FlipdishPublicModelsV1VouchersVoucherBase {
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersVoucherBase.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class FlipdishPublicModelsV1VouchersVoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersVoucherDataPoint.attributeTypeMap;
    }
}

/**
* Voucher Summary
*/
export class FlipdishPublicModelsV1VouchersVoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Status
    */
    'Status'?: FlipdishPublicModelsV1VouchersVoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: FlipdishPublicModelsV1VouchersVoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: FlipdishPublicModelsV1VouchersVoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "FlipdishPublicModelsV1VouchersVoucherSummary.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "FlipdishPublicModelsV1VouchersVoucherSummary.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "FlipdishPublicModelsV1VouchersVoucherSummary.VoucherSubTypeEnum"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersVoucherSummary.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1VouchersVoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher With Statistics
*/
export class FlipdishPublicModelsV1VouchersVoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed'?: number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers'?: number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders'?: number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted'?: number;
    /**
    * Average Order Size
    */
    'AverageOrderSize'?: number;
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: FlipdishPublicModelsV1VouchersVoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: FlipdishPublicModelsV1VouchersVoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: FlipdishPublicModelsV1VouchersAddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: FlipdishPublicModelsV1VouchersCreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: FlipdishPublicModelsV1VouchersLumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: FlipdishPublicModelsV1VouchersPercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalUsed",
            "baseName": "TotalUsed",
            "type": "number"
        },
        {
            "name": "TotalCustomers",
            "baseName": "TotalCustomers",
            "type": "number"
        },
        {
            "name": "TotalAmountFromOrders",
            "baseName": "TotalAmountFromOrders",
            "type": "number"
        },
        {
            "name": "TotalDiscounted",
            "baseName": "TotalDiscounted",
            "type": "number"
        },
        {
            "name": "AverageOrderSize",
            "baseName": "AverageOrderSize",
            "type": "number"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "FlipdishPublicModelsV1VouchersVoucherWithStats.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "FlipdishPublicModelsV1VouchersVoucherWithStats.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "FlipdishPublicModelsV1VouchersAddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "FlipdishPublicModelsV1VouchersCreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersLumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "FlipdishPublicModelsV1VouchersPercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1VouchersVoucherWithStats.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1VouchersVoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Webhook log
*/
export class FlipdishPublicModelsV1WebhooksWebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId'?: number;
    /**
    * Event created
    */
    'EventCreated'?: string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered'?: string;
    /**
    * Webhook event name
    */
    'WebhookEventName'?: string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl'?: string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode'?: string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus'?: string;
    /**
    * Request headers
    */
    'RequestHeaders'?: string;
    /**
    * Request body
    */
    'RequestBody'?: string;
    /**
    * Received response headers
    */
    'ResponseHeaders'?: string;
    /**
    * Received response body
    */
    'ResponseBody'?: string;
    /**
    * Duration of HTTP request
    */
    'Duration'?: string;
    /**
    * Retry count
    */
    'RetryCount'?: number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId'?: string;
    /**
    * Flipdish webhook version
    */
    'Version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebhookSubscriptionOwnerUserId",
            "baseName": "WebhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "EventCreated",
            "baseName": "EventCreated",
            "type": "string"
        },
        {
            "name": "WebhookTriggered",
            "baseName": "WebhookTriggered",
            "type": "string"
        },
        {
            "name": "WebhookEventName",
            "baseName": "WebhookEventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionCallbackUrl",
            "baseName": "WebhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "HttpResponseStatusCode",
            "baseName": "HttpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "HttpResponseStatus",
            "baseName": "HttpResponseStatus",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "string"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "string"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "string"
        },
        {
            "name": "RetryCount",
            "baseName": "RetryCount",
            "type": "number"
        },
        {
            "name": "FlipdishWebhookId",
            "baseName": "FlipdishWebhookId",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebhooksWebhookLog.attributeTypeMap;
    }
}

/**
* Webhook subscription
*/
export class FlipdishPublicModelsV1WebhooksWebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version'?: string;
    /**
    * Webhook subscription event names
    */
    'EventNames'?: Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl'?: string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled'?: boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "EventNames",
            "baseName": "EventNames",
            "type": "Array<string>"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "VerifyToken",
            "baseName": "VerifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebhooksWebhookSubscription.attributeTypeMap;
    }
}

/**
* Index Page
*/
export class FlipdishPublicModelsV1WebsiteIndexPage {
    /**
    * Testimonials
    */
    'Testimonials'?: Array<FlipdishPublicModelsV1WebsiteWebsiteTestimonial>;
    /**
    * Images
    */
    'Images'?: Array<FlipdishPublicModelsV1WebsiteWebsiteImage>;
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Testimonials",
            "baseName": "Testimonials",
            "type": "Array<FlipdishPublicModelsV1WebsiteWebsiteTestimonial>"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<FlipdishPublicModelsV1WebsiteWebsiteImage>"
        },
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebsiteIndexPage.attributeTypeMap;
    }
}

/**
* Base of Index Page
*/
export class FlipdishPublicModelsV1WebsiteIndexPageBase {
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebsiteIndexPageBase.attributeTypeMap;
    }
}

/**
* Represents a website image
*/
export class FlipdishPublicModelsV1WebsiteWebsiteImage {
    /**
    * Represents the id of the image
    */
    'ImageId'?: number;
    /**
    * Represents the location of the image
    */
    'ImageLocation'?: FlipdishPublicModelsV1WebsiteWebsiteImage.ImageLocationEnum;
    /**
    * Represents the image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageId",
            "baseName": "ImageId",
            "type": "number"
        },
        {
            "name": "ImageLocation",
            "baseName": "ImageLocation",
            "type": "FlipdishPublicModelsV1WebsiteWebsiteImage.ImageLocationEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebsiteWebsiteImage.attributeTypeMap;
    }
}

export namespace FlipdishPublicModelsV1WebsiteWebsiteImage {
    export enum ImageLocationEnum {
        IndexHeader = <any> 'IndexHeader',
        IndexAboutSectionLeft = <any> 'IndexAboutSectionLeft',
        IndexAboutSectionRight = <any> 'IndexAboutSectionRight',
        IndexGallery = <any> 'IndexGallery',
        IndexOpeningHoursHeader = <any> 'IndexOpeningHoursHeader',
        IndexTestimonialsHeader = <any> 'IndexTestimonialsHeader'
    }
}
/**
* Represents a testimonial
*/
export class FlipdishPublicModelsV1WebsiteWebsiteTestimonial {
    /**
    * Id of the testimonial
    */
    'TestimonialId'?: number;
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TestimonialId",
            "baseName": "TestimonialId",
            "type": "number"
        },
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebsiteWebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Represents a testimonial base
*/
export class FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase {
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "FlipdishPublicModelsV1AccountsSignupStep.ActionEnum": FlipdishPublicModelsV1AccountsSignupStep.ActionEnum,
        "FlipdishPublicModelsV1ApmApmHourlyDataPoint.DayEnum": FlipdishPublicModelsV1ApmApmHourlyDataPoint.DayEnum,
        "FlipdishPublicModelsV1ApmCurrencyData.CurrencyEnum": FlipdishPublicModelsV1ApmCurrencyData.CurrencyEnum,
        "FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint.CurrencyEnum": FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint.CurrencyEnum,
        "FlipdishPublicModelsV1AppsApp.AppAccessLevelEnum": FlipdishPublicModelsV1AppsApp.AppAccessLevelEnum,
        "FlipdishPublicModelsV1AppsApp.AppResourceSetEnum": FlipdishPublicModelsV1AppsApp.AppResourceSetEnum,
        "FlipdishPublicModelsV1AppsApp.ApplicationCategoryEnum": FlipdishPublicModelsV1AppsApp.ApplicationCategoryEnum,
        "FlipdishPublicModelsV1AppsAppConfigUpdateModel.ApplicationCategoryEnum": FlipdishPublicModelsV1AppsAppConfigUpdateModel.ApplicationCategoryEnum,
        "FlipdishPublicModelsV1AppsSupportedCountry.AddressLayoutEnum": FlipdishPublicModelsV1AppsSupportedCountry.AddressLayoutEnum,
        "FlipdishPublicModelsV1AppsSupportedCountry.PostCodeTypeEnum": FlipdishPublicModelsV1AppsSupportedCountry.PostCodeTypeEnum,
        "FlipdishPublicModelsV1AppsSupportedCountry.SupportRegionEnum": FlipdishPublicModelsV1AppsSupportedCountry.SupportRegionEnum,
        "FlipdishPublicModelsV1BankAccountBankAccount.AccountStateEnum": FlipdishPublicModelsV1BankAccountBankAccount.AccountStateEnum,
        "FlipdishPublicModelsV1BankAccountBankAccountCreate.CurrencyCodeEnum": FlipdishPublicModelsV1BankAccountBankAccountCreate.CurrencyCodeEnum,
        "FlipdishPublicModelsV1BankAccountBankAccountDetail.AccountStateEnum": FlipdishPublicModelsV1BankAccountBankAccountDetail.AccountStateEnum,
        "FlipdishPublicModelsV1BankAccountBankAccountDetail.CurrencyCodeEnum": FlipdishPublicModelsV1BankAccountBankAccountDetail.CurrencyCodeEnum,
        "FlipdishPublicModelsV1BankAccountBankAccountSummary.AccountStateEnum": FlipdishPublicModelsV1BankAccountBankAccountSummary.AccountStateEnum,
        "FlipdishPublicModelsV1BusinessHoursPeriod.DayOfWeekEnum": FlipdishPublicModelsV1BusinessHoursPeriod.DayOfWeekEnum,
        "FlipdishPublicModelsV1BusinessHoursPeriodBase.DayOfWeekEnum": FlipdishPublicModelsV1BusinessHoursPeriodBase.DayOfWeekEnum,
        "FlipdishPublicModelsV1DeliveryTrackingDriverStore.PresenceEnum": FlipdishPublicModelsV1DeliveryTrackingDriverStore.PresenceEnum,
        "FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent.HydraDeviceStatusEnum": FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent.HydraDeviceStatusEnum,
        "FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent.DeliveryTypeEnum": FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent.DeliveryTypeEnum,
        "FlipdishPublicModelsV1HomeHomeAction.HomeActionTypeEnum": FlipdishPublicModelsV1HomeHomeAction.HomeActionTypeEnum,
        "FlipdishPublicModelsV1HydraHydraConfig.PaymentOptionsEnum": FlipdishPublicModelsV1HydraHydraConfig.PaymentOptionsEnum,
        "FlipdishPublicModelsV1HydraHydraDeviceDetails.DeviceTypeEnum": FlipdishPublicModelsV1HydraHydraDeviceDetails.DeviceTypeEnum,
        "FlipdishPublicModelsV1HydraHydraDeviceDetails.StatusEnum": FlipdishPublicModelsV1HydraHydraDeviceDetails.StatusEnum,
        "FlipdishPublicModelsV1HydraHydraStatus.UserTypeEnum": FlipdishPublicModelsV1HydraHydraStatus.UserTypeEnum,
        "FlipdishPublicModelsV1LightspeedLightspeedSettings.PriceTypeEnum": FlipdishPublicModelsV1LightspeedLightspeedSettings.PriceTypeEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenu.MenuSectionBehaviourEnum": FlipdishPublicModelsV1MenusCreateFullMenu.MenuSectionBehaviourEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenu.TaxTypeEnum": FlipdishPublicModelsV1MenusCreateFullMenu.TaxTypeEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.SpicinessRatingEnum": FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.SpicinessRatingEnum,
        "FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusCreateFullMenuSectionItem.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenu.MenuSectionBehaviourEnum": FlipdishPublicModelsV1MenusMenu.MenuSectionBehaviourEnum,
        "FlipdishPublicModelsV1MenusMenu.TaxTypeEnum": FlipdishPublicModelsV1MenusMenu.TaxTypeEnum,
        "FlipdishPublicModelsV1MenusMenuBase.MenuSectionBehaviourEnum": FlipdishPublicModelsV1MenusMenuBase.MenuSectionBehaviourEnum,
        "FlipdishPublicModelsV1MenusMenuBase.TaxTypeEnum": FlipdishPublicModelsV1MenusMenuBase.TaxTypeEnum,
        "FlipdishPublicModelsV1MenusMenuItemOptionSet.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuItemOptionSet.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuItemOptionSetBase.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuItemOptionSetBase.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuItemOptionSetItem.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuItemOptionSetItem.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuSectionAvailability.AvailabilityModeEnum": FlipdishPublicModelsV1MenusMenuSectionAvailability.AvailabilityModeEnum,
        "FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase.AvailabilityModeEnum": FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase.AvailabilityModeEnum,
        "FlipdishPublicModelsV1MenusMenuSectionItem.SpicinessRatingEnum": FlipdishPublicModelsV1MenusMenuSectionItem.SpicinessRatingEnum,
        "FlipdishPublicModelsV1MenusMenuSectionItem.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuSectionItem.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuSectionItemBase.SpicinessRatingEnum": FlipdishPublicModelsV1MenusMenuSectionItemBase.SpicinessRatingEnum,
        "FlipdishPublicModelsV1MenusMenuSectionItemBase.CellLayoutTypeEnum": FlipdishPublicModelsV1MenusMenuSectionItemBase.CellLayoutTypeEnum,
        "FlipdishPublicModelsV1MenusMenuTaxDetails.TaxTypeEnum": FlipdishPublicModelsV1MenusMenuTaxDetails.TaxTypeEnum,
        "FlipdishPublicModelsV1OAuthClientsOAuthApp.FlowEnum": FlipdishPublicModelsV1OAuthClientsOAuthApp.FlowEnum,
        "FlipdishPublicModelsV1OAuthClientsOAuthApp.RefreshTokenUsageEnum": FlipdishPublicModelsV1OAuthClientsOAuthApp.RefreshTokenUsageEnum,
        "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig.DeliveryTypeEnum": FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig.DeliveryTypeEnum,
        "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod.DayOfTheWeekEnum": FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod.DayOfTheWeekEnum,
        "FlipdishPublicModelsV1OrdersOrder.DeliveryTypeEnum": FlipdishPublicModelsV1OrdersOrder.DeliveryTypeEnum,
        "FlipdishPublicModelsV1OrdersOrder.PickupLocationTypeEnum": FlipdishPublicModelsV1OrdersOrder.PickupLocationTypeEnum,
        "FlipdishPublicModelsV1OrdersOrder.TableServiceCatagoryEnum": FlipdishPublicModelsV1OrdersOrder.TableServiceCatagoryEnum,
        "FlipdishPublicModelsV1OrdersOrder.PaymentAccountTypeEnum": FlipdishPublicModelsV1OrdersOrder.PaymentAccountTypeEnum,
        "FlipdishPublicModelsV1OrdersOrder.OrderStateEnum": FlipdishPublicModelsV1OrdersOrder.OrderStateEnum,
        "FlipdishPublicModelsV1OrdersOrder.AppTypeEnum": FlipdishPublicModelsV1OrdersOrder.AppTypeEnum,
        "FlipdishPublicModelsV1OrdersOrder.PaymentStatusEnum": FlipdishPublicModelsV1OrdersOrder.PaymentStatusEnum,
        "FlipdishPublicModelsV1OrdersOrder.RejectionReasonEnum": FlipdishPublicModelsV1OrdersOrder.RejectionReasonEnum,
        "FlipdishPublicModelsV1OrdersOrder.DeliveryTrackingStatusEnum": FlipdishPublicModelsV1OrdersOrder.DeliveryTrackingStatusEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.DeliveryTypeEnum": FlipdishPublicModelsV1OrdersOrderSummary.DeliveryTypeEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.PickupLocationTypeEnum": FlipdishPublicModelsV1OrdersOrderSummary.PickupLocationTypeEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.TableServiceCatagoryEnum": FlipdishPublicModelsV1OrdersOrderSummary.TableServiceCatagoryEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.OrderStateEnum": FlipdishPublicModelsV1OrdersOrderSummary.OrderStateEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.PaymentAccountTypeEnum": FlipdishPublicModelsV1OrdersOrderSummary.PaymentAccountTypeEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.PaymentStatusEnum": FlipdishPublicModelsV1OrdersOrderSummary.PaymentStatusEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.CurrencyEnum": FlipdishPublicModelsV1OrdersOrderSummary.CurrencyEnum,
        "FlipdishPublicModelsV1OrdersOrderSummary.AppTypeEnum": FlipdishPublicModelsV1OrdersOrderSummary.AppTypeEnum,
        "FlipdishPublicModelsV1OrdersReject.RejectReasonEnum": FlipdishPublicModelsV1OrdersReject.RejectReasonEnum,
        "FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder.CurrencyEnum": FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder.CurrencyEnum,
        "FlipdishPublicModelsV1PhoneCall.CallStatusEnum": FlipdishPublicModelsV1PhoneCall.CallStatusEnum,
        "FlipdishPublicModelsV1ProcessingFeeConfig.PaymentAccountTypeEnum": FlipdishPublicModelsV1ProcessingFeeConfig.PaymentAccountTypeEnum,
        "FlipdishPublicModelsV1Range.DayOfWeekEnum": FlipdishPublicModelsV1Range.DayOfWeekEnum,
        "FlipdishPublicModelsV1StoresBusinessHoursOverride.DeliveryTypeEnum": FlipdishPublicModelsV1StoresBusinessHoursOverride.DeliveryTypeEnum,
        "FlipdishPublicModelsV1StoresBusinessHoursOverride.TypeEnum": FlipdishPublicModelsV1StoresBusinessHoursOverride.TypeEnum,
        "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.DeliveryTypeEnum": FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.DeliveryTypeEnum,
        "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.TypeEnum": FlipdishPublicModelsV1StoresBusinessHoursOverrideBase.TypeEnum,
        "FlipdishPublicModelsV1StoresPreOrderConfig.PreOrderTimeDisplayTypeEnum": FlipdishPublicModelsV1StoresPreOrderConfig.PreOrderTimeDisplayTypeEnum,
        "FlipdishPublicModelsV1StoresStore.PrintoutLayoutTypeEnum": FlipdishPublicModelsV1StoresStore.PrintoutLayoutTypeEnum,
        "FlipdishPublicModelsV1StoresStore.CurrencyEnum": FlipdishPublicModelsV1StoresStore.CurrencyEnum,
        "FlipdishPublicModelsV1StoresStoreEndOfDayReport.CurrencyEnum": FlipdishPublicModelsV1StoresStoreEndOfDayReport.CurrencyEnum,
        "FlipdishPublicModelsV1StoresStoreGroup.CurrencyEnum": FlipdishPublicModelsV1StoresStoreGroup.CurrencyEnum,
        "FlipdishPublicModelsV1StoresStoreGroupBase.CurrencyEnum": FlipdishPublicModelsV1StoresStoreGroupBase.CurrencyEnum,
        "FlipdishPublicModelsV1StoresStoreGroupExtended.CurrencyEnum": FlipdishPublicModelsV1StoresStoreGroupExtended.CurrencyEnum,
        "FlipdishPublicModelsV1StoresStoreSummary.CurrencyEnum": FlipdishPublicModelsV1StoresStoreSummary.CurrencyEnum,
        "FlipdishPublicModelsV1StuartStuartSettings.PackageTypeEnum": FlipdishPublicModelsV1StuartStuartSettings.PackageTypeEnum,
        "FlipdishPublicModelsV1StuartStuartSettings.TransportTypeEnum": FlipdishPublicModelsV1StuartStuartSettings.TransportTypeEnum,
        "FlipdishPublicModelsV1TeammatesCreateTeammate.AppAccessLevelEnum": FlipdishPublicModelsV1TeammatesCreateTeammate.AppAccessLevelEnum,
        "FlipdishPublicModelsV1TeammatesRedeemInvitationResult.InvitationStatusEnum": FlipdishPublicModelsV1TeammatesRedeemInvitationResult.InvitationStatusEnum,
        "FlipdishPublicModelsV1TeammatesTeammate.InvitationStatusEnum": FlipdishPublicModelsV1TeammatesTeammate.InvitationStatusEnum,
        "FlipdishPublicModelsV1TeammatesTeammate.AppAccessLevelEnum": FlipdishPublicModelsV1TeammatesTeammate.AppAccessLevelEnum,
        "FlipdishPublicModelsV1TeammatesTeammateBase.AppAccessLevelEnum": FlipdishPublicModelsV1TeammatesTeammateBase.AppAccessLevelEnum,
        "FlipdishPublicModelsV1VouchersCreateVoucher.VoucherTypeEnum": FlipdishPublicModelsV1VouchersCreateVoucher.VoucherTypeEnum,
        "FlipdishPublicModelsV1VouchersOrderVoucherSummary.TypeEnum": FlipdishPublicModelsV1VouchersOrderVoucherSummary.TypeEnum,
        "FlipdishPublicModelsV1VouchersOrderVoucherSummary.SubTypeEnum": FlipdishPublicModelsV1VouchersOrderVoucherSummary.SubTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucher.StatusEnum": FlipdishPublicModelsV1VouchersVoucher.StatusEnum,
        "FlipdishPublicModelsV1VouchersVoucher.VoucherTypeEnum": FlipdishPublicModelsV1VouchersVoucher.VoucherTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucher.VoucherSubTypeEnum": FlipdishPublicModelsV1VouchersVoucher.VoucherSubTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucher.CurrencyEnum": FlipdishPublicModelsV1VouchersVoucher.CurrencyEnum,
        "FlipdishPublicModelsV1VouchersVoucherSummary.StatusEnum": FlipdishPublicModelsV1VouchersVoucherSummary.StatusEnum,
        "FlipdishPublicModelsV1VouchersVoucherSummary.VoucherTypeEnum": FlipdishPublicModelsV1VouchersVoucherSummary.VoucherTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucherSummary.VoucherSubTypeEnum": FlipdishPublicModelsV1VouchersVoucherSummary.VoucherSubTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucherWithStats.StatusEnum": FlipdishPublicModelsV1VouchersVoucherWithStats.StatusEnum,
        "FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherTypeEnum": FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherSubTypeEnum": FlipdishPublicModelsV1VouchersVoucherWithStats.VoucherSubTypeEnum,
        "FlipdishPublicModelsV1VouchersVoucherWithStats.CurrencyEnum": FlipdishPublicModelsV1VouchersVoucherWithStats.CurrencyEnum,
        "FlipdishPublicModelsV1WebsiteWebsiteImage.ImageLocationEnum": FlipdishPublicModelsV1WebsiteWebsiteImage.ImageLocationEnum,
}

let typeMap: {[index: string]: any} = {
    "FlipdishPublicModelsV1AccountsAccountDetail": FlipdishPublicModelsV1AccountsAccountDetail,
    "FlipdishPublicModelsV1AccountsAccountDetailBase": FlipdishPublicModelsV1AccountsAccountDetailBase,
    "FlipdishPublicModelsV1AccountsChangePasswordModel": FlipdishPublicModelsV1AccountsChangePasswordModel,
    "FlipdishPublicModelsV1AccountsCreateAccountModel": FlipdishPublicModelsV1AccountsCreateAccountModel,
    "FlipdishPublicModelsV1AccountsDriverLoginModel": FlipdishPublicModelsV1AccountsDriverLoginModel,
    "FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel": FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel,
    "FlipdishPublicModelsV1AccountsLocalisedTimeZone": FlipdishPublicModelsV1AccountsLocalisedTimeZone,
    "FlipdishPublicModelsV1AccountsLoginModel": FlipdishPublicModelsV1AccountsLoginModel,
    "FlipdishPublicModelsV1AccountsLoginWithPinModel": FlipdishPublicModelsV1AccountsLoginWithPinModel,
    "FlipdishPublicModelsV1AccountsPasswordResetModel": FlipdishPublicModelsV1AccountsPasswordResetModel,
    "FlipdishPublicModelsV1AccountsPredefinedAnswer": FlipdishPublicModelsV1AccountsPredefinedAnswer,
    "FlipdishPublicModelsV1AccountsRequestLoginPinModel": FlipdishPublicModelsV1AccountsRequestLoginPinModel,
    "FlipdishPublicModelsV1AccountsRequestLoginPinResposne": FlipdishPublicModelsV1AccountsRequestLoginPinResposne,
    "FlipdishPublicModelsV1AccountsRequestPasswordResetModel": FlipdishPublicModelsV1AccountsRequestPasswordResetModel,
    "FlipdishPublicModelsV1AccountsSetPasswordWithPinModel": FlipdishPublicModelsV1AccountsSetPasswordWithPinModel,
    "FlipdishPublicModelsV1AccountsSignupStep": FlipdishPublicModelsV1AccountsSignupStep,
    "FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken": FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken,
    "FlipdishPublicModelsV1AccountsUpdateDriverProfileModel": FlipdishPublicModelsV1AccountsUpdateDriverProfileModel,
    "FlipdishPublicModelsV1AllMetadataResult": FlipdishPublicModelsV1AllMetadataResult,
    "FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog": FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLog,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse": FlipdishPublicModelsV1ApiResultsRestApiDefaultResponse,
    "FlipdishPublicModelsV1ApiResultsRestApiErrorResult": FlipdishPublicModelsV1ApiResultsRestApiErrorResult,
    "FlipdishPublicModelsV1ApiResultsRestApiForbiddenResult": FlipdishPublicModelsV1ApiResultsRestApiForbiddenResult,
    "FlipdishPublicModelsV1ApiResultsRestApiIntegerResult": FlipdishPublicModelsV1ApiResultsRestApiIntegerResult,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionAvailabilityFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionAvailabilityFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull": FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull,
    "FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult": FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult,
    "FlipdishPublicModelsV1ApiResultsRestApiStringResult": FlipdishPublicModelsV1ApiResultsRestApiStringResult,
    "FlipdishPublicModelsV1ApiResultsRestApiUnauthorizedResult": FlipdishPublicModelsV1ApiResultsRestApiUnauthorizedResult,
    "FlipdishPublicModelsV1ApiResultsValidationErrorResult": FlipdishPublicModelsV1ApiResultsValidationErrorResult,
    "FlipdishPublicModelsV1ApmApmCurrencyDataPoint": FlipdishPublicModelsV1ApmApmCurrencyDataPoint,
    "FlipdishPublicModelsV1ApmApmDataPoint": FlipdishPublicModelsV1ApmApmDataPoint,
    "FlipdishPublicModelsV1ApmApmHourlyDataPoint": FlipdishPublicModelsV1ApmApmHourlyDataPoint,
    "FlipdishPublicModelsV1ApmApmStatistics": FlipdishPublicModelsV1ApmApmStatistics,
    "FlipdishPublicModelsV1ApmCurrencyData": FlipdishPublicModelsV1ApmCurrencyData,
    "FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint": FlipdishPublicModelsV1ApmStatisticsCurrencyDataPoint,
    "FlipdishPublicModelsV1AppsApp": FlipdishPublicModelsV1AppsApp,
    "FlipdishPublicModelsV1AppsAppConfigUpdateModel": FlipdishPublicModelsV1AppsAppConfigUpdateModel,
    "FlipdishPublicModelsV1AppsDnsRecordInformation": FlipdishPublicModelsV1AppsDnsRecordInformation,
    "FlipdishPublicModelsV1AppsLanguage": FlipdishPublicModelsV1AppsLanguage,
    "FlipdishPublicModelsV1AppsSupportedCountry": FlipdishPublicModelsV1AppsSupportedCountry,
    "FlipdishPublicModelsV1BankAccountAssignedBankAccount": FlipdishPublicModelsV1BankAccountAssignedBankAccount,
    "FlipdishPublicModelsV1BankAccountBankAccount": FlipdishPublicModelsV1BankAccountBankAccount,
    "FlipdishPublicModelsV1BankAccountBankAccountCreate": FlipdishPublicModelsV1BankAccountBankAccountCreate,
    "FlipdishPublicModelsV1BankAccountBankAccountDetail": FlipdishPublicModelsV1BankAccountBankAccountDetail,
    "FlipdishPublicModelsV1BankAccountBankAccountSummary": FlipdishPublicModelsV1BankAccountBankAccountSummary,
    "FlipdishPublicModelsV1BusinessHoursPeriod": FlipdishPublicModelsV1BusinessHoursPeriod,
    "FlipdishPublicModelsV1BusinessHoursPeriodBase": FlipdishPublicModelsV1BusinessHoursPeriodBase,
    "FlipdishPublicModelsV1CampaignsLoyaltyCampaign": FlipdishPublicModelsV1CampaignsLoyaltyCampaign,
    "FlipdishPublicModelsV1CampaignsRetentionCampaign": FlipdishPublicModelsV1CampaignsRetentionCampaign,
    "FlipdishPublicModelsV1Coordinates": FlipdishPublicModelsV1Coordinates,
    "FlipdishPublicModelsV1CreateMetadata": FlipdishPublicModelsV1CreateMetadata,
    "FlipdishPublicModelsV1CustomersCustomerSummary": FlipdishPublicModelsV1CustomersCustomerSummary,
    "FlipdishPublicModelsV1DeliveryLocation": FlipdishPublicModelsV1DeliveryLocation,
    "FlipdishPublicModelsV1DeliveryTrackingDriver": FlipdishPublicModelsV1DeliveryTrackingDriver,
    "FlipdishPublicModelsV1DeliveryTrackingDriverInvitation": FlipdishPublicModelsV1DeliveryTrackingDriverInvitation,
    "FlipdishPublicModelsV1DeliveryTrackingDriverStore": FlipdishPublicModelsV1DeliveryTrackingDriverStore,
    "FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber": FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber,
    "FlipdishPublicModelsV1EventsAnalyticsClientEvent": FlipdishPublicModelsV1EventsAnalyticsClientEvent,
    "FlipdishPublicModelsV1EventsAppCreatedEvent": FlipdishPublicModelsV1EventsAppCreatedEvent,
    "FlipdishPublicModelsV1EventsAppUpdatedEvent": FlipdishPublicModelsV1EventsAppUpdatedEvent,
    "FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent": FlipdishPublicModelsV1EventsBankingBankAccountCreatedEvent,
    "FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent": FlipdishPublicModelsV1EventsBankingBankAccountDeletedEvent,
    "FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent": FlipdishPublicModelsV1EventsBankingBankAccountUpdatedEvent,
    "FlipdishPublicModelsV1EventsCertificateCreatedEvent": FlipdishPublicModelsV1EventsCertificateCreatedEvent,
    "FlipdishPublicModelsV1EventsCertificateRenewedEvent": FlipdishPublicModelsV1EventsCertificateRenewedEvent,
    "FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent": FlipdishPublicModelsV1EventsCustomerConsentUpdatedEvent,
    "FlipdishPublicModelsV1EventsCustomerCreatedEvent": FlipdishPublicModelsV1EventsCustomerCreatedEvent,
    "FlipdishPublicModelsV1EventsCustomerUpdatedEvent": FlipdishPublicModelsV1EventsCustomerUpdatedEvent,
    "FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent": FlipdishPublicModelsV1EventsDeliveryZoneCreatedEvent,
    "FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent": FlipdishPublicModelsV1EventsDeliveryZoneDeletedEvent,
    "FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent": FlipdishPublicModelsV1EventsDeliveryZoneUpdatedEvent,
    "FlipdishPublicModelsV1EventsDnsVerifiedEvent": FlipdishPublicModelsV1EventsDnsVerifiedEvent,
    "FlipdishPublicModelsV1EventsEmvNotificationEvent": FlipdishPublicModelsV1EventsEmvNotificationEvent,
    "FlipdishPublicModelsV1EventsEventSearchResult": FlipdishPublicModelsV1EventsEventSearchResult,
    "FlipdishPublicModelsV1EventsHydraHydraAssignedEvent": FlipdishPublicModelsV1EventsHydraHydraAssignedEvent,
    "FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent": FlipdishPublicModelsV1EventsHydraHydraConnectionStatusChangedEvent,
    "FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent": FlipdishPublicModelsV1EventsHydraHydraRequestResetEvent,
    "FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent": FlipdishPublicModelsV1EventsHydraHydraSettingChangedEvent,
    "FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent": FlipdishPublicModelsV1EventsHydraHydraUnAssignedEvent,
    "FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent": FlipdishPublicModelsV1EventsLoyaltyCampaignCreatedEvent,
    "FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent": FlipdishPublicModelsV1EventsLoyaltyCampaignDeletedEvent,
    "FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent": FlipdishPublicModelsV1EventsLoyaltyCampaignUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuCreatedEvent": FlipdishPublicModelsV1EventsMenuCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent": FlipdishPublicModelsV1EventsMenuMenuCheckpointCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetDeletedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemDeletedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetItemUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent": FlipdishPublicModelsV1EventsMenuMenuItemOptionSetUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionDeletedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionItemCreatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionItemDeletedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionItemUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent": FlipdishPublicModelsV1EventsMenuMenuSectionUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuUpdatedEvent": FlipdishPublicModelsV1EventsMenuUpdatedEvent,
    "FlipdishPublicModelsV1EventsMenuUploadedEvent": FlipdishPublicModelsV1EventsMenuUploadedEvent,
    "FlipdishPublicModelsV1EventsOrderAcceptedEvent": FlipdishPublicModelsV1EventsOrderAcceptedEvent,
    "FlipdishPublicModelsV1EventsOrderCreatedEvent": FlipdishPublicModelsV1EventsOrderCreatedEvent,
    "FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent": FlipdishPublicModelsV1EventsOrderCustomerTrackingCreatedEvent,
    "FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent": FlipdishPublicModelsV1EventsOrderDeliveryTrackingStatusUpdatedEvent,
    "FlipdishPublicModelsV1EventsOrderDispatchedEvent": FlipdishPublicModelsV1EventsOrderDispatchedEvent,
    "FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent": FlipdishPublicModelsV1EventsOrderRatingUpdatedEvent,
    "FlipdishPublicModelsV1EventsOrderRefundedEvent": FlipdishPublicModelsV1EventsOrderRefundedEvent,
    "FlipdishPublicModelsV1EventsOrderRejectedEvent": FlipdishPublicModelsV1EventsOrderRejectedEvent,
    "FlipdishPublicModelsV1EventsOrderTipUpdatedEvent": FlipdishPublicModelsV1EventsOrderTipUpdatedEvent,
    "FlipdishPublicModelsV1EventsPhoneCallEndedEvent": FlipdishPublicModelsV1EventsPhoneCallEndedEvent,
    "FlipdishPublicModelsV1EventsPhoneCallStartedEvent": FlipdishPublicModelsV1EventsPhoneCallStartedEvent,
    "FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent": FlipdishPublicModelsV1EventsPrinterAssignedToStoreEvent,
    "FlipdishPublicModelsV1EventsPrinterTurnedOffEvent": FlipdishPublicModelsV1EventsPrinterTurnedOffEvent,
    "FlipdishPublicModelsV1EventsPrinterTurnedOnEvent": FlipdishPublicModelsV1EventsPrinterTurnedOnEvent,
    "FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent": FlipdishPublicModelsV1EventsPrinterUnassignedFromStoreEvent,
    "FlipdishPublicModelsV1EventsPushNotificationDeletedEvent": FlipdishPublicModelsV1EventsPushNotificationDeletedEvent,
    "FlipdishPublicModelsV1EventsPushNotificationScheduledEvent": FlipdishPublicModelsV1EventsPushNotificationScheduledEvent,
    "FlipdishPublicModelsV1EventsPushNotificationSentEvent": FlipdishPublicModelsV1EventsPushNotificationSentEvent,
    "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult": FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult,
    "FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent": FlipdishPublicModelsV1EventsRetentionCampaignCreatedEvent,
    "FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent": FlipdishPublicModelsV1EventsRetentionCampaignDeletedEvent,
    "FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent": FlipdishPublicModelsV1EventsRetentionCampaignUpdatedEvent,
    "FlipdishPublicModelsV1EventsSearchCriteria": FlipdishPublicModelsV1EventsSearchCriteria,
    "FlipdishPublicModelsV1EventsSmsReceivedEvent": FlipdishPublicModelsV1EventsSmsReceivedEvent,
    "FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent": FlipdishPublicModelsV1EventsStoreAddressUpdatedEvent,
    "FlipdishPublicModelsV1EventsStoreArchivedEvent": FlipdishPublicModelsV1EventsStoreArchivedEvent,
    "FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent": FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideCreatedEvent,
    "FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent": FlipdishPublicModelsV1EventsStoreBusinessHoursOverrideDeletedEvent,
    "FlipdishPublicModelsV1EventsStoreCreatedEvent": FlipdishPublicModelsV1EventsStoreCreatedEvent,
    "FlipdishPublicModelsV1EventsStoreDeletedEvent": FlipdishPublicModelsV1EventsStoreDeletedEvent,
    "FlipdishPublicModelsV1EventsStoreGroupCreatedEvent": FlipdishPublicModelsV1EventsStoreGroupCreatedEvent,
    "FlipdishPublicModelsV1EventsStoreGroupDeletedEvent": FlipdishPublicModelsV1EventsStoreGroupDeletedEvent,
    "FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent": FlipdishPublicModelsV1EventsStoreGroupUpdatedEvent,
    "FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent": FlipdishPublicModelsV1EventsStoreKioskSettingUpdatedEvent,
    "FlipdishPublicModelsV1EventsStoreLogoCreatedEvent": FlipdishPublicModelsV1EventsStoreLogoCreatedEvent,
    "FlipdishPublicModelsV1EventsStoreLogoDeletedEvent": FlipdishPublicModelsV1EventsStoreLogoDeletedEvent,
    "FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent": FlipdishPublicModelsV1EventsStoreLogoUpdatedEvent,
    "FlipdishPublicModelsV1EventsStoreMenuAssignedEvent": FlipdishPublicModelsV1EventsStoreMenuAssignedEvent,
    "FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent": FlipdishPublicModelsV1EventsStoreOpeningHoursUpdatedEvent,
    "FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent": FlipdishPublicModelsV1EventsStorePreOrderConfigUpdatedEvent,
    "FlipdishPublicModelsV1EventsStorePublishedEvent": FlipdishPublicModelsV1EventsStorePublishedEvent,
    "FlipdishPublicModelsV1EventsStoreUnarchivedEvent": FlipdishPublicModelsV1EventsStoreUnarchivedEvent,
    "FlipdishPublicModelsV1EventsStoreUnpublishedEvent": FlipdishPublicModelsV1EventsStoreUnpublishedEvent,
    "FlipdishPublicModelsV1EventsStoreUpdatedEvent": FlipdishPublicModelsV1EventsStoreUpdatedEvent,
    "FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent": FlipdishPublicModelsV1EventsTeammateTeammateDeletedEvent,
    "FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent": FlipdishPublicModelsV1EventsTeammateTeammateInviteAcceptedEvent,
    "FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent": FlipdishPublicModelsV1EventsTeammateTeammateInviteSentEvent,
    "FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent": FlipdishPublicModelsV1EventsTeammateTeammateUpdatedEvent,
    "FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent": FlipdishPublicModelsV1EventsUserAnsweredSignupQuestionsEvent,
    "FlipdishPublicModelsV1EventsUserCreatedEvent": FlipdishPublicModelsV1EventsUserCreatedEvent,
    "FlipdishPublicModelsV1EventsUserDeletedEvent": FlipdishPublicModelsV1EventsUserDeletedEvent,
    "FlipdishPublicModelsV1EventsUserLoginEvent": FlipdishPublicModelsV1EventsUserLoginEvent,
    "FlipdishPublicModelsV1EventsUserPasswordCreatedEvent": FlipdishPublicModelsV1EventsUserPasswordCreatedEvent,
    "FlipdishPublicModelsV1EventsUserUpdatedEvent": FlipdishPublicModelsV1EventsUserUpdatedEvent,
    "FlipdishPublicModelsV1EventsVoucherCreatedEvent": FlipdishPublicModelsV1EventsVoucherCreatedEvent,
    "FlipdishPublicModelsV1EventsVoucherDeletedEvent": FlipdishPublicModelsV1EventsVoucherDeletedEvent,
    "FlipdishPublicModelsV1EventsVoucherUpdatedEvent": FlipdishPublicModelsV1EventsVoucherUpdatedEvent,
    "FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent": FlipdishPublicModelsV1EventsWebhookSubscriptionCreatedEvent,
    "FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent": FlipdishPublicModelsV1EventsWebhookSubscriptionDeletedEvent,
    "FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo": FlipdishPublicModelsV1EventsWebhookSubscriptionEventInfo,
    "FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent": FlipdishPublicModelsV1EventsWebhookSubscriptionUpdatedEvent,
    "FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent": FlipdishPublicModelsV1EventsWebsiteWebsiteUpdatedEvent,
    "FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent": FlipdishPublicModelsV1EventsWebsiteWebsiteVanityUrlUpdatedEvent,
    "FlipdishPublicModelsV1FeesFeeSummary": FlipdishPublicModelsV1FeesFeeSummary,
    "FlipdishPublicModelsV1HomeHomeAction": FlipdishPublicModelsV1HomeHomeAction,
    "FlipdishPublicModelsV1HomeHomeStatistics": FlipdishPublicModelsV1HomeHomeStatistics,
    "FlipdishPublicModelsV1HydraDeviceSettings": FlipdishPublicModelsV1HydraDeviceSettings,
    "FlipdishPublicModelsV1HydraEmvTerminal": FlipdishPublicModelsV1HydraEmvTerminal,
    "FlipdishPublicModelsV1HydraEmvTerminalWithAssignments": FlipdishPublicModelsV1HydraEmvTerminalWithAssignments,
    "FlipdishPublicModelsV1HydraHydraConfig": FlipdishPublicModelsV1HydraHydraConfig,
    "FlipdishPublicModelsV1HydraHydraDeviceDetails": FlipdishPublicModelsV1HydraHydraDeviceDetails,
    "FlipdishPublicModelsV1HydraHydraRegistrationRequest": FlipdishPublicModelsV1HydraHydraRegistrationRequest,
    "FlipdishPublicModelsV1HydraHydraStatus": FlipdishPublicModelsV1HydraHydraStatus,
    "FlipdishPublicModelsV1HydraHydraStoreData": FlipdishPublicModelsV1HydraHydraStoreData,
    "FlipdishPublicModelsV1HydraPaymentTerminalDetails": FlipdishPublicModelsV1HydraPaymentTerminalDetails,
    "FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails": FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetails,
    "FlipdishPublicModelsV1LightspeedLightspeedSettings": FlipdishPublicModelsV1LightspeedLightspeedSettings,
    "FlipdishPublicModelsV1MenusCreateFullMenu": FlipdishPublicModelsV1MenusCreateFullMenu,
    "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet": FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSet,
    "FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem": FlipdishPublicModelsV1MenusCreateFullMenuItemOptionSetItem,
    "FlipdishPublicModelsV1MenusCreateFullMenuSection": FlipdishPublicModelsV1MenusCreateFullMenuSection,
    "FlipdishPublicModelsV1MenusCreateFullMenuSectionItem": FlipdishPublicModelsV1MenusCreateFullMenuSectionItem,
    "FlipdishPublicModelsV1MenusCreateMenuTaxRate": FlipdishPublicModelsV1MenusCreateMenuTaxRate,
    "FlipdishPublicModelsV1MenusMenu": FlipdishPublicModelsV1MenusMenu,
    "FlipdishPublicModelsV1MenusMenuBase": FlipdishPublicModelsV1MenusMenuBase,
    "FlipdishPublicModelsV1MenusMenuCheckpoint": FlipdishPublicModelsV1MenusMenuCheckpoint,
    "FlipdishPublicModelsV1MenusMenuItemOptionSet": FlipdishPublicModelsV1MenusMenuItemOptionSet,
    "FlipdishPublicModelsV1MenusMenuItemOptionSetBase": FlipdishPublicModelsV1MenusMenuItemOptionSetBase,
    "FlipdishPublicModelsV1MenusMenuItemOptionSetItem": FlipdishPublicModelsV1MenusMenuItemOptionSetItem,
    "FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase": FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase,
    "FlipdishPublicModelsV1MenusMenuObjectDisplayOrders": FlipdishPublicModelsV1MenusMenuObjectDisplayOrders,
    "FlipdishPublicModelsV1MenusMenuSection": FlipdishPublicModelsV1MenusMenuSection,
    "FlipdishPublicModelsV1MenusMenuSectionAvailability": FlipdishPublicModelsV1MenusMenuSectionAvailability,
    "FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase": FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase,
    "FlipdishPublicModelsV1MenusMenuSectionBase": FlipdishPublicModelsV1MenusMenuSectionBase,
    "FlipdishPublicModelsV1MenusMenuSectionItem": FlipdishPublicModelsV1MenusMenuSectionItem,
    "FlipdishPublicModelsV1MenusMenuSectionItemBase": FlipdishPublicModelsV1MenusMenuSectionItemBase,
    "FlipdishPublicModelsV1MenusMenuStoreNames": FlipdishPublicModelsV1MenusMenuStoreNames,
    "FlipdishPublicModelsV1MenusMenuSummary": FlipdishPublicModelsV1MenusMenuSummary,
    "FlipdishPublicModelsV1MenusMenuTaxDetails": FlipdishPublicModelsV1MenusMenuTaxDetails,
    "FlipdishPublicModelsV1MenusMenuTaxRate": FlipdishPublicModelsV1MenusMenuTaxRate,
    "FlipdishPublicModelsV1MenusObjectDisplayOrder": FlipdishPublicModelsV1MenusObjectDisplayOrder,
    "FlipdishPublicModelsV1Metadata": FlipdishPublicModelsV1Metadata,
    "FlipdishPublicModelsV1OAuthClientsOAuthApp": FlipdishPublicModelsV1OAuthClientsOAuthApp,
    "FlipdishPublicModelsV1OAuthClientsOAuthTokenModel": FlipdishPublicModelsV1OAuthClientsOAuthTokenModel,
    "FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri": FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUri,
    "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig": FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfig,
    "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel": FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel,
    "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod": FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityPeriod,
    "FlipdishPublicModelsV1OrdersAccept": FlipdishPublicModelsV1OrdersAccept,
    "FlipdishPublicModelsV1OrdersMaskedPhoneNumber": FlipdishPublicModelsV1OrdersMaskedPhoneNumber,
    "FlipdishPublicModelsV1OrdersOrder": FlipdishPublicModelsV1OrdersOrder,
    "FlipdishPublicModelsV1OrdersOrderItem": FlipdishPublicModelsV1OrdersOrderItem,
    "FlipdishPublicModelsV1OrdersOrderItemOption": FlipdishPublicModelsV1OrdersOrderItemOption,
    "FlipdishPublicModelsV1OrdersOrderSummary": FlipdishPublicModelsV1OrdersOrderSummary,
    "FlipdishPublicModelsV1OrdersRefund": FlipdishPublicModelsV1OrdersRefund,
    "FlipdishPublicModelsV1OrdersReject": FlipdishPublicModelsV1OrdersReject,
    "FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder": FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrder,
    "FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine": FlipdishPublicModelsV1OrdersTrackingCustomerCustomerDeliveryTrackingOrderLine,
    "FlipdishPublicModelsV1PhoneCall": FlipdishPublicModelsV1PhoneCall,
    "FlipdishPublicModelsV1Printer": FlipdishPublicModelsV1Printer,
    "FlipdishPublicModelsV1ProcessingFeeConfig": FlipdishPublicModelsV1ProcessingFeeConfig,
    "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest": FlipdishPublicModelsV1PushNotificationsPushNotificationRequest,
    "FlipdishPublicModelsV1PushNotificationsPushNotificationResponse": FlipdishPublicModelsV1PushNotificationsPushNotificationResponse,
    "FlipdishPublicModelsV1Range": FlipdishPublicModelsV1Range,
    "FlipdishPublicModelsV1SmsInfo": FlipdishPublicModelsV1SmsInfo,
    "FlipdishPublicModelsV1StoresBusinessHoursOverride": FlipdishPublicModelsV1StoresBusinessHoursOverride,
    "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase": FlipdishPublicModelsV1StoresBusinessHoursOverrideBase,
    "FlipdishPublicModelsV1StoresDeliveryZone": FlipdishPublicModelsV1StoresDeliveryZone,
    "FlipdishPublicModelsV1StoresDeliveryZoneBase": FlipdishPublicModelsV1StoresDeliveryZoneBase,
    "FlipdishPublicModelsV1StoresGroupedCoordinates": FlipdishPublicModelsV1StoresGroupedCoordinates,
    "FlipdishPublicModelsV1StoresPreOrderConfig": FlipdishPublicModelsV1StoresPreOrderConfig,
    "FlipdishPublicModelsV1StoresPreOrderTime": FlipdishPublicModelsV1StoresPreOrderTime,
    "FlipdishPublicModelsV1StoresStore": FlipdishPublicModelsV1StoresStore,
    "FlipdishPublicModelsV1StoresStoreAddress": FlipdishPublicModelsV1StoresStoreAddress,
    "FlipdishPublicModelsV1StoresStoreAddressBase": FlipdishPublicModelsV1StoresStoreAddressBase,
    "FlipdishPublicModelsV1StoresStoreBase": FlipdishPublicModelsV1StoresStoreBase,
    "FlipdishPublicModelsV1StoresStoreCloneSettings": FlipdishPublicModelsV1StoresStoreCloneSettings,
    "FlipdishPublicModelsV1StoresStoreCreateBase": FlipdishPublicModelsV1StoresStoreCreateBase,
    "FlipdishPublicModelsV1StoresStoreDataPoint": FlipdishPublicModelsV1StoresStoreDataPoint,
    "FlipdishPublicModelsV1StoresStoreEndOfDayReport": FlipdishPublicModelsV1StoresStoreEndOfDayReport,
    "FlipdishPublicModelsV1StoresStoreGroup": FlipdishPublicModelsV1StoresStoreGroup,
    "FlipdishPublicModelsV1StoresStoreGroupBase": FlipdishPublicModelsV1StoresStoreGroupBase,
    "FlipdishPublicModelsV1StoresStoreGroupExtended": FlipdishPublicModelsV1StoresStoreGroupExtended,
    "FlipdishPublicModelsV1StoresStoreHeader": FlipdishPublicModelsV1StoresStoreHeader,
    "FlipdishPublicModelsV1StoresStoreKioskSetting": FlipdishPublicModelsV1StoresStoreKioskSetting,
    "FlipdishPublicModelsV1StoresStoreNote": FlipdishPublicModelsV1StoresStoreNote,
    "FlipdishPublicModelsV1StoresStoreStatistics": FlipdishPublicModelsV1StoresStoreStatistics,
    "FlipdishPublicModelsV1StoresStoreSummary": FlipdishPublicModelsV1StoresStoreSummary,
    "FlipdishPublicModelsV1StuartJobAddress": FlipdishPublicModelsV1StuartJobAddress,
    "FlipdishPublicModelsV1StuartJobCancellation": FlipdishPublicModelsV1StuartJobCancellation,
    "FlipdishPublicModelsV1StuartJobContact": FlipdishPublicModelsV1StuartJobContact,
    "FlipdishPublicModelsV1StuartJobDelivery": FlipdishPublicModelsV1StuartJobDelivery,
    "FlipdishPublicModelsV1StuartJobDeliveryDetail": FlipdishPublicModelsV1StuartJobDeliveryDetail,
    "FlipdishPublicModelsV1StuartJobDriver": FlipdishPublicModelsV1StuartJobDriver,
    "FlipdishPublicModelsV1StuartJobEta": FlipdishPublicModelsV1StuartJobEta,
    "FlipdishPublicModelsV1StuartJobPricing": FlipdishPublicModelsV1StuartJobPricing,
    "FlipdishPublicModelsV1StuartJobProof": FlipdishPublicModelsV1StuartJobProof,
    "FlipdishPublicModelsV1StuartJobResponse": FlipdishPublicModelsV1StuartJobResponse,
    "FlipdishPublicModelsV1StuartStuartSettings": FlipdishPublicModelsV1StuartStuartSettings,
    "FlipdishPublicModelsV1TeammatesCreateTeammate": FlipdishPublicModelsV1TeammatesCreateTeammate,
    "FlipdishPublicModelsV1TeammatesRedeemInvitationResult": FlipdishPublicModelsV1TeammatesRedeemInvitationResult,
    "FlipdishPublicModelsV1TeammatesTeammate": FlipdishPublicModelsV1TeammatesTeammate,
    "FlipdishPublicModelsV1TeammatesTeammateBase": FlipdishPublicModelsV1TeammatesTeammateBase,
    "FlipdishPublicModelsV1UserEventInfo": FlipdishPublicModelsV1UserEventInfo,
    "FlipdishPublicModelsV1VouchersAddItemDetails": FlipdishPublicModelsV1VouchersAddItemDetails,
    "FlipdishPublicModelsV1VouchersCreateVoucher": FlipdishPublicModelsV1VouchersCreateVoucher,
    "FlipdishPublicModelsV1VouchersCreditNoteDetails": FlipdishPublicModelsV1VouchersCreditNoteDetails,
    "FlipdishPublicModelsV1VouchersLumpDiscountDetails": FlipdishPublicModelsV1VouchersLumpDiscountDetails,
    "FlipdishPublicModelsV1VouchersOrderVoucherSummary": FlipdishPublicModelsV1VouchersOrderVoucherSummary,
    "FlipdishPublicModelsV1VouchersPercentDiscountDetails": FlipdishPublicModelsV1VouchersPercentDiscountDetails,
    "FlipdishPublicModelsV1VouchersVoucher": FlipdishPublicModelsV1VouchersVoucher,
    "FlipdishPublicModelsV1VouchersVoucherBase": FlipdishPublicModelsV1VouchersVoucherBase,
    "FlipdishPublicModelsV1VouchersVoucherDataPoint": FlipdishPublicModelsV1VouchersVoucherDataPoint,
    "FlipdishPublicModelsV1VouchersVoucherSummary": FlipdishPublicModelsV1VouchersVoucherSummary,
    "FlipdishPublicModelsV1VouchersVoucherWithStats": FlipdishPublicModelsV1VouchersVoucherWithStats,
    "FlipdishPublicModelsV1WebhooksWebhookLog": FlipdishPublicModelsV1WebhooksWebhookLog,
    "FlipdishPublicModelsV1WebhooksWebhookSubscription": FlipdishPublicModelsV1WebhooksWebhookSubscription,
    "FlipdishPublicModelsV1WebsiteIndexPage": FlipdishPublicModelsV1WebsiteIndexPage,
    "FlipdishPublicModelsV1WebsiteIndexPageBase": FlipdishPublicModelsV1WebsiteIndexPageBase,
    "FlipdishPublicModelsV1WebsiteWebsiteImage": FlipdishPublicModelsV1WebsiteWebsiteImage,
    "FlipdishPublicModelsV1WebsiteWebsiteTestimonial": FlipdishPublicModelsV1WebsiteWebsiteTestimonial,
    "FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase": FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Answer a signup question
     * @param signupStepAction Signup step action
     * @param answerId Identifier of the answer
     * @param {*} [options] Override http request options.
     */
    public answerSignUpQuestion (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', answerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerId, "number")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePassword (changePasswordModel: FlipdishPublicModelsV1AccountsChangePasswordModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "FlipdishPublicModelsV1AccountsChangePasswordModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePasswordWithPin (changePasswordModel: FlipdishPublicModelsV1AccountsSetPasswordWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "FlipdishPublicModelsV1AccountsSetPasswordWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create account with email address and store name
     * @param createAccountModel Create account model
     * @param {*} [options] Override http request options.
     */
    public createAccount (createAccountModel: FlipdishPublicModelsV1AccountsCreateAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAccountModel, "FlipdishPublicModelsV1AccountsCreateAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current account detail
     * @param {*} [options] Override http request options.
     */
    public getAccountDetails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AccountsAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get timezones localised to users language
     * @param {*} [options] Override http request options.
     */
    public getLocalisedTimeZones (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AccountsLocalisedTimeZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public login (loginModel: FlipdishPublicModelsV1AccountsLoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "FlipdishPublicModelsV1AccountsLoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public loginWithPin (loginModel: FlipdishPublicModelsV1AccountsLoginWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "FlipdishPublicModelsV1AccountsLoginWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log out. It removes Flipdish authorization Cookie.
     * @param {*} [options] Override http request options.
     */
    public logout (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset password with token.
     * @param passwordResetModel Password reset model
     * @param {*} [options] Override http request options.
     */
    public passwordResetWithToken (passwordResetModel: FlipdishPublicModelsV1AccountsPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordResetModel, "FlipdishPublicModelsV1AccountsPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request login PIN. The server sends the PIN to the email address.
     * @param requestLoginPinRequest Request login PIN request
     * @param {*} [options] Override http request options.
     */
    public requestLoginPin (requestLoginPinRequest: FlipdishPublicModelsV1AccountsRequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1AccountsRequestLoginPinResposne;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestLoginPinRequest, "FlipdishPublicModelsV1AccountsRequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1AccountsRequestLoginPinResposne;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1AccountsRequestLoginPinResposne");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request password reset. Flipdish system will send a token via email.
     * @param requestPasswordResetModel Request password reset model
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (requestPasswordResetModel: FlipdishPublicModelsV1AccountsRequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetModel, "FlipdishPublicModelsV1AccountsRequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Skip a signup question
     * @param signupStepAction Signup step action
     * @param {*} [options] Override http request options.
     */
    public skipSignupStep (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update account with name and language
     * @param updateAccountModel Update account model
     * @param {*} [options] Override http request options.
     */
    public updateAccount (updateAccountModel: FlipdishPublicModelsV1AccountsAccountDetailBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAccountModel, "FlipdishPublicModelsV1AccountsAccountDetailBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        (this.authentications as any)[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Get Basic Statistics
     * @param appId App Name
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ApmApmStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calendar statistics
     * @param appId App Name
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmHourlyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calls Statistics
     * @param appId App Name
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCallsStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Order Statistics (Value of Orders)
     * @param appId App Name
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getOrderStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApmApmCurrencyDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get paginated APM call list
     * @param appId App Name
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PhoneCallFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        (this.authentications as any)[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get the application configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A domain might be ready but still need 10 minutes to work properly because of HAProxy.
     * @summary Get the application hostname DNS delegation states for A and CNAME records.
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getAppHostnameStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostnamestatus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppHostnameStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsDnsRecordInformationFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Apps
     * @param nameFilter 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getApps (nameFilter?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (nameFilter !== undefined) {
            localVarQueryParameters['nameFilter'] = ObjectSerializer.serialize(nameFilter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get panacea vanity url
     * @param appId Application identifier.
     * @param {*} [options] Override http request options.
     */
    public getPanaceaVanityUrl (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPanaceaVanityUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the application configuration
     * @param {*} [options] Override http request options.
     */
    public getSupportedCountries (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/supportedcountries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AppsSupportedCountryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Is panacea vanity url available
     * @param vanityUrl Vanity url to check
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public isPanaceaVanityUrlAvailable (vanityUrl: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url/available'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application configuration
     * @param appId Application identifier
     * @param appConfigUpdate Changes to the configuration
     * @param {*} [options] Override http request options.
     */
    public setAppConfig (appId: string, appConfigUpdate: FlipdishPublicModelsV1AppsAppConfigUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppConfig.');
        }

        // verify required parameter 'appConfigUpdate' is not null or undefined
        if (appConfigUpdate === null || appConfigUpdate === undefined) {
            throw new Error('Required parameter appConfigUpdate was null or undefined when calling setAppConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appConfigUpdate, "FlipdishPublicModelsV1AppsAppConfigUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If no subdomain is specified in {hostname} 'www' will be appended.
     * @summary Set the application hostname.
     * @param appId Application identifier.
     * @param hostname The new Hostname.
     * @param isEmbed Will the website be embedded
     * @param {*} [options] Override http request options.
     */
    public setAppHostname (appId: string, hostname: string, isEmbed?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostname'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppHostname.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling setAppHostname.');
        }

        if (hostname !== undefined) {
            localVarQueryParameters['hostname'] = ObjectSerializer.serialize(hostname, "string");
        }

        if (isEmbed !== undefined) {
            localVarQueryParameters['isEmbed'] = ObjectSerializer.serialize(isEmbed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application languages
     * @param appId Application identifier
     * @param languages New list of languages
     * @param {*} [options] Override http request options.
     */
    public setAppLanguages (appId: string, languages: Array<FlipdishPublicModelsV1AppsLanguage>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config/languages'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppLanguages.');
        }

        // verify required parameter 'languages' is not null or undefined
        if (languages === null || languages === undefined) {
            throw new Error('Required parameter languages was null or undefined when calling setAppLanguages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(languages, "Array<FlipdishPublicModelsV1AppsLanguage>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1AppsAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Minimum length of 3 characters
     * @summary Set panacea vanity url
     * @param appId Application identifier.
     * @param vanityUrl Vanity url
     * @param {*} [options] Override http request options.
     */
    public setPanaceaVanityUrl (appId: string, vanityUrl: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setPanaceaVanityUrl.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling setPanaceaVanityUrl.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the application logo \\ icon
     * @param appId Application identifier
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppLogo (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/logo'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get authorization tokens
     * @param oauthAppId Client identifier
     * @param appId 
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OAuthClientsOAuthTokenModelFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke token
     * @param key Token identifier key
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public revokeToken (key: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Attach Bank Account to Store
     * @param appId App Name
     * @param accountId Id of account to be updated
     * @param storeId Store to be attached to Bank account
     * @param {*} [options] Override http request options.
     */
    public attachBankAccountToStore (appId: string, accountId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{accountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Create a new Bank Account and attach to this App
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccount (appId: string, account: FlipdishPublicModelsV1BankAccountBankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "FlipdishPublicModelsV1BankAccountBankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Delete BankAccount
     * @param appId App Name
     * @param id Id of account to be marked as deleted
     * @param {*} [options] Override http request options.
     */
    public deleteBankAccount (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get BankAccount Detail by Id
     * @param id Id of account
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccountById (id: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBankAccountById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountBankAccountDetailFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get List of BankAccounts for WL
     * @param appId App Name
     * @param {*} [options] Override http request options.
     */
    public getBankAccounts (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BankAccountBankAccountSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update BankAccount
     * @param appId App Name
     * @param id Id of account to be updated
     * @param account Details to update account with
     * @param {*} [options] Override http request options.
     */
    public updateBankAccount (appId: string, id: number, account: FlipdishPublicModelsV1BankAccountBankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "FlipdishPublicModelsV1BankAccountBankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update State of Bank Account
     * @param appId App Name
     * @param accountId Id of account to be updated
     * @param state New state
     * @param reason Reason for state change, Manadatory for rejections
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountState (appId: string, accountId: number, state: string, reason: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{accountId}/state/{state}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling updateBankAccountState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reason, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryTrackingApiApiKeys {
}

export class DeliveryTrackingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryTrackingApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryTrackingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Assign driver to order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrder (appId: string, orderId: number, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders/{orderId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling assignDriverToOrder.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign driver to multiple orders
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param orderIdAndSequenceNumbers Array of object containing OrderId and Sequence
     * @param {*} [options] Override http request options.
     */
    public assignDriverToOrders (appId: string, driverId: number, orderIdAndSequenceNumbers: Array<FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling assignDriverToOrders.');
        }

        // verify required parameter 'orderIdAndSequenceNumbers' is not null or undefined
        if (orderIdAndSequenceNumbers === null || orderIdAndSequenceNumbers === undefined) {
            throw new Error('Required parameter orderIdAndSequenceNumbers was null or undefined when calling assignDriverToOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderIdAndSequenceNumbers, "Array<FlipdishPublicModelsV1DeliveryTrackingOrderIdAndSequenceNumber>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Get drivers by App
     * @param appId Application identifier
     * @param name Driver&#39;s username
     * @param phoneNumber Driver&#39;s phone number
     * @param storeId Store Id
     * @param presence Offline/Online
     * @param {*} [options] Override http request options.
     */
    public getDrivers (appId: string, name?: string, phoneNumber?: string, storeId?: number, presence?: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getDrivers.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (presence !== undefined) {
            localVarQueryParameters['presence'] = ObjectSerializer.serialize(presence, "'Offline' | 'Online'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Invite driver
     * @param appId Application identifier
     * @param driverInvitation Driver invitation model
     * @param {*} [options] Override http request options.
     */
    public inviteDriverToApp (appId: string, driverInvitation: FlipdishPublicModelsV1DeliveryTrackingDriverInvitation, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling inviteDriverToApp.');
        }

        // verify required parameter 'driverInvitation' is not null or undefined
        if (driverInvitation === null || driverInvitation === undefined) {
            throw new Error('Required parameter driverInvitation was null or undefined when calling inviteDriverToApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverInvitation, "FlipdishPublicModelsV1DeliveryTrackingDriverInvitation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from app
     * @param appId Application identifier
     * @param driverId Driver Id
     * @param {*} [options] Override http request options.
     */
    public removeDriverFromApp (appId: string, driverId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/drivers/{driverId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'driverId' + '}', encodeURIComponent(String(driverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeDriverFromApp.');
        }

        // verify required parameter 'driverId' is not null or undefined
        if (driverId === null || driverId === undefined) {
            throw new Error('Required parameter driverId was null or undefined when calling removeDriverFromApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Unassign driver from order
     * @param appId Application identifier
     * @param orderId Order Id
     * @param {*} [options] Override http request options.
     */
    public unassignDriverFromOrder (appId: string, orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/{orderId}/driver'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignDriverFromOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling unassignDriverFromOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a delivery zone to the store id
     * @param storeId Store Id to which the delivery zone will be added
     * @param deliveryZoneBase Optional delivery zone, if not supplied will create a default zone
     * @param {*} [options] Override http request options.
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: FlipdishPublicModelsV1StoresDeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZoneBase, "FlipdishPublicModelsV1StoresDeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the delivery zones associated with a store
     * @param storeId Store Id to which the delivery zones are associated
     * @param {*} [options] Override http request options.
     */
    public getDeliveryZones (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be removed
     * @param {*} [options] Override http request options.
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be updated
     * @param deliveryZone Delta of delivery zone parameters that need to be changed
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: FlipdishPublicModelsV1StoresDeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZone, "FlipdishPublicModelsV1StoresDeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresDeliveryZoneFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DriversApiApiKeys {
}

export class DriversApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DriversApiApiKeys, value: string) {
        (this.authentications as any)[DriversApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add driver token
     * @param updateDriverToken 
     * @param {*} [options] Override http request options.
     */
    public addDriverNotificationToken (updateDriverToken: FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverToken' is not null or undefined
        if (updateDriverToken === null || updateDriverToken === undefined) {
            throw new Error('Required parameter updateDriverToken was null or undefined when calling addDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverToken, "FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver profile image
     * @param {*} [options] Override http request options.
     */
    public deleteDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Login with phone number and pin
     * @param driverLoginModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverLogin (driverLoginModel: FlipdishPublicModelsV1AccountsDriverLoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverLoginModel' is not null or undefined
        if (driverLoginModel === null || driverLoginModel === undefined) {
            throw new Error('Required parameter driverLoginModel was null or undefined when calling driverLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverLoginModel, "FlipdishPublicModelsV1AccountsDriverLoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Request an SMS to be sent to the driver with their login code
     * @param driverRequestLoginPinModel Driver request login code model
     * @param {*} [options] Override http request options.
     */
    public driverRequestLoginCodeSms (driverRequestLoginPinModel: FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverRequestLoginPinModel' is not null or undefined
        if (driverRequestLoginPinModel === null || driverRequestLoginPinModel === undefined) {
            throw new Error('Required parameter driverRequestLoginPinModel was null or undefined when calling driverRequestLoginCodeSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverRequestLoginPinModel, "FlipdishPublicModelsV1AccountsDriverRequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get driver profile
     * @param {*} [options] Override http request options.
     */
    public getDriverProfile (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1DeliveryTrackingDriverFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores for driver
     * @param {*} [options] Override http request options.
     */
    public getStoresForDriver (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/assignedstores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1DeliveryTrackingDriverStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete driver token
     * @param removeDriverToken 
     * @param {*} [options] Override http request options.
     */
    public removeDriverNotificationToken (removeDriverToken: FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'removeDriverToken' is not null or undefined
        if (removeDriverToken === null || removeDriverToken === undefined) {
            throw new Error('Required parameter removeDriverToken was null or undefined when calling removeDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeDriverToken, "FlipdishPublicModelsV1AccountsUpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param presence 
     * @param {*} [options] Override http request options.
     */
    public setDriverPresenceForStore (storeId: number, presence: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/stores/{storeId}/presence/{presence}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'presence' + '}', encodeURIComponent(String(presence)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setDriverPresenceForStore.');
        }

        // verify required parameter 'presence' is not null or undefined
        if (presence === null || presence === undefined) {
            throw new Error('Required parameter presence was null or undefined when calling setDriverPresenceForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set driver profile image and returns it's url
     * @param {*} [options] Override http request options.
     */
    public setDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ...
     * @summary Change delivery tracking status and return the updated status.
     * @param orderId Order identifier
     * @param deliveryTrackingStatus 
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryTrackingStatus (orderId: number, deliveryTrackingStatus: 'Unassigned' | 'Unaccepted' | 'Accepted' | 'Carrying' | 'OnTheWay' | 'ArrivedAtLocation' | 'Delivered' | 'CannotDeliver', options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/tracking/{deliveryTrackingStatus}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'deliveryTrackingStatus' + '}', encodeURIComponent(String(deliveryTrackingStatus)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        // verify required parameter 'deliveryTrackingStatus' is not null or undefined
        if (deliveryTrackingStatus === null || deliveryTrackingStatus === undefined) {
            throw new Error('Required parameter deliveryTrackingStatus was null or undefined when calling updateDeliveryTrackingStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update driver profile
     * @param updateDriverProfile Update the driver profile (i.e Name)
     * @param {*} [options] Override http request options.
     */
    public updateDriverProfile (updateDriverProfile: FlipdishPublicModelsV1AccountsUpdateDriverProfileModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverProfile' is not null or undefined
        if (updateDriverProfile === null || updateDriverProfile === undefined) {
            throw new Error('Required parameter updateDriverProfile was null or undefined when calling updateDriverProfile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverProfile, "FlipdishPublicModelsV1AccountsUpdateDriverProfileModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer events  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events  For technical reasons, the number of records returned is limited to 100.
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getEvents (whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event by Id  For technical reasons, the number of records returned is limited to 100.
     * @param eventId Event identifier (Guid)
     * @param {*} [options] Override http request options.
     */
    public getEventsById (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsEventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsEventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsEventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu events  For technical reasons, the number of records returned is limited to 100.
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events  For technical reasons, the number of records returned is limited to 100.
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId2 !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId2, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events by customer  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store events  For technical reasons, the number of records returned is limited to 100.
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user events  For technical reasons, the number of records returned is limited to 100.
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId2?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId2 !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId2, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get WhiteLabel events  For technical reasons, the number of records returned is limited to 100.
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1EventsRestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        (this.authentications as any)[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headHostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headPing (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public hostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        (this.authentications as any)[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param appId App Name Id
     * @param homeActionId Id of the action
     * @param isDismissed 
     * @param {*} [options] Override http request options.
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'homeActionId' + '}', encodeURIComponent(String(homeActionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            localVarQueryParameters['isDismissed'] = ObjectSerializer.serialize(isDismissed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param {*} [options] Override http request options.
     */
    public dismissOldPortalAction (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/home/dismissoldportalaction';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Actions
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeActions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HomeHomeActionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Statistics
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeStatistics (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HomeHomeStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get API interaction logs
     * @param start Start date time
     * @param end End date time
     * @param appId 
     * @param filterByUserId User id (optional)
     * @param guid Id of the log
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, guid?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1ApiRequestResponseLogHttpRequestAndResponseLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        (this.authentications as any)[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Assign an EMV terminal to a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param emvTerminalId 
     * @param {*} [options] Override http request options.
     */
    public assignEmv (appId: string, hydraConfigId: number, emvTerminalId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/assign/{hydraConfigId}/{emvTerminalId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)))
            .replace('{' + 'emvTerminalId' + '}', encodeURIComponent(String(emvTerminalId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'emvTerminalId' is not null or undefined
        if (emvTerminalId === null || emvTerminalId === undefined) {
            throw new Error('Required parameter emvTerminalId was null or undefined when calling assignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelEmvPayment (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/cancelemvpayment/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelEmvPayment.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelEmvPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceType 
     * @param pageIndex 
     * @param pageSize 
     * @param storeId 
     * @param deviceName 
     * @param deviceSerial 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevices (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', pageIndex?: number, pageSize?: number, storeId?: number, deviceName?: string, deviceSerial?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/list'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevices.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevices.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (deviceName !== undefined) {
            localVarQueryParameters['deviceName'] = ObjectSerializer.serialize(deviceName, "string");
        }

        if (deviceSerial !== undefined) {
            localVarQueryParameters['deviceSerial'] = ObjectSerializer.serialize(deviceSerial, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1HydraHydraDeviceDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEMVTerminalDetails (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEMVTerminalDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEmvOrderState (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvorderstate/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmvOrderState.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEmvOrderState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraPaymentTerminalTransactionDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRegistration (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param {*} [options] Override http request options.
     */
    public getSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param emv 
     * @param {*} [options] Override http request options.
     */
    public hydraCreateEmv (appId: string, emv: FlipdishPublicModelsV1HydraEmvTerminal, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraCreateEmv.');
        }

        // verify required parameter 'emv' is not null or undefined
        if (emv === null || emv === undefined) {
            throw new Error('Required parameter emv was null or undefined when calling hydraCreateEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emv, "FlipdishPublicModelsV1HydraEmvTerminal")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public hydraDeleteEmv (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDeleteEmv.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hydraDeleteEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List EMV terminals belonging to the given AppNameId
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public hydraGetEmvsForAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraGetEmvsForAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1HydraEmvTerminalWithAssignmentsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param deviceId 
     * @param hydraUserType 
     * @param serialNumber 
     * @param {*} [options] Override http request options.
     */
    public loginWithDeviceId (deviceId: string, hydraUserType?: 'Kiosk' | 'Terminal' | 'LegacyPrinter', serialNumber?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling loginWithDeviceId.');
        }

        if (hydraUserType !== undefined) {
            localVarQueryParameters['hydraUserType'] = ObjectSerializer.serialize(hydraUserType, "'Kiosk' | 'Terminal' | 'LegacyPrinter'");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serialNumber'] = ObjectSerializer.serialize(serialNumber, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param hydraRegistration 
     * @param {*} [options] Override http request options.
     */
    public register (appId: string, hydraRegistration: FlipdishPublicModelsV1HydraHydraRegistrationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling register.');
        }

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hydraRegistration, "FlipdishPublicModelsV1HydraHydraRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1HydraHydraStatusFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unAssign (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unAssign.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unAssign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unassign the currently assigned EMV terminal from a kiosk
     * @param appId 
     * @param hydraConfigId 
     * @param {*} [options] Override http request options.
     */
    public unassignEmv (appId: string, hydraConfigId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/unassign/{hydraConfigId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling unassignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        (this.authentications as any)[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGenerateMenu (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGetStoreSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param lightspeedSettings 
     * @param {*} [options] Override http request options.
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: FlipdishPublicModelsV1LightspeedLightspeedSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lightspeedSettings, "FlipdishPublicModelsV1LightspeedLightspeedSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1LightspeedLightspeedSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     * @param {*} [options] Override http request options.
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private API] Set Tax Rate on OptionSetItem
     * @param menuId Menu identifier
     * @param menuSectionId 
     * @param menuSectionItemId 
     * @param optionSetId 
     * @param menuItemOptionSetItemId Option set item identifier
     * @param taxRateId Tax Rate to use
     * @param {*} [options] Override http request options.
     */
    public setOptionSetItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setOptionSetItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "FlipdishPublicModelsV1MenusMenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     * @param {*} [options] Override http request options.
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: FlipdishPublicModelsV1MenusMenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "FlipdishPublicModelsV1MenusMenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuItemOptionSetFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: FlipdishPublicModelsV1MenusMenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "FlipdishPublicModelsV1MenusMenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: FlipdishPublicModelsV1MenusMenuSectionItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "FlipdishPublicModelsV1MenusMenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItems (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionItemFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param destinationDisplayOrder New Display Order of item
     * @param {*} [options] Override http request options.
     */
    public moveMenuItem (menuId: number, menuSectionId: number, menuSectionItemId: number, destinationDisplayOrder: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/setorder/{destinationDisplayOrder}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'destinationDisplayOrder' + '}', encodeURIComponent(String(destinationDisplayOrder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'destinationDisplayOrder' is not null or undefined
        if (destinationDisplayOrder === null || destinationDisplayOrder === undefined) {
            throw new Error('Required parameter destinationDisplayOrder was null or undefined when calling moveMenuItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param taxRateId tax rate to be set against item
     * @param {*} [options] Override http request options.
     */
    public setSectionItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setSectionItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: FlipdishPublicModelsV1MenusMenuSectionItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "FlipdishPublicModelsV1MenusMenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set/update menu section availability hours.
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek Day of the  week
     * @param businessHoursPeriod Menu section active hours, note: DayOfWeek property will be overriden by the path parameter.
     * @param {*} [options] Override http request options.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday', businessHoursPeriod: FlipdishPublicModelsV1BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'dayOfWeek' + '}', encodeURIComponent(String(dayOfWeek)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "FlipdishPublicModelsV1BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     * @param {*} [options] Override http request options.
     */
    public createMenuSection (menuId: number, menuSection: FlipdishPublicModelsV1MenusMenuSectionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "FlipdishPublicModelsV1MenusMenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu availability type
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability DisplayAlways, DisplayBasedOnTimes, DisplayAlwaysStartCollapsed, DisplayAlwaysStartCollapsedBasedOnTimes
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionAvailability, "FlipdishPublicModelsV1MenusMenuSectionAvailabilityBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSectionById (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSections (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSectionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Re-arrange Items within a Section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param displayOrders Item Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menuSectionsSetItemDisplayOrders (menuId: number, menuSectionId: number, displayOrders: FlipdishPublicModelsV1MenusMenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitemdisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "FlipdishPublicModelsV1MenusMenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: FlipdishPublicModelsV1MenusMenuSectionBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "FlipdishPublicModelsV1MenusMenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API]Clone a menu, (without attaching stores)
     * @param menuId Menu identifier
     * @param newName Name of the new Menu
     * @param {*} [options] Override http request options.
     */
    public createDraftMenuFromExistingMenu (menuId: number, newName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone/{newName}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'newName' + '}', encodeURIComponent(String(newName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        // verify required parameter 'newName' is not null or undefined
        if (newName === null || newName === undefined) {
            throw new Error('Required parameter newName was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu. If request body is empty, the system will create a menu with default items.
     * @param appId App identifier
     * @param menu Menu
     * @param {*} [options] Override http request options.
     */
    public createNewMenuForApp (appId: string, menu: FlipdishPublicModelsV1MenusCreateFullMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "FlipdishPublicModelsV1MenusCreateFullMenu")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Mark a Menu as Deleted
     * @param menuId Menu Identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuImage (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all menu metadata by menu ID and store ID
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getAllMenuMetadataByMenuIdAndStoreId (menuId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1AllMetadataResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuById (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MenusMenuFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1MetadataFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus store names
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuStoreNames (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuStoreNamesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus tax details
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuTaxDetails (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuTaxDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuTaxDetailsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus by appId
     * @param appId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public getMenusByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get a Menus Checkpoints
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenusCheckpoints (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1MenusMenuCheckpointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Remove a Menus Tax Rate, can only remove a tax rate that does not have items/optionSetItems attached
     * @param menuId Menu identifier
     * @param taxId Id of Menu Tax to be removed
     * @param {*} [options] Override http request options.
     */
    public menusDeleteTaxRate (menuId: number, taxId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/{taxId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusDeleteTaxRate.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling menusDeleteTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set if tax shows for a Menu
     * @param menuId Menu identifier
     * @param show Boolean show or dont show tax (Exclusive tax type can only ever be TRUE)
     * @param {*} [options] Override http request options.
     */
    public menusSetDisplayOnMenuTax (menuId: number, show: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/show/{show}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'show' + '}', encodeURIComponent(String(show)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        // verify required parameter 'show' is not null or undefined
        if (show === null || show === undefined) {
            throw new Error('Required parameter show was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Re-arrange Sections within a Menu
     * @param menuId Menu identifier
     * @param displayOrders Section Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menusSetItemDisplayOrders (menuId: number, displayOrders: FlipdishPublicModelsV1MenusMenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sectiondisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menusSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "FlipdishPublicModelsV1MenusMenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set the type of Tax on a Menu
     * @param menuId Menu identifier
     * @param type Type of Tax
     * @param {*} [options] Override http request options.
     */
    public menusUpdateTaxType (menuId: number, type: 'IncludedInBasePrice' | 'ExcludedFromBasePrice', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/type/{type}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpdateTaxType.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling menusUpdateTaxType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Add/Update a Tax Rate
     * @param menuId Menu identifier
     * @param taxRate Tax Rate to Add/Update
     * @param {*} [options] Override http request options.
     */
    public menusUpsertTaxRate (menuId: number, taxRate: FlipdishPublicModelsV1MenusMenuTaxRate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1MenusMenuTaxRate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/taxrate'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpsertTaxRate.');
        }

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling menusUpsertTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxRate, "FlipdishPublicModelsV1MenusMenuTaxRate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1MenusMenuTaxRate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1MenusMenuTaxRate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Restore a Menu to a checkpoint
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     * @param {*} [options] Override http request options.
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'checkpointId' + '}', encodeURIComponent(String(checkpointId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: FlipdishPublicModelsV1Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "FlipdishPublicModelsV1Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: FlipdishPublicModelsV1Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "FlipdishPublicModelsV1Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Lock/Unlock a Menu for Editing
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     * @param {*} [options] Override http request options.
     */
    public setMenuLock (menuId: number, locked: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locked, "boolean")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set Menus Name
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     * @param {*} [options] Override http request options.
     */
    public setMenuName (menuId: number, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenu (menuId: number, menu: FlipdishPublicModelsV1MenusMenuBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "FlipdishPublicModelsV1MenusMenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuImage (menuId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu from xlsx file.
     * @param appId App identifier
     * @param Menu Uploaded xlsx menu
     * @param {*} [options] Override http request options.
     */
    public uploadNewMenuForApp (appId: string, Menu: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/xlsx'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadNewMenuForApp.');
        }

        // verify required parameter 'Menu' is not null or undefined
        if (Menu === null || Menu === undefined) {
            throw new Error('Required parameter Menu was null or undefined when calling uploadNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Menu !== undefined) {
            localVarFormParams['Menu'] = Menu;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uri Redirect uri
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OAuth App
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createOAuthApp (oAuthApp: FlipdishPublicModelsV1OAuthClientsOAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "FlipdishPublicModelsV1OAuthClientsOAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteOAuthApp (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all OAuth Apps
     * @param appId 
     * @param oauthAppName 
     * @param {*} [options] Override http request options.
     */
    public getOAuthApps (appId: string, oauthAppName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            localVarQueryParameters['oauthAppName'] = ObjectSerializer.serialize(oauthAppName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App by identifier
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OAuthClientsOAuthAppFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App secret key
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth access token for App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOauthAccessToken (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App redirect uris
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRedirectUris (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1OAuthClientsOauthClientRedirectUriFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public oAuthClientsGetApplications (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uriId Redirect uri identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OAuth App
     * @param oauthAppId OAuth App identifier
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateOAuthApp (oauthAppId: string, oAuthApp: FlipdishPublicModelsV1OAuthClientsOAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "FlipdishPublicModelsV1OAuthClientsOAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * To accept an order, you create an `accept` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Accept order
     * @param id Order identifier
     * @param acceptObject Order accept parameters (eg: EstimatedMinutesForDelivery)
     * @param {*} [options] Override http request options.
     */
    public acceptOrder (id: number, acceptObject: FlipdishPublicModelsV1OrdersAccept, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "FlipdishPublicModelsV1OrdersAccept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To dispatch an order send a POST request with `Id` path parameter which identifies the order.
     * @summary Dispatch order
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public dispatchOrder (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order by ID
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderById (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orders by filter
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param from Order has been placed after this parameter value
     * @param to Order has been placed before this parameter value
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, from?: Date, to?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get summary of orders by filter
     * @param appId App Name Id
     * @param searchQuery Query string
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param orderByRequestedForTime 
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, orderByRequestedForTime?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderByRequestedForTime !== undefined) {
            localVarQueryParameters['orderByRequestedForTime'] = ObjectSerializer.serialize(orderByRequestedForTime, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1OrdersOrderSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To refund an order, you create a `refund` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Refund order
     * @param id Order identifier
     * @param refundObject 
     * @param {*} [options] Override http request options.
     */
    public refundOrder (id: number, refundObject: FlipdishPublicModelsV1OrdersRefund, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "FlipdishPublicModelsV1OrdersRefund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To reject an order, you create a `reject` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Reject order
     * @param id Order identifier
     * @param rejectObject 
     * @param {*} [options] Override http request options.
     */
    public rejectOrder (id: number, rejectObject: FlipdishPublicModelsV1OrdersReject, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "FlipdishPublicModelsV1OrdersReject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        (this.authentications as any)[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get processing fee configs by store identifiers
     * @param storeIds Store identifiers
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PushNotificationsApiApiKeys {
}

export class PushNotificationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PushNotificationsApiApiKeys, value: string) {
        (this.authentications as any)[PushNotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param scheduledPushNotificationId ID of Scheduled push notifiaction to delete
     * @param {*} [options] Override http request options.
     */
    public deletePushNotification (appId: string, scheduledPushNotificationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling deletePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPushNotifications (appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPushNotifications.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Push notification to cutomers
     * @param appId Application Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public schedulePushNotification (appId: string, notification: FlipdishPublicModelsV1PushNotificationsPushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling schedulePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling schedulePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE] Update the push notification
     * @param appId Application Id
     * @param scheduledPushNotificationId Notification Id
     * @param notification Notification to send
     * @param {*} [options] Override http request options.
     */
    public updatePushNotification (appId: string, scheduledPushNotificationId: number, notification: FlipdishPublicModelsV1PushNotificationsPushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updatePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "FlipdishPublicModelsV1PushNotificationsPushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1PushNotificationsPushNotificationResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        (this.authentications as any)[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a Store Group  It will be attached to an existing App
     * @param appNameId App Name Id
     * @param storeGroup Store group definition
     * @param {*} [options] Override http request options.
     */
    public createStoreGroup (appNameId: string, storeGroup: FlipdishPublicModelsV1StoresStoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "FlipdishPublicModelsV1StoresStoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a Store Groups
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a paginated list of Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Returns a paginated list of Extended Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param groupingRadius 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (groupingRadius !== undefined) {
            localVarQueryParameters['groupingRadius'] = ObjectSerializer.serialize(groupingRadius, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreGroupExtendedFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a Store Group  Can only remove a store group if there is no stores attached to the group
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public removeStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Store Group
     * @param storeGroupId Store Group Id
     * @param storeGroup Store Group Delta
     * @param {*} [options] Override http request options.
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: FlipdishPublicModelsV1StoresStoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "FlipdishPublicModelsV1StoresStoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreGroupBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreOrderCapacityApiApiKeys {
}

export class StoreOrderCapacityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreOrderCapacityApiApiKeys, value: string) {
        (this.authentications as any)[StoreOrderCapacityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get store's order capacity configuration
     * @param appId App Name Id
     * @param storeId Store Id
     * @param deliveryType Delivery / Pickup
     * @param {*} [options] Override http request options.
     */
    public getStoreOrderCapacity (appId: string, storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}/{deliveryType}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getStoreOrderCapacity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create or update a store's order capacity configuration
     * @param storeId Store identifier
     * @param deliveryType Delivery / Pickup
     * @param newOrderCapacityConfig new order capacity configuration
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateStoreOrderCapacityConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', newOrderCapacityConfig: FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'newOrderCapacityConfig' is not null or undefined
        if (newOrderCapacityConfig === null || newOrderCapacityConfig === undefined) {
            throw new Error('Required parameter newOrderCapacityConfig was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        if (deliveryType !== undefined) {
            localVarQueryParameters['deliveryType'] = ObjectSerializer.serialize(deliveryType, "'Delivery' | 'Pickup'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newOrderCapacityConfig, "FlipdishPublicModelsV1OrderCapacityStoreOrderCapacityConfigEditModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Archive store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public archiveStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/archive'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling archiveStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign Menu to Store
     * @param storeId Store identifier
     * @param menuId Id of Menu to assign to store
     * @param {*} [options] Override http request options.
     */
    public assignMenu (storeId: number, menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/menu/{menuId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling assignMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone store with store clone settings
     * @param storeId Store identifier
     * @param settings Settings for cloning the store
     * @param {*} [options] Override http request options.
     */
    public cloneStore (storeId: number, settings: FlipdishPublicModelsV1StoresStoreCloneSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "FlipdishPublicModelsV1StoresStoreCloneSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create Business Hours Override for a store
     * @param storeId Store identifier
     * @param businessHoursOverride Business Hours Override
     * @param {*} [options] Override http request options.
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: FlipdishPublicModelsV1StoresBusinessHoursOverrideBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursOverride, "FlipdishPublicModelsV1StoresBusinessHoursOverrideBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create store with Store Group identifier
     * @param storeGroupId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public createStore (storeGroupId: number, store: FlipdishPublicModelsV1StoresStoreCreateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "FlipdishPublicModelsV1StoresStoreCreateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Business Hours Override for a store
     * @param storeId 
     * @param businessHoursOverrideId 
     * @param {*} [options] Override http request options.
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'businessHoursOverrideId' + '}', encodeURIComponent(String(businessHoursOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Stores Bank Account Id
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getBankAccountForStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BankAccountAssignedBankAccountFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param {*} [options] Override http request options.
     */
    public getBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get business hours overrides by store identifier
     * @param storeId Store identifier
     * @param after Return results that ended after this datetime. Default value is the current datetime.
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresBusinessHoursOverrideFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store end of day report
     * @param storeId Store identifier
     * @param date Store identifier
     * @param {*} [options] Override http request options.
     */
    public getEndOfDayReport (storeId: number, date?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/endofdayreport'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getEndOfDayReport.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreEndOfDayReportFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param {*} [options] Override http request options.
     */
    public getPreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresPreOrderConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the Preview times of the pre-order configuration
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig_leadTimeMinutes Lead Time in Minutes
     * @param preOrderConfig_intervalMinutes Interval in minutes
     * @param preOrderConfig_maxOrderAheadDays Max Days to order ahead
     * @param preOrderConfig_includeAsap Show ASAP as option
     * @param preOrderConfig_includeMoreGranularInitialTime Granual Init&#39; Time
     * @param preOrderConfig_cutOffTimePreviousDayBasic Cut off time previous day
     * @param preOrderConfig_cutOffTimeCurrentDayBasic Cut off time current day
     * @param preOrderConfig_preOrderTimeDisplayType Type of time displayed.
     * @param preOrderConfig_alwaysAppearOpen Specifies whether a customer can pre-order outside the store opening hours or not.
     * @param preOrderConfig_requireExplicitSelectAlways Force customer to select collection time.
     * @param {*} [options] Override http request options.
     */
    public getPreOrderPreview (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig_leadTimeMinutes?: number, preOrderConfig_intervalMinutes?: number, preOrderConfig_maxOrderAheadDays?: number, preOrderConfig_includeAsap?: boolean, preOrderConfig_includeMoreGranularInitialTime?: boolean, preOrderConfig_cutOffTimePreviousDayBasic?: string, preOrderConfig_cutOffTimeCurrentDayBasic?: string, preOrderConfig_preOrderTimeDisplayType?: 'SingleTime' | 'StartAndEndTime' | 'DayOnly', preOrderConfig_alwaysAppearOpen?: boolean, preOrderConfig_requireExplicitSelectAlways?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/preview'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderPreview.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderPreview.');
        }

        if (preOrderConfig_leadTimeMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.leadTimeMinutes'] = ObjectSerializer.serialize(preOrderConfig_leadTimeMinutes, "number");
        }

        if (preOrderConfig_intervalMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.intervalMinutes'] = ObjectSerializer.serialize(preOrderConfig_intervalMinutes, "number");
        }

        if (preOrderConfig_maxOrderAheadDays !== undefined) {
            localVarQueryParameters['preOrderConfig.maxOrderAheadDays'] = ObjectSerializer.serialize(preOrderConfig_maxOrderAheadDays, "number");
        }

        if (preOrderConfig_includeAsap !== undefined) {
            localVarQueryParameters['preOrderConfig.includeAsap'] = ObjectSerializer.serialize(preOrderConfig_includeAsap, "boolean");
        }

        if (preOrderConfig_includeMoreGranularInitialTime !== undefined) {
            localVarQueryParameters['preOrderConfig.includeMoreGranularInitialTime'] = ObjectSerializer.serialize(preOrderConfig_includeMoreGranularInitialTime, "boolean");
        }

        if (preOrderConfig_cutOffTimePreviousDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimePreviousDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimePreviousDayBasic, "string");
        }

        if (preOrderConfig_cutOffTimeCurrentDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimeCurrentDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimeCurrentDayBasic, "string");
        }

        if (preOrderConfig_preOrderTimeDisplayType !== undefined) {
            localVarQueryParameters['preOrderConfig.preOrderTimeDisplayType'] = ObjectSerializer.serialize(preOrderConfig_preOrderTimeDisplayType, "'SingleTime' | 'StartAndEndTime' | 'DayOnly'");
        }

        if (preOrderConfig_alwaysAppearOpen !== undefined) {
            localVarQueryParameters['preOrderConfig.alwaysAppearOpen'] = ObjectSerializer.serialize(preOrderConfig_alwaysAppearOpen, "boolean");
        }

        if (preOrderConfig_requireExplicitSelectAlways !== undefined) {
            localVarQueryParameters['preOrderConfig.requireExplicitSelectAlways'] = ObjectSerializer.serialize(preOrderConfig_requireExplicitSelectAlways, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresPreOrderTimeFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param paymentAccountType 
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: 'Card' | 'Cash' | 'Ideal' | 'Bancontact' | 'Giropay' | 'Eps' | 'Emv' | 'PayPal', appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'paymentAccountType' + '}', encodeURIComponent(String(paymentAccountType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1ProcessingFeeConfigFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store by identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getStoreById (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param storeNameQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoreHeadersByAppId (appId: string, storeNameQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/header'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreHeadersByAppId.');
        }

        if (storeNameQuery !== undefined) {
            localVarQueryParameters['storeNameQuery'] = ObjectSerializer.serialize(storeNameQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreHeaderFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stores statistics by app name id and storeIds
     * @param appId App Name Id
     * @param storeId Store Ids
     * @param {*} [options] Override http request options.
     */
    public getStoreNetSales (appId: string, storeId: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1StoresStoreStatisticsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores, excluding archived ones
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public publishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/publish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling publishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Business hours
     * @param storeId Store identifier
     * @param deliveryType Delivery type
     * @param businessHoursPeriod Business Hours Period
     * @param {*} [options] Override http request options.
     */
    public setBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', businessHoursPeriod: FlipdishPublicModelsV1BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "FlipdishPublicModelsV1BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1BusinessHoursPeriodFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param enabled Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public setPreOrdeEnabled (storeId: number, deliveryType: 'Delivery' | 'Pickup', enabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/enabled'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'enabled' is not null or undefined
        if (enabled === null || enabled === undefined) {
            throw new Error('Required parameter enabled was null or undefined when calling setPreOrdeEnabled.');
        }

        if (enabled !== undefined) {
            localVarQueryParameters['enabled'] = ObjectSerializer.serialize(enabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unpublish store
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public unpublishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/unpublish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unpublishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UPDATE pre order config for a store, by type
     * @param storeId Store identifier
     * @param deliveryType \&quot;delivery\&quot; or \&quot;pickup\&quot;
     * @param preOrderConfig Update pre order config values
     * @param {*} [options] Override http request options.
     */
    public updatePreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig: FlipdishPublicModelsV1StoresPreOrderConfig, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'preOrderConfig' is not null or undefined
        if (preOrderConfig === null || preOrderConfig === undefined) {
            throw new Error('Required parameter preOrderConfig was null or undefined when calling updatePreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(preOrderConfig, "FlipdishPublicModelsV1StoresPreOrderConfig")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1ApiResultsRestApiDefaultResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store by identifier
     * @param storeId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public updateStore (storeId: number, store: FlipdishPublicModelsV1StoresStoreBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "FlipdishPublicModelsV1StoresStoreBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address
     * @param storeId Store identifier
     * @param storeAddress Store address
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddress (storeId: number, storeAddress: FlipdishPublicModelsV1StoresStoreAddressBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeAddress, "FlipdishPublicModelsV1StoresStoreAddressBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StoresStoreAddressFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address coordinates
     * @param storeId Store identifier
     * @param coordinates Store address coordinates
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: FlipdishPublicModelsV1Coordinates, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coordinates, "FlipdishPublicModelsV1Coordinates")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1CoordinatesFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        (this.authentications as any)[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Cancel a stuart job
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartCancelJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get start job details
     * @param jobId Stuart job identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartJobResponseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stuart settings for a store
     * @param storeId Store Identifier
     * @param {*} [options] Override http request options.
     */
    public stuartGetStuartSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1StuartStuartSettingsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set stuart settings for a store
     * @param storeId Store Identifier
     * @param stuartSettings Stuart settings model
     * @param {*} [options] Override http request options.
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: FlipdishPublicModelsV1StuartStuartSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stuartSettings, "FlipdishPublicModelsV1StuartStuartSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        (this.authentications as any)[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create teammate and send an invite.
     * @param appId Application identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public createTeammate (appId: string, teammate: FlipdishPublicModelsV1TeammatesCreateTeammate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "FlipdishPublicModelsV1TeammatesCreateTeammate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete teammate
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteTeammate (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a teammates by email address
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all teammates
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getTeammatesByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Redeem one-time code from invitation
     * @param otc 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public redeemInvitation (otc: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', encodeURIComponent(String(otc)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesRedeemInvitationResultFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update teammates (this method does not support Deltas!)
     * @param appId Application identifier
     * @param id teammate identifier
     * @param teammate teammate model
     * @param {*} [options] Override http request options.
     */
    public updateTeammate (appId: string, id: string, teammate: FlipdishPublicModelsV1TeammatesTeammateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "FlipdishPublicModelsV1TeammatesTeammateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1TeammatesTeammateFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param userId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getPreviousOrderCountForStore (userId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/{userId}/previousordercount/{storeId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get role names
     * @param {*} [options] Override http request options.
     */
    public getRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Create voucher
     * @param appId App Name Id
     * @param voucher Voucher Details
     * @param {*} [options] Override http request options.
     */
    public createVoucher (appId: string, voucher: FlipdishPublicModelsV1VouchersCreateVoucher, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "FlipdishPublicModelsV1VouchersCreateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher by identifier
     * @param voucherId Id of the voucher
     * @param {*} [options] Override http request options.
     */
    public getVoucherById (voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher stats by identifier
     * @param voucherId Id of the voucher
     * @param aggregateDataBy Aggregate data by day \\ week \\ month
     * @param dataPointLimit Amount of data points per request
     * @param {*} [options] Override http request options.
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            localVarQueryParameters['aggregateDataBy'] = ObjectSerializer.serialize(aggregateDataBy, "'Daily' | 'Weekly' | 'Monthly'");
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiArrayResult1FlipdishPublicModelsV1VouchersVoucherDataPointFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get vouchers summaries for App Id
     * @param appId Application Id
     * @param pageIndex Page Number
     * @param pageSize Page Size
     * @param searchCodes Search by Voucher Code\\s
     * @param statusSearch Search by Status
     * @param typeSearch Search by Type
     * @param subTypeSearch Search by Sub Type
     * @param storeIds Search by Store Ids
     * @param {*} [options] Override http request options.
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>, typeSearch?: Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>, subTypeSearch?: Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchCodes !== undefined) {
            localVarQueryParameters['searchCodes'] = ObjectSerializer.serialize(searchCodes, "Array<string>");
        }

        if (statusSearch !== undefined) {
            localVarQueryParameters['statusSearch'] = ObjectSerializer.serialize(statusSearch, "Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>");
        }

        if (typeSearch !== undefined) {
            localVarQueryParameters['typeSearch'] = ObjectSerializer.serialize(typeSearch, "Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>");
        }

        if (subTypeSearch !== undefined) {
            localVarQueryParameters['subTypeSearch'] = ObjectSerializer.serialize(subTypeSearch, "Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1VouchersVoucherSummaryFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Updates voucher
     * @param voucherId Id of the voucher
     * @param voucher Updated details for the voucher
     * @param storeId 
     * @param percentValue Percent voucher value (can have 1 of 3)
     * @param lumpValue Lump voucher value (can have 1 of 3)
     * @param freeItemId Free Item Id (can have 1 of 3)
     * @param {*} [options] Override http request options.
     */
    public updateVoucher (voucherId: number, voucher: FlipdishPublicModelsV1VouchersVoucherBase, storeId?: Array<number>, percentValue?: number, lumpValue?: number, freeItemId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (percentValue !== undefined) {
            localVarQueryParameters['percentValue'] = ObjectSerializer.serialize(percentValue, "number");
        }

        if (lumpValue !== undefined) {
            localVarQueryParameters['lumpValue'] = ObjectSerializer.serialize(lumpValue, "number");
        }

        if (freeItemId !== undefined) {
            localVarQueryParameters['freeItemId'] = ObjectSerializer.serialize(freeItemId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "FlipdishPublicModelsV1VouchersVoucherBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1VouchersVoucherWithStatsFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a webhook subscription for you Oauth App
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public craeteWebhookSubscription (oauthAppId: string, webhookSubscription: FlipdishPublicModelsV1WebhooksWebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling craeteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "FlipdishPublicModelsV1WebhooksWebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete you webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscription event names
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNames (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your webhook subscriptions selected event names
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs for your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param appId 
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookLogFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscriptions by your Oauth App id
     * @param oauthAppId Oauth App identifier
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiPaginationResult1FlipdishPublicModelsV1WebhooksWebhookSubscriptionFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook subscription object
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: FlipdishPublicModelsV1WebhooksWebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "FlipdishPublicModelsV1WebhooksWebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebsiteApiApiKeys {
}

export class WebsiteApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebsiteApiApiKeys, value: string) {
        (this.authentications as any)[WebsiteApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add a testimonial
     * @param appId Application identifier
     * @param testimonial Testimonial to be added
     * @param {*} [options] Override http request options.
     */
    public addTestimonial (appId: string, testimonial: FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling addTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to delete
     * @param {*} [options] Override http request options.
     */
    public deleteTestimonial (appId: string, testimonialId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling deleteTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Website Image
     * @param appId Application identifier
     * @param imageId Id of the image
     * @param {*} [options] Override http request options.
     */
    public deleteWebsiteImage (appId: string, imageId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebsiteImage.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling deleteWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a testimonial
     * @param appId Application identifier
     * @param testimonialId Id of the testimonial to edit
     * @param testimonial New values of the testimonial
     * @param {*} [options] Override http request options.
     */
    public editTestimonial (appId: string, testimonialId: number, testimonial: FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling editTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "FlipdishPublicModelsV1WebsiteWebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteTestimonialFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Index Configuration
     * @param appId Application identifier
     * @param {*} [options] Override http request options.
     */
    public getIndexConfiguration (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Index Configuration
     * @param appId Application identifier
     * @param indexPage New index page definition
     * @param {*} [options] Override http request options.
     */
    public setIndexConfiguration (appId: string, indexPage: FlipdishPublicModelsV1WebsiteIndexPageBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setIndexConfiguration.');
        }

        // verify required parameter 'indexPage' is not null or undefined
        if (indexPage === null || indexPage === undefined) {
            throw new Error('Required parameter indexPage was null or undefined when calling setIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(indexPage, "FlipdishPublicModelsV1WebsiteIndexPageBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteIndexPageBaseFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload Website Image
     * @param appId Application identifier
     * @param imageLocation Section for which to upload the image
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadWebsiteImage (appId: string, imageLocation: 'IndexHeader' | 'IndexAboutSectionLeft' | 'IndexAboutSectionRight' | 'IndexGallery' | 'IndexOpeningHoursHeader' | 'IndexTestimonialsHeader', Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageLocation}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageLocation' + '}', encodeURIComponent(String(imageLocation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'imageLocation' is not null or undefined
        if (imageLocation === null || imageLocation === undefined) {
            throw new Error('Required parameter imageLocation was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlipdishPublicModelsV1ApiResultsRestApiResult1FlipdishPublicModelsV1WebsiteWebsiteImageFlipdishPublicModelsVersion1000CultureneutralPublicKeyTokennull");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Triggers a Check DNS Process
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public websiteCheckNow (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/dnscheck'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling websiteCheckNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
