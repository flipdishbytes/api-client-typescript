/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Accept
*/
export class Accept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Accept.attributeTypeMap;
    }
}

/**
* Account details
*/
export class AccountDetail {
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Signup steps
    */
    'SignupSteps'?: Array<SignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified'?: boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser'?: boolean;
    /**
    * Accounts Id
    */
    'AccountId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SignupSteps",
            "baseName": "SignupSteps",
            "type": "Array<SignupStep>"
        },
        {
            "name": "IsVerified",
            "baseName": "IsVerified",
            "type": "boolean"
        },
        {
            "name": "IsSelfServeUser",
            "baseName": "IsSelfServeUser",
            "type": "boolean"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetail.attributeTypeMap;
    }
}

/**
* Account Details Base
*/
export class AccountDetailBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetailBase.attributeTypeMap;
    }
}

/**
* Add item details
*/
export class AddItemDetails {
    /**
    * Promotional Item Id
    */
    'PromotionalItemId'?: number;
    /**
    * Promotional Item Name
    */
    'PromotionalItemName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionalItemId",
            "baseName": "PromotionalItemId",
            "type": "number"
        },
        {
            "name": "PromotionalItemName",
            "baseName": "PromotionalItemName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddItemDetails.attributeTypeMap;
    }
}

/**
* Client Analytics event
*/
export class AnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Type of the event
    */
    'EventType'?: string;
    /**
    * Type of the app the event is coming from
    */
    'AppType'?: string;
    /**
    * JSON Metadata
    */
    'Metadata'?: string;
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * Latitude of the event
    */
    'Latitude'?: number;
    /**
    * Longitude of the event
    */
    'Longitude'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalyticsClientEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The values of this data point
    */
    'CurrencyData'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return ApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmDataPoint.attributeTypeMap;
    }
}

/**
* Provides an average value for a single hour of day of the week
*/
export class ApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day'?: ApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour'?: number;
    /**
    * Total Value
    */
    'TotalValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "ApmHourlyDataPoint.DayEnum"
        },
        {
            "name": "Hour",
            "baseName": "Hour",
            "type": "number"
        },
        {
            "name": "TotalValue",
            "baseName": "TotalValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmHourlyDataPoint.attributeTypeMap;
    }
}

export namespace ApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class ApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved'?: number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved'?: number;
    /**
    * Currency based data
    */
    'CurrencyData'?: Array<StatisticsCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesSaved",
            "baseName": "EstimatedMinutesSaved",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesCouldSaved",
            "baseName": "EstimatedMinutesCouldSaved",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<StatisticsCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatistics.attributeTypeMap;
    }
}

/**
* App
*/
export class App {
    /**
    * App Identifier
    */
    'AppId'?: string;
    /**
    * App name
    */
    'Name'?: string;
    /**
    * Center of the map coordinates
    */
    'MapCenter'?: Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates
    */
    'MapNorthEast'?: Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates
    */
    'MapSouthWest'?: Coordinates;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel'?: App.AppAccessLevelEnum;
    /**
    * Icon url
    */
    'IconUrl'?: string;
    /**
    * Icon thumbnail url
    */
    'IconThumbnailUrl'?: string;
    /**
    * Country identifier
    */
    'CountryId'?: string;
    /**
    * Available Languages for Apps\\Staff
    */
    'AvailableAppLanguages'?: Array<Language>;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet'?: Array<App.AppResourceSetEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MapCenter",
            "baseName": "MapCenter",
            "type": "Coordinates"
        },
        {
            "name": "MapNorthEast",
            "baseName": "MapNorthEast",
            "type": "Coordinates"
        },
        {
            "name": "MapSouthWest",
            "baseName": "MapSouthWest",
            "type": "Coordinates"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "App.AppAccessLevelEnum"
        },
        {
            "name": "IconUrl",
            "baseName": "IconUrl",
            "type": "string"
        },
        {
            "name": "IconThumbnailUrl",
            "baseName": "IconThumbnailUrl",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "AvailableAppLanguages",
            "baseName": "AvailableAppLanguages",
            "type": "Array<Language>"
        },
        {
            "name": "AppResourceSet",
            "baseName": "AppResourceSet",
            "type": "Array<App.AppResourceSetEnum>"
        }    ];

    static getAttributeTypeMap() {
        return App.attributeTypeMap;
    }
}

export namespace App {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum AppResourceSetEnum {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        UpdateAppName = <any> 'UpdateAppName',
        EditAppAssets = <any> 'EditAppAssets',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        UpdateVouchersExtendDisable = <any> 'UpdateVouchersExtendDisable',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        ViewFeesConfigurations = <any> 'ViewFeesConfigurations',
        EditFeesConfigurations = <any> 'EditFeesConfigurations',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer'
    }
}
/**
* Application created event
*/
export class AppCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppCreatedEvent.attributeTypeMap;
    }
}

/**
* Application updated event
*/
export class AppUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppUpdatedEvent.attributeTypeMap;
    }
}

/**
* Assigned to Store Bank Account
*/
export class AssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id'?: number;
    /**
    * Name of Bank Account
    */
    'BankAccountName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "BankAccountName",
            "baseName": "BankAccountName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssignedBankAccount.attributeTypeMap;
    }
}

/**
* BANK ACCOUNT
*/
export class BankAccount {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccount.AccountStateEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccount.attributeTypeMap;
    }
}

export namespace BankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountCreate.CurrencyCodeEnum;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountCreate.CurrencyCodeEnum"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreate.attributeTypeMap;
    }
}

export namespace BankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* 
*/
export class BankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDetail {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountDetail.AccountStateEnum;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountDetail.CurrencyCodeEnum;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountDetail.AccountStateEnum"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountDetail.CurrencyCodeEnum"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetail.attributeTypeMap;
    }
}

export namespace BankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* 
*/
export class BankAccountSummary {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountSummary.AccountStateEnum"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountSummary.attributeTypeMap;
    }
}

export namespace BankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId'?: number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverride.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BusinessHoursOverrideId",
            "baseName": "BusinessHoursOverrideId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverride.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverride.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverride.attributeTypeMap;
    }
}

export namespace BusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class BusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverrideBase.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverrideBase.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverrideBase.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverrideBase.attributeTypeMap;
    }
}

export namespace BusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriod {
    /**
    * Early
    */
    'Early'?: Range;
    /**
    * Late
    */
    'Late'?: Range;
    /**
    * Ranges
    */
    'Ranges'?: Array<Range>;
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Early",
            "baseName": "Early",
            "type": "Range"
        },
        {
            "name": "Late",
            "baseName": "Late",
            "type": "Range"
        },
        {
            "name": "Ranges",
            "baseName": "Ranges",
            "type": "Array<Range>"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriodBase.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriodBase.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Credit card
*/
export class Card {
    /**
    * Last four digits
    */
    'Last4Digit'?: string;
    /**
    * Expiry month
    */
    'ExpiryMonth'?: number;
    /**
    * Expiry yaer
    */
    'ExpiryYear'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Last4Digit",
            "baseName": "Last4Digit",
            "type": "string"
        },
        {
            "name": "ExpiryMonth",
            "baseName": "ExpiryMonth",
            "type": "number"
        },
        {
            "name": "ExpiryYear",
            "baseName": "ExpiryYear",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Card.attributeTypeMap;
    }
}

/**
* Credit card Base
*/
export class CardBase {
    /**
    * Expiry month
    */
    'ExpiryMonth'?: number;
    /**
    * Expiry yaer
    */
    'ExpiryYear'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ExpiryMonth",
            "baseName": "ExpiryMonth",
            "type": "number"
        },
        {
            "name": "ExpiryYear",
            "baseName": "ExpiryYear",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CardBase.attributeTypeMap;
    }
}

/**
* Card with token
*/
export class CardWithToken {
    /**
    * Token
    */
    'Token': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardWithToken.attributeTypeMap;
    }
}

/**
* Change password model
*/
export class ChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordModel.attributeTypeMap;
    }
}

/**
* Coordinates
*/
export class Coordinates {
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

/**
* Create account model
*/
export class CreateAccountModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAccountModel.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateTeammate {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: CreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "CreateTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeammate.attributeTypeMap;
    }
}

export namespace CreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* Voucher
*/
export class CreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType'?: CreateVoucher.VoucherTypeEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "CreateVoucher.VoucherTypeEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CreateVoucher.attributeTypeMap;
    }
}

export namespace CreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
}
/**
* Credit note details
*/
export class CreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RemainingCredit",
            "baseName": "RemainingCredit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreditNoteDetails.attributeTypeMap;
    }
}

/**
* A single currency data piece, with no date
*/
export class CurrencyData {
    /**
    * Currency
    */
    'Currency'?: CurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CurrencyData.CurrencyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CurrencyData.attributeTypeMap;
    }
}

export namespace CurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Customer consent updated
*/
export class CustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

/**
* Customer created event
*/
export class CustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreatedEvent.attributeTypeMap;
    }
}

/**
* Customer summary
*/
export class CustomerSummary {
    /**
    * Customer identifier
    */
    'Id'?: number;
    /**
    * Customer name
    */
    'Name'?: string;
    /**
    * Customer email address
    */
    'EmailAddress'?: string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat'?: string;
    /**
    * Customer phone number
    */
    'PhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "PhoneNumberLocalFormat",
            "baseName": "PhoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSummary.attributeTypeMap;
    }
}

/**
* Customer updated event
*/
export class CustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdatedEvent.attributeTypeMap;
    }
}

/**
* Delivery location
*/
export class DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Building
    */
    'Building'?: string;
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Town
    */
    'Town'?: string;
    /**
    * Post code
    */
    'PostCode'?: string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions'?: string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Building",
            "baseName": "Building",
            "type": "string"
        },
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Town",
            "baseName": "Town",
            "type": "string"
        },
        {
            "name": "PostCode",
            "baseName": "PostCode",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "PrettyAddressString",
            "baseName": "PrettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryLocation.attributeTypeMap;
    }
}

/**
* Delivery Zone
*/
export class DeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id'?: number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZone.attributeTypeMap;
    }
}

/**
* Delivery Zone Base
*/
export class DeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneBase.attributeTypeMap;
    }
}

/**
* Delivery Zone Created Event
*/
export class DeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneCreatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Deleted Event
*/
export class DeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneDeletedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Updated Event
*/
export class DeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

/**
* Device settings for Hydra
*/
export class DeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Volume",
            "baseName": "Volume",
            "type": "number"
        },
        {
            "name": "FontSize",
            "baseName": "FontSize",
            "type": "number"
        },
        {
            "name": "Brightness",
            "baseName": "Brightness",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceSettings.attributeTypeMap;
    }
}

/**
* 
*/
export class EventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent'?: Array<AppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent'?: Array<AppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent'?: Array<AnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent'?: Array<OrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent'?: Array<OrderDispatchedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent'?: Array<OrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent'?: Array<OrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent'?: Array<OrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent'?: Array<OrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent'?: Array<OrderTipUpdatedEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent'?: Array<StoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent'?: Array<StoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent'?: Array<StoreAddressUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent'?: Array<DeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent'?: Array<DeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent'?: Array<DeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent'?: Array<StoreOpeningHoursUpdatedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent'?: Array<StoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent'?: Array<StoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent'?: Array<StoreUpdatedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent'?: Array<MenuCreatedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent'?: Array<MenuUpdatedEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent'?: Array<MenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent'?: Array<MenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent'?: Array<MenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent'?: Array<MenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent'?: Array<MenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent'?: Array<MenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent'?: Array<MenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent'?: Array<MenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent'?: Array<MenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent'?: Array<MenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent'?: Array<MenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent'?: Array<MenuItemOptionSetItemDeletedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent'?: Array<StoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent'?: Array<StoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent'?: Array<StoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent'?: Array<CustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent'?: Array<CustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent'?: Array<CustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent'?: Array<WebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent'?: Array<WebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent'?: Array<WebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent'?: Array<PrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent'?: Array<PrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent'?: Array<PrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent'?: Array<PrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent'?: Array<PhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent'?: Array<PhoneCallEndedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent'?: Array<LoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent'?: Array<LoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent'?: Array<LoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent'?: Array<RetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent'?: Array<RetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent'?: Array<RetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent'?: Array<SmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent'?: Array<UserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent'?: Array<UserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent'?: Array<UserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent'?: Array<UserDeletedEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent'?: Array<VoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent'?: Array<VoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent'?: Array<VoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent'?: Array<TeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent'?: Array<TeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent'?: Array<TeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent'?: Array<TeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent'?: Array<BankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent'?: Array<BankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent'?: Array<BankAccountDeletedEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppCreatedEvent",
            "baseName": "AppCreatedEvent",
            "type": "Array<AppCreatedEvent>"
        },
        {
            "name": "AppUpdatedEvent",
            "baseName": "AppUpdatedEvent",
            "type": "Array<AppUpdatedEvent>"
        },
        {
            "name": "AnalyticsClientEvent",
            "baseName": "AnalyticsClientEvent",
            "type": "Array<AnalyticsClientEvent>"
        },
        {
            "name": "OrderAcceptedEvent",
            "baseName": "OrderAcceptedEvent",
            "type": "Array<OrderAcceptedEvent>"
        },
        {
            "name": "OrderDispatchedEvent",
            "baseName": "OrderDispatchedEvent",
            "type": "Array<OrderDispatchedEvent>"
        },
        {
            "name": "OrderCreatedEvent",
            "baseName": "OrderCreatedEvent",
            "type": "Array<OrderCreatedEvent>"
        },
        {
            "name": "OrderRatingUpdatedEvent",
            "baseName": "OrderRatingUpdatedEvent",
            "type": "Array<OrderRatingUpdatedEvent>"
        },
        {
            "name": "OrderRefundedEvent",
            "baseName": "OrderRefundedEvent",
            "type": "Array<OrderRefundedEvent>"
        },
        {
            "name": "OrderRejectedEvent",
            "baseName": "OrderRejectedEvent",
            "type": "Array<OrderRejectedEvent>"
        },
        {
            "name": "OrderTipUpdatedEvent",
            "baseName": "OrderTipUpdatedEvent",
            "type": "Array<OrderTipUpdatedEvent>"
        },
        {
            "name": "StoreCreatedEvent",
            "baseName": "StoreCreatedEvent",
            "type": "Array<StoreCreatedEvent>"
        },
        {
            "name": "StoreDeletedEvent",
            "baseName": "StoreDeletedEvent",
            "type": "Array<StoreDeletedEvent>"
        },
        {
            "name": "StoreAddressUpdatedEvent",
            "baseName": "StoreAddressUpdatedEvent",
            "type": "Array<StoreAddressUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneCreatedEvent",
            "baseName": "DeliveryZoneCreatedEvent",
            "type": "Array<DeliveryZoneCreatedEvent>"
        },
        {
            "name": "DeliveryZoneUpdatedEvent",
            "baseName": "DeliveryZoneUpdatedEvent",
            "type": "Array<DeliveryZoneUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneDeletedEvent",
            "baseName": "DeliveryZoneDeletedEvent",
            "type": "Array<DeliveryZoneDeletedEvent>"
        },
        {
            "name": "StoreOpeningHoursUpdatedEvent",
            "baseName": "StoreOpeningHoursUpdatedEvent",
            "type": "Array<StoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideCreatedEvent",
            "baseName": "StoreBusinessHoursOverrideCreatedEvent",
            "type": "Array<StoreBusinessHoursOverrideCreatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideDeletedEvent",
            "baseName": "StoreBusinessHoursOverrideDeletedEvent",
            "type": "Array<StoreBusinessHoursOverrideDeletedEvent>"
        },
        {
            "name": "StoreUpdatedEvent",
            "baseName": "StoreUpdatedEvent",
            "type": "Array<StoreUpdatedEvent>"
        },
        {
            "name": "MenuCreatedEvent",
            "baseName": "MenuCreatedEvent",
            "type": "Array<MenuCreatedEvent>"
        },
        {
            "name": "MenuUpdatedEvent",
            "baseName": "MenuUpdatedEvent",
            "type": "Array<MenuUpdatedEvent>"
        },
        {
            "name": "MenuSectionCreatedEvent",
            "baseName": "MenuSectionCreatedEvent",
            "type": "Array<MenuSectionCreatedEvent>"
        },
        {
            "name": "MenuSectionUpdatedEvent",
            "baseName": "MenuSectionUpdatedEvent",
            "type": "Array<MenuSectionUpdatedEvent>"
        },
        {
            "name": "MenuSectionDeletedEvent",
            "baseName": "MenuSectionDeletedEvent",
            "type": "Array<MenuSectionDeletedEvent>"
        },
        {
            "name": "MenuSectionItemCreatedEvent",
            "baseName": "MenuSectionItemCreatedEvent",
            "type": "Array<MenuSectionItemCreatedEvent>"
        },
        {
            "name": "MenuSectionItemUpdatedEvent",
            "baseName": "MenuSectionItemUpdatedEvent",
            "type": "Array<MenuSectionItemUpdatedEvent>"
        },
        {
            "name": "MenuSectionItemDeletedEvent",
            "baseName": "MenuSectionItemDeletedEvent",
            "type": "Array<MenuSectionItemDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetCreatedEvent",
            "baseName": "MenuItemOptionSetCreatedEvent",
            "type": "Array<MenuItemOptionSetCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetUpdatedEvent",
            "baseName": "MenuItemOptionSetUpdatedEvent",
            "type": "Array<MenuItemOptionSetUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetDeletedEvent",
            "baseName": "MenuItemOptionSetDeletedEvent",
            "type": "Array<MenuItemOptionSetDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemCreatedEvent",
            "baseName": "MenuItemOptionSetItemCreatedEvent",
            "type": "Array<MenuItemOptionSetItemCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemUpdatedEvent",
            "baseName": "MenuItemOptionSetItemUpdatedEvent",
            "type": "Array<MenuItemOptionSetItemUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemDeletedEvent",
            "baseName": "MenuItemOptionSetItemDeletedEvent",
            "type": "Array<MenuItemOptionSetItemDeletedEvent>"
        },
        {
            "name": "StoreGroupCreatedEvent",
            "baseName": "StoreGroupCreatedEvent",
            "type": "Array<StoreGroupCreatedEvent>"
        },
        {
            "name": "StoreGroupUpdatedEvent",
            "baseName": "StoreGroupUpdatedEvent",
            "type": "Array<StoreGroupUpdatedEvent>"
        },
        {
            "name": "StoreGroupDeletedEvent",
            "baseName": "StoreGroupDeletedEvent",
            "type": "Array<StoreGroupDeletedEvent>"
        },
        {
            "name": "CustomerCreatedEvent",
            "baseName": "CustomerCreatedEvent",
            "type": "Array<CustomerCreatedEvent>"
        },
        {
            "name": "CustomerUpdatedEvent",
            "baseName": "CustomerUpdatedEvent",
            "type": "Array<CustomerUpdatedEvent>"
        },
        {
            "name": "CustomerConsentUpdatedEvent",
            "baseName": "CustomerConsentUpdatedEvent",
            "type": "Array<CustomerConsentUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionCreatedEvent",
            "baseName": "WebhookSubscriptionCreatedEvent",
            "type": "Array<WebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "WebhookSubscriptionUpdatedEvent",
            "baseName": "WebhookSubscriptionUpdatedEvent",
            "type": "Array<WebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionDeletedEvent",
            "baseName": "WebhookSubscriptionDeletedEvent",
            "type": "Array<WebhookSubscriptionDeletedEvent>"
        },
        {
            "name": "PrinterTurnedOnEvent",
            "baseName": "PrinterTurnedOnEvent",
            "type": "Array<PrinterTurnedOnEvent>"
        },
        {
            "name": "PrinterTurnedOffEvent",
            "baseName": "PrinterTurnedOffEvent",
            "type": "Array<PrinterTurnedOffEvent>"
        },
        {
            "name": "PrinterAssignedToStoreEvent",
            "baseName": "PrinterAssignedToStoreEvent",
            "type": "Array<PrinterAssignedToStoreEvent>"
        },
        {
            "name": "PrinterUnassignedFromStoreEvent",
            "baseName": "PrinterUnassignedFromStoreEvent",
            "type": "Array<PrinterUnassignedFromStoreEvent>"
        },
        {
            "name": "PhoneCallStartedEvent",
            "baseName": "PhoneCallStartedEvent",
            "type": "Array<PhoneCallStartedEvent>"
        },
        {
            "name": "PhoneCallEndedEvent",
            "baseName": "PhoneCallEndedEvent",
            "type": "Array<PhoneCallEndedEvent>"
        },
        {
            "name": "LoyaltyCampaignCreatedEvent",
            "baseName": "LoyaltyCampaignCreatedEvent",
            "type": "Array<LoyaltyCampaignCreatedEvent>"
        },
        {
            "name": "LoyaltyCampaignDeletedEvent",
            "baseName": "LoyaltyCampaignDeletedEvent",
            "type": "Array<LoyaltyCampaignDeletedEvent>"
        },
        {
            "name": "LoyaltyCampaignUpdatedEvent",
            "baseName": "LoyaltyCampaignUpdatedEvent",
            "type": "Array<LoyaltyCampaignUpdatedEvent>"
        },
        {
            "name": "RetentionCampaignCreatedEvent",
            "baseName": "RetentionCampaignCreatedEvent",
            "type": "Array<RetentionCampaignCreatedEvent>"
        },
        {
            "name": "RetentionCampaignDeletedEvent",
            "baseName": "RetentionCampaignDeletedEvent",
            "type": "Array<RetentionCampaignDeletedEvent>"
        },
        {
            "name": "RetentionCampaignUpdatedEvent",
            "baseName": "RetentionCampaignUpdatedEvent",
            "type": "Array<RetentionCampaignUpdatedEvent>"
        },
        {
            "name": "SmsReceivedEvent",
            "baseName": "SmsReceivedEvent",
            "type": "Array<SmsReceivedEvent>"
        },
        {
            "name": "UserLoginEvent",
            "baseName": "UserLoginEvent",
            "type": "Array<UserLoginEvent>"
        },
        {
            "name": "UserCreatedEvent",
            "baseName": "UserCreatedEvent",
            "type": "Array<UserCreatedEvent>"
        },
        {
            "name": "UserUpdatedEvent",
            "baseName": "UserUpdatedEvent",
            "type": "Array<UserUpdatedEvent>"
        },
        {
            "name": "UserDeletedEvent",
            "baseName": "UserDeletedEvent",
            "type": "Array<UserDeletedEvent>"
        },
        {
            "name": "VoucherCreatedEvent",
            "baseName": "VoucherCreatedEvent",
            "type": "Array<VoucherCreatedEvent>"
        },
        {
            "name": "VoucherUpdatedEvent",
            "baseName": "VoucherUpdatedEvent",
            "type": "Array<VoucherUpdatedEvent>"
        },
        {
            "name": "VoucherDeletedEvent",
            "baseName": "VoucherDeletedEvent",
            "type": "Array<VoucherDeletedEvent>"
        },
        {
            "name": "TeammateInviteSentEvent",
            "baseName": "TeammateInviteSentEvent",
            "type": "Array<TeammateInviteSentEvent>"
        },
        {
            "name": "TeammateInviteAcceptedEvent",
            "baseName": "TeammateInviteAcceptedEvent",
            "type": "Array<TeammateInviteAcceptedEvent>"
        },
        {
            "name": "TeammateUpdatedEvent",
            "baseName": "TeammateUpdatedEvent",
            "type": "Array<TeammateUpdatedEvent>"
        },
        {
            "name": "TeammateDeletedEvent",
            "baseName": "TeammateDeletedEvent",
            "type": "Array<TeammateDeletedEvent>"
        },
        {
            "name": "BankAccountCreatedEvent",
            "baseName": "BankAccountCreatedEvent",
            "type": "Array<BankAccountCreatedEvent>"
        },
        {
            "name": "BankAccountUpdatedEvent",
            "baseName": "BankAccountUpdatedEvent",
            "type": "Array<BankAccountUpdatedEvent>"
        },
        {
            "name": "BankAccountDeletedEvent",
            "baseName": "BankAccountDeletedEvent",
            "type": "Array<BankAccountDeletedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return EventSearchResult.attributeTypeMap;
    }
}

/**
* Fee Summary
*/
export class FeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount'?: number;
    /**
    * Percentage rate
    */
    'PercentageRate'?: number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeAmount",
            "baseName": "FeeAmount",
            "type": "number"
        },
        {
            "name": "PercentageRate",
            "baseName": "PercentageRate",
            "type": "number"
        },
        {
            "name": "PerTransactionFee",
            "baseName": "PerTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeeSummary.attributeTypeMap;
    }
}

/**
* Describes coordinates that have a group
*/
export class GroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude'?: number;
    /**
    * Longitude of this coordinate
    */
    'Longitude'?: number;
    /**
    * Count of members in the group
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupedCoordinates.attributeTypeMap;
    }
}

/**
* 
*/
export class HomeAction {
    /**
    * 
    */
    'HomeActionId'?: number;
    /**
    * Type of Action
    */
    'HomeActionType'?: HomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order'?: number;
    /**
    * 
    */
    'TitleKey'?: string;
    /**
    * 
    */
    'ActionKey'?: string;
    /**
    * 
    */
    'DescriptionKey'?: string;
    /**
    * 
    */
    'Action'?: string;
    /**
    * 
    */
    'Dismissible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HomeActionId",
            "baseName": "HomeActionId",
            "type": "number"
        },
        {
            "name": "HomeActionType",
            "baseName": "HomeActionType",
            "type": "HomeAction.HomeActionTypeEnum"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "number"
        },
        {
            "name": "TitleKey",
            "baseName": "TitleKey",
            "type": "string"
        },
        {
            "name": "ActionKey",
            "baseName": "ActionKey",
            "type": "string"
        },
        {
            "name": "DescriptionKey",
            "baseName": "DescriptionKey",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "Dismissible",
            "baseName": "Dismissible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HomeAction.attributeTypeMap;
    }
}

export namespace HomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class HomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalMoneySaved",
            "baseName": "TotalMoneySaved",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return HomeStatistics.attributeTypeMap;
    }
}

/**
* Http Request and Response Log
*/
export class HttpRequestAndResponseLog {
    /**
    * Verb associated with the HTTP call.
    */
    'Verb'?: string;
    /**
    * Http request URI.
    */
    'RequestUri'?: string;
    /**
    * Http response status code.
    */
    'StatusCode'?: number;
    /**
    * Http response status line.
    */
    'ReasonPhrase'?: string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds'?: number;
    /**
    * Identity of the caller.
    */
    'UserId'?: string;
    /**
    * Ip address of the caller
    */
    'IpAddress'?: string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime'?: string;
    /**
    * Http request headers.
    */
    'RequestHeaders'?: { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody'?: string;
    /**
    * Http request content-length
    */
    'RequestLength'?: number;
    /**
    * Http response headers.
    */
    'ResponseHeaders'?: { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody'?: string;
    /**
    * Http response content-length
    */
    'ResponseLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Verb",
            "baseName": "Verb",
            "type": "string"
        },
        {
            "name": "RequestUri",
            "baseName": "RequestUri",
            "type": "string"
        },
        {
            "name": "StatusCode",
            "baseName": "StatusCode",
            "type": "number"
        },
        {
            "name": "ReasonPhrase",
            "baseName": "ReasonPhrase",
            "type": "string"
        },
        {
            "name": "CallDurationInMilliseconds",
            "baseName": "CallDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        },
        {
            "name": "CreatedDateTime",
            "baseName": "CreatedDateTime",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "RequestLength",
            "baseName": "RequestLength",
            "type": "number"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "ResponseLength",
            "baseName": "ResponseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Hydra configuration
*/
export class HydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': Array<HydraConfig.PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': DeviceSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinimumVersion",
            "baseName": "MinimumVersion",
            "type": "string"
        },
        {
            "name": "PaymentOptions",
            "baseName": "PaymentOptions",
            "type": "Array<HydraConfig.PaymentOptionsEnum>"
        },
        {
            "name": "DeviceSettings",
            "baseName": "DeviceSettings",
            "type": "DeviceSettings"
        }    ];

    static getAttributeTypeMap() {
        return HydraConfig.attributeTypeMap;
    }
}

export namespace HydraConfig {
    export enum PaymentOptionsEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hdyra login result
*/
export class HydraRegistration {
    /**
    * App
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreId': number;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HydraRegistration.attributeTypeMap;
    }
}

/**
* Hdyra status
*/
export class HydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreId'?: number;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "IsRegistered",
            "baseName": "IsRegistered",
            "type": "boolean"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HydraStatus.attributeTypeMap;
    }
}

/**
* Job Address
*/
export class JobAddress {
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country
    */
    'Country'?: string;
    /**
    * Zone
    */
    'Zone'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Country",
            "baseName": "Country",
            "type": "string"
        },
        {
            "name": "Zone",
            "baseName": "Zone",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobAddress.attributeTypeMap;
    }
}

/**
* Job Cancellation
*/
export class JobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy'?: string;
    /**
    * Reason Key
    */
    'ReasonKey'?: string;
    /**
    * Comment
    */
    'Comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanceledBy",
            "baseName": "CanceledBy",
            "type": "string"
        },
        {
            "name": "ReasonKey",
            "baseName": "ReasonKey",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobCancellation.attributeTypeMap;
    }
}

/**
* Job Contact
*/
export class JobContact {
    /**
    * Firstname
    */
    'Firstname'?: string;
    /**
    * Lastname
    */
    'Lastname'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Company
    */
    'Company'?: string;
    /**
    * Company Name
    */
    'CompanyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Firstname",
            "baseName": "Firstname",
            "type": "string"
        },
        {
            "name": "Lastname",
            "baseName": "Lastname",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Company",
            "baseName": "Company",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobContact.attributeTypeMap;
    }
}

/**
* Job Delivery
*/
export class JobDelivery {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Picked At
    */
    'PickedAt'?: string;
    /**
    * Delivered At
    */
    'DeliveredAt'?: string;
    /**
    * Tracking Url
    */
    'TrackingUrl'?: string;
    /**
    * Client Reference
    */
    'ClientReference'?: string;
    /**
    * Package Description
    */
    'PackageDescription'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Pickup
    */
    'Pickup'?: JobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff'?: JobDeliveryDetail;
    /**
    * Eta
    */
    'Eta'?: JobEta;
    /**
    * Cancellation
    */
    'Cancellation'?: JobCancellation;
    /**
    * Proof
    */
    'Proof'?: JobProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PickedAt",
            "baseName": "PickedAt",
            "type": "string"
        },
        {
            "name": "DeliveredAt",
            "baseName": "DeliveredAt",
            "type": "string"
        },
        {
            "name": "TrackingUrl",
            "baseName": "TrackingUrl",
            "type": "string"
        },
        {
            "name": "ClientReference",
            "baseName": "ClientReference",
            "type": "string"
        },
        {
            "name": "PackageDescription",
            "baseName": "PackageDescription",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Eta",
            "baseName": "Eta",
            "type": "JobEta"
        },
        {
            "name": "Cancellation",
            "baseName": "Cancellation",
            "type": "JobCancellation"
        },
        {
            "name": "Proof",
            "baseName": "Proof",
            "type": "JobProof"
        }    ];

    static getAttributeTypeMap() {
        return JobDelivery.attributeTypeMap;
    }
}

/**
* Job Delivery Detail
*/
export class JobDeliveryDetail {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Address
    */
    'Address'?: JobAddress;
    /**
    * Contact
    */
    'Contact'?: JobContact;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "JobAddress"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "JobContact"
        }    ];

    static getAttributeTypeMap() {
        return JobDeliveryDetail.attributeTypeMap;
    }
}

/**
* Job Driver
*/
export class JobDriver {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Display Name
    */
    'DisplayName'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Picture Url
    */
    'PictureUrl'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "PictureUrl",
            "baseName": "PictureUrl",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDriver.attributeTypeMap;
    }
}

/**
* Job Eta
*/
export class JobEta {
    /**
    * Pickup
    */
    'Pickup'?: string;
    /**
    * Dropoff
    */
    'Dropoff'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "string"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobEta.attributeTypeMap;
    }
}

/**
* Job Pricing
*/
export class JobPricing {
    /**
    * Currency
    */
    'Currency'?: string;
    /**
    * Tax Percentage
    */
    'TaxPercentage'?: number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded'?: number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded'?: number;
    /**
    * Tax Amount
    */
    'TaxAmount'?: number;
    /**
    * Invoice Url
    */
    'InvoiceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "TaxPercentage",
            "baseName": "TaxPercentage",
            "type": "number"
        },
        {
            "name": "PriceTaxIncluded",
            "baseName": "PriceTaxIncluded",
            "type": "number"
        },
        {
            "name": "PriceTaxExcluded",
            "baseName": "PriceTaxExcluded",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "InvoiceUrl",
            "baseName": "InvoiceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobPricing.attributeTypeMap;
    }
}

/**
* Job Proof
*/
export class JobProof {
    /**
    * Signature Url
    */
    'SignatureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SignatureUrl",
            "baseName": "SignatureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobProof.attributeTypeMap;
    }
}

/**
* Job Response
*/
export class JobResponse {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Created At
    */
    'CreatedAt'?: Date;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Assignment Code
    */
    'AssignmentCode'?: string;
    /**
    * Pickup At
    */
    'PickupAt'?: string;
    /**
    * Dropoff At
    */
    'DropoffAt'?: string;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Distance
    */
    'Distance'?: number;
    /**
    * Duration
    */
    'Duration'?: number;
    /**
    * Deliveries
    */
    'Deliveries'?: Array<JobDelivery>;
    /**
    * Pricing
    */
    'Pricing'?: JobPricing;
    /**
    * Driver
    */
    'Driver'?: JobDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "CreatedAt",
            "baseName": "CreatedAt",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "AssignmentCode",
            "baseName": "AssignmentCode",
            "type": "string"
        },
        {
            "name": "PickupAt",
            "baseName": "PickupAt",
            "type": "string"
        },
        {
            "name": "DropoffAt",
            "baseName": "DropoffAt",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Distance",
            "baseName": "Distance",
            "type": "number"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "number"
        },
        {
            "name": "Deliveries",
            "baseName": "Deliveries",
            "type": "Array<JobDelivery>"
        },
        {
            "name": "Pricing",
            "baseName": "Pricing",
            "type": "JobPricing"
        },
        {
            "name": "Driver",
            "baseName": "Driver",
            "type": "JobDriver"
        }    ];

    static getAttributeTypeMap() {
        return JobResponse.attributeTypeMap;
    }
}

/**
* Sorted Language
*/
export class Language {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId'?: string;
    /**
    * Display Order
    */
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Language.attributeTypeMap;
    }
}

/**
* Ligthspeed store settings
*/
export class LightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection'?: number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation'?: string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment'?: boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId'?: string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId'?: string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId'?: string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType'?: LightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CompanyId",
            "baseName": "CompanyId",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesForCollection",
            "baseName": "EstimatedMinutesForCollection",
            "type": "number"
        },
        {
            "name": "GeographicLocation",
            "baseName": "GeographicLocation",
            "type": "string"
        },
        {
            "name": "Establishment",
            "baseName": "Establishment",
            "type": "boolean"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "string"
        },
        {
            "name": "DeliveryFeeId",
            "baseName": "DeliveryFeeId",
            "type": "string"
        },
        {
            "name": "ProcessingFeeId",
            "baseName": "ProcessingFeeId",
            "type": "string"
        },
        {
            "name": "PriceType",
            "baseName": "PriceType",
            "type": "LightspeedSettings.PriceTypeEnum"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LightspeedSettings.attributeTypeMap;
    }
}

export namespace LightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Represents a localised time zone
*/
export class LocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId'?: string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId'?: string;
    /**
    * Display name in users language
    */
    'DisplayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TimeZoneId",
            "baseName": "TimeZoneId",
            "type": "string"
        },
        {
            "name": "IanaTimeZoneId",
            "baseName": "IanaTimeZoneId",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Login model
*/
export class LoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoginModel.attributeTypeMap;
    }
}

/**
* Login with PIN model
*/
export class LoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoginWithPinModel.attributeTypeMap;
    }
}

/**
* The loyalty campaign
*/
export class LoyaltyCampaign {
    /**
    * Date and time of campaign beginning
    */
    'From'?: Date;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Loyalty campaign created event
*/
export class LoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign deleted event
*/
export class LoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign updated event
*/
export class LoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Lump discount details
*/
export class LumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DiscountAmount",
            "baseName": "DiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LumpDiscountDetails.attributeTypeMap;
    }
}

/**
* Menu
*/
export class Menu {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<MenuSection>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: Menu.MenuSectionBehaviourEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<MenuSection>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "Menu.MenuSectionBehaviourEnum"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
}
/**
* Menu base
*/
export class MenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: MenuBase.MenuSectionBehaviourEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "MenuBase.MenuSectionBehaviourEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuBase.attributeTypeMap;
    }
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
}
/**
* Menu Checkpoint
*/
export class MenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId'?: number;
    /**
    * Time of creation of checkpoint
    */
    'Time'?: Date;
    /**
    * Name of checkpoint
    */
    'Name'?: string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCheckpointId",
            "baseName": "MenuCheckpointId",
            "type": "number"
        },
        {
            "name": "Time",
            "baseName": "Time",
            "type": "Date"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpoint.attributeTypeMap;
    }
}

/**
* Menu created event
*/
export class MenuCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCreatedEvent.attributeTypeMap;
    }
}

/**
* Menu item option set
*/
export class MenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<MenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<MenuItemOptionSetItem>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSet.attributeTypeMap;
    }
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item option set item
*/
export class MenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItem.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class MenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItemBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItemBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu section
*/
export class MenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu items
    */
    'MenuItems'?: Array<MenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<MenuSectionItem>"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSection.attributeTypeMap;
    }
}

/**
* Menu section availability
*/
export class MenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes'?: Array<BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailability.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailableTimes",
            "baseName": "AvailableTimes",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailability.attributeTypeMap;
    }
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class MenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailabilityBase.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailabilityBase.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailabilityBase.attributeTypeMap;
    }
}

export namespace MenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class MenuSectionBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionBase.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item
*/
export class MenuSectionItem {
    /**
    * Menu item identifier. This ID may change at any time. Use `PublicId` if you need a perminant reference to the item.
    */
    'MenuItemId'?: number;
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice'?: number;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<MenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours'?: Array<BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ActualPrice",
            "baseName": "ActualPrice",
            "type": "number"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<MenuItemOptionSet>"
        },
        {
            "name": "DailySpecialHours",
            "baseName": "DailySpecialHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItem.attributeTypeMap;
    }
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class MenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemBase.attributeTypeMap;
    }
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Deleted by user
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Menu name
    */
    'MenuName'?: string;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Store Names
*/
export class MenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuStoreNames.attributeTypeMap;
    }
}

/**
* Menu Summary
*/
export class MenuSummary {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuSummary.attributeTypeMap;
    }
}

/**
* Menu updated event
*/
export class MenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUpdatedEvent.attributeTypeMap;
    }
}

/**
* Metadata
*/
export class Metadata {
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metadata.attributeTypeMap;
    }
}

/**
* Oauth client (also knowns as 'app')
*/
export class OAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId'?: string;
    /**
    * OAuth App Name
    */
    'OauthAppName'?: string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * OAuth App logo uri
    */
    'LogoUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OauthAppId",
            "baseName": "OauthAppId",
            "type": "string"
        },
        {
            "name": "OauthAppName",
            "baseName": "OauthAppName",
            "type": "string"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OAuthApp.attributeTypeMap;
    }
}

/**
* OAuth token model
*/
export class OAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key'?: string;
    /**
    * Token type
    */
    'TokenType'?: string;
    /**
    * Oauth subject identifier
    */
    'SubjectId'?: string;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Token expiry
    */
    'Expiry'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "TokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "SubjectId",
            "baseName": "SubjectId",
            "type": "string"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "Expiry",
            "baseName": "Expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OAuthTokenModel.attributeTypeMap;
    }
}

/**
* OAuth client redirect uri
*/
export class OauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id'?: number;
    /**
    * Redirect uri
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Order
*/
export class Order {
    /**
    * Store summary
    */
    'Store'?: StoreSummary;
    /**
    * Customer summary
    */
    'Customer'?: CustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher'?: OrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees'?: FeeSummary;
    /**
    * Ordered items
    */
    'OrderItems'?: Array<OrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation'?: DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation'?: Coordinates;
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: Order.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: Order.PickupLocationTypeEnum;
    /**
    * Tip amount
    */
    'TipAmount'?: number;
    /**
    * Delivery amount
    */
    'DeliveryAmount'?: number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount'?: number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount'?: number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: Order.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription'?: string;
    /**
    * Order state
    */
    'OrderState'?: Order.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder'?: boolean;
    /**
    * Order placed time
    */
    'PlacedTime'?: Date;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Chef note
    */
    'ChefNote'?: string;
    /**
    * Used app type
    */
    'AppType'?: Order.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating'?: number;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: Order.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason'?: Order.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Store",
            "baseName": "Store",
            "type": "StoreSummary"
        },
        {
            "name": "Customer",
            "baseName": "Customer",
            "type": "CustomerSummary"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "OrderVoucherSummary"
        },
        {
            "name": "Fees",
            "baseName": "Fees",
            "type": "FeeSummary"
        },
        {
            "name": "OrderItems",
            "baseName": "OrderItems",
            "type": "Array<OrderItem>"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        },
        {
            "name": "CustomerLocation",
            "baseName": "CustomerLocation",
            "type": "Coordinates"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "Order.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "Order.PickupLocationTypeEnum"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "OrderItemsAmount",
            "baseName": "OrderItemsAmount",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "Order.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentAccountDescription",
            "baseName": "PaymentAccountDescription",
            "type": "string"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "Order.OrderStateEnum"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "PlacedTime",
            "baseName": "PlacedTime",
            "type": "Date"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "Order.AppTypeEnum"
        },
        {
            "name": "UserRating",
            "baseName": "UserRating",
            "type": "number"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "Order.PaymentStatusEnum"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "Order.RejectionReasonEnum"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Order Accepted Event
*/
export class OrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderAcceptedTime",
            "baseName": "OrderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderAcceptedEvent.attributeTypeMap;
    }
}

/**
* Order Created Event
*/
export class OrderCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCreatedTime",
            "baseName": "OrderCreatedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedEvent.attributeTypeMap;
    }
}

/**
* Order Dispatched Event
*/
export class OrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderDispatchedTime",
            "baseName": "OrderDispatchedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDispatchedEvent.attributeTypeMap;
    }
}

/**
* Order item
*/
export class OrderItem {
    /**
    * Option list
    */
    'OrderItemOptions'?: Array<OrderItemOption>;
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId'?: string;
    /**
    * Menu section name
    */
    'MenuSectionName'?: string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems'?: number;
    /**
    * Menu item identifier
    */
    'MenuItemId'?: number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderItemOptions",
            "baseName": "OrderItemOptions",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "MenuItemDisplayOrder",
            "baseName": "MenuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

/**
* Order item option
*/
export class OrderItemOption {
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId'?: string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId'?: number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder'?: number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemOptionPublicId",
            "baseName": "MenuItemOptionPublicId",
            "type": "string"
        },
        {
            "name": "MenuItemOptionId",
            "baseName": "MenuItemOptionId",
            "type": "number"
        },
        {
            "name": "IsMasterOptionSetItem",
            "baseName": "IsMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "MenuItemOptionDisplayOrder",
            "baseName": "MenuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetDisplayOrder",
            "baseName": "MenuItemOptionSetDisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

/**
* Order Rating Update Event
*/
export class OrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * New User Rating
    */
    'Rating'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Rating",
            "baseName": "Rating",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRatingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Refunded Event
*/
export class OrderRefundedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The amount refunded
    */
    'RefundedAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRefundedEvent.attributeTypeMap;
    }
}

/**
* Order Rejected Event
*/
export class OrderRejectedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderRejectedTime",
            "baseName": "OrderRejectedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRejectedEvent.attributeTypeMap;
    }
}

/**
* Order summary
*/
export class OrderSummary {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: OrderSummary.DeliveryTypeEnum;
    /**
    * Order state
    */
    'OrderState'?: OrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone'?: string;
    /**
    * Name of the customer
    */
    'CustomerName'?: string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber'?: string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Payment Account
    */
    'PaymentAccountType'?: OrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: OrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency'?: OrderSummary.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "OrderSummary.DeliveryTypeEnum"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "OrderSummary.OrderStateEnum"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreIanaTimeZone",
            "baseName": "StoreIanaTimeZone",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "CustomerPhoneNumber",
            "baseName": "CustomerPhoneNumber",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "OrderSummary.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "OrderSummary.PaymentStatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "OrderSummary.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderSummary.attributeTypeMap;
    }
}

export namespace OrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Order Tip Update Event
*/
export class OrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Tip Amount
    */
    'TipAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher summary
*/
export class OrderVoucherSummary {
    /**
    * Voucher name
    */
    'Name'?: string;
    /**
    * Voucher description
    */
    'Description'?: string;
    /**
    * Voucher code
    */
    'Code'?: string;
    /**
    * Voucher amount
    */
    'Amount'?: number;
    /**
    * Voucher type
    */
    'Type'?: OrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType'?: OrderVoucherSummary.SubTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "OrderVoucherSummary.TypeEnum"
        },
        {
            "name": "SubType",
            "baseName": "SubType",
            "type": "OrderVoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderVoucherSummary.attributeTypeMap;
    }
}

export namespace OrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Password reset model
*/
export class PasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "PasswordConfirmation",
            "baseName": "PasswordConfirmation",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetModel.attributeTypeMap;
    }
}

/**
* Pay order
*/
export class PayOrder {
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PaymentOption': PayOrder.PaymentOptionEnum;
    /**
    * Chef note
    */
    'ChefNote'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PaymentOption",
            "baseName": "PaymentOption",
            "type": "PayOrder.PaymentOptionEnum"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayOrder.attributeTypeMap;
    }
}

export namespace PayOrder {
    export enum PaymentOptionEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Percent discount details
*/
export class PercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PercentageDiscount",
            "baseName": "PercentageDiscount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PercentDiscountDetails.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId'?: number;
    /**
    * Time of the call
    */
    'TimeOfCall'?: Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal'?: Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId'?: number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName'?: string;
    /**
    * Name of the caller
    */
    'CallerName'?: string;
    /**
    * UserID of the caller
    */
    'CallerUserId'?: number;
    /**
    * Phone number of the caller
    */
    'CallerNumber'?: string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds'?: number;
    /**
    * The status of the call
    */
    'CallStatus'?: PhoneCall.CallStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneCallId",
            "baseName": "PhoneCallId",
            "type": "number"
        },
        {
            "name": "TimeOfCall",
            "baseName": "TimeOfCall",
            "type": "Date"
        },
        {
            "name": "TimeOfCallLocal",
            "baseName": "TimeOfCallLocal",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "CallerName",
            "baseName": "CallerName",
            "type": "string"
        },
        {
            "name": "CallerUserId",
            "baseName": "CallerUserId",
            "type": "number"
        },
        {
            "name": "CallerNumber",
            "baseName": "CallerNumber",
            "type": "string"
        },
        {
            "name": "CallLengthInSeconds",
            "baseName": "CallLengthInSeconds",
            "type": "number"
        },
        {
            "name": "CallStatus",
            "baseName": "CallStatus",
            "type": "PhoneCall.CallStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCall.attributeTypeMap;
    }
}

export namespace PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Phone call ended event
*/
export class PhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallEndedEvent.attributeTypeMap;
    }
}

/**
* Phone call started event
*/
export class PhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallStartedEvent.attributeTypeMap;
    }
}

/**
* Predefined answer
*/
export class PredefinedAnswer {
    /**
    * Identifier
    */
    'Id'?: number;
    /**
    * Text
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredefinedAnswer.attributeTypeMap;
    }
}

/**
* Printer
*/
export class Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber'?: string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "LastPollTime",
            "baseName": "LastPollTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Printer.attributeTypeMap;
    }
}

/**
* Printer assigned to store event
*/
export class PrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterAssignedToStoreEvent.attributeTypeMap;
    }
}

/**
* Printer turned off event
*/
export class PrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOffEvent.attributeTypeMap;
    }
}

/**
* Printer turned on event
*/
export class PrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOnEvent.attributeTypeMap;
    }
}

/**
* Printer assigned from store event
*/
export class PrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterUnassignedFromStoreEvent.attributeTypeMap;
    }
}

/**
* Processing fee config
*/
export class ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee'?: number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "ProcessingFeeConfig.PaymentAccountTypeEnum"
        },
        {
            "name": "PercentFee",
            "baseName": "PercentFee",
            "type": "number"
        },
        {
            "name": "FixedFee",
            "baseName": "FixedFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessingFeeConfig.attributeTypeMap;
    }
}

export namespace ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps'
    }
}
/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class Range {
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Day of week
    */
    'DayOfWeek'?: Range.DayOfWeekEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* 
*/
export class RedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: RedeemInvitationResult.InvitationStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "RedeemInvitationResult.InvitationStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return RedeemInvitationResult.attributeTypeMap;
    }
}

export namespace RedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* Refund
*/
export class Refund {
    /**
    * Refund reason
    */
    'RefundReason'?: string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If ture, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RefundReason",
            "baseName": "RefundReason",
            "type": "string"
        },
        {
            "name": "RefundAmount",
            "baseName": "RefundAmount",
            "type": "number"
        },
        {
            "name": "NotifyCustomer",
            "baseName": "NotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

/**
* Reject
*/
export class Reject {
    /**
    * Reject reason.
    */
    'RejectReason': Reject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RejectReason",
            "baseName": "RejectReason",
            "type": "Reject.RejectReasonEnum"
        },
        {
            "name": "DoNotNotifyCustomer",
            "baseName": "DoNotNotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Reject.attributeTypeMap;
    }
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Request login PIN response
*/
export class RequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class RequestLoginPinResposne {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LoginPinSentViaEmail",
            "baseName": "LoginPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinResposne.attributeTypeMap;
    }
}

/**
* 
*/
export class RequestPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetModel.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmCurrencyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmHourlyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmHourlyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmHourlyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmHourlyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBankAccountSummary {
    /**
    * Generic data object.
    */
    'Data': Array<BankAccountSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BankAccountSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBankAccountSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': Array<DeliveryZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DeliveryZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultHomeAction {
    /**
    * Generic data object.
    */
    'Data': Array<HomeAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HomeAction>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultHomeAction.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocalisedTimeZone {
    /**
    * Generic data object.
    */
    'Data': Array<LocalisedTimeZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocalisedTimeZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuCheckpoint {
    /**
    * Generic data object.
    */
    'Data': Array<MenuCheckpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuCheckpoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuCheckpoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuStoreNames {
    /**
    * Generic data object.
    */
    'Data': Array<MenuStoreNames>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuStoreNames>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuStoreNames.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSummary {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': Array<OAuthApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthApp>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': Array<OauthClientRedirectUri>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<ProcessingFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ProcessingFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestApiDefaultResponse {
    /**
    * Generic data object.
    */
    'Data': Array<RestApiDefaultResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<StoreStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreStatistics.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Array<Teammate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Teammate>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultVoucherDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<VoucherDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultVoucherDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultWebhookSubscription {
    /**
    * Generic data object.
    */
    'Data': Array<WebhookSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultWebhookSubscription.attributeTypeMap;
    }
}

/**
* Rest api default response
*/
export class RestApiDefaultResponse {
    /**
    * Data string
    */
    'Data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api error result
*/
export class RestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Stack trace
    */
    'StackTrace'?: string;
    /**
    * List of errors grouped by field name
    */
    'Errors'?: Array<ValidationErrorResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "StackTrace",
            "baseName": "StackTrace",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<ValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiErrorResult.attributeTypeMap;
    }
}

/**
* 
*/
export class RestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': EventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "EventSearchResult"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

/**
* Rest Api Forbidden Result
*/
export class RestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiForbiddenResult.attributeTypeMap;
    }
}

/**
* Rest api integer result
*/
export class RestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultApp {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<App>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<App>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultApp.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultBusinessHoursOverride {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursOverride>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHttpRequestAndResponseLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HttpRequestAndResponseLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOAuthTokenModel {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OAuthTokenModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOAuthTokenModel.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Order>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Order>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrderSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OrderSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrderSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPhoneCall {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PhoneCall>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PhoneCall>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPhoneCall.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStore {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Store>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Store>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStore.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroup>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroupExtended {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroupExtended>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroupExtended>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroupExtended.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultVoucherSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<VoucherSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultVoucherSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookLog.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountDetail {
    /**
    * Generic data object.
    */
    'Data': AccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatistics {
    /**
    * Generic data object.
    */
    'Data': ApmStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAssignedBankAccount {
    /**
    * Generic data object.
    */
    'Data': AssignedBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AssignedBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAssignedBankAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBankAccountDetail {
    /**
    * Generic data object.
    */
    'Data': BankAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BankAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBankAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursOverride {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursOverride;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursOverride"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursPeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursPeriod"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCard {
    /**
    * Generic data object.
    */
    'Data': Card;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Card"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCard.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCoordinates {
    /**
    * Generic data object.
    */
    'Data': Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCoordinates.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': DeliveryZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DeliveryZone"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHomeStatistics {
    /**
    * Generic data object.
    */
    'Data': HomeStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HomeStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHomeStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraConfig {
    /**
    * Generic data object.
    */
    'Data': HydraConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraStatus {
    /**
    * Generic data object.
    */
    'Data': HydraStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultJobResponse {
    /**
    * Generic data object.
    */
    'Data': JobResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "JobResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultJobResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLightspeedSettings {
    /**
    * Generic data object.
    */
    'Data': LightspeedSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LightspeedSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLightspeedSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenu {
    /**
    * Generic data object.
    */
    'Data': Menu;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Menu"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenu.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSetItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': MenuSection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSection"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionAvailability {
    /**
    * Generic data object.
    */
    'Data': MenuSectionAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionAvailability"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionAvailability.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': MenuSectionItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Metadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Metadata"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': OAuthApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OAuthApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': OauthClientRedirectUri;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrder {
    /**
    * Generic data object.
    */
    'Data': Order;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrder.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': ProcessingFeeConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ProcessingFeeConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRedeemInvitationResult {
    /**
    * Generic data object.
    */
    'Data': RedeemInvitationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RedeemInvitationResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRedeemInvitationResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStore {
    /**
    * Generic data object.
    */
    'Data': Store;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Store"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStore.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreAddress {
    /**
    * Generic data object.
    */
    'Data': StoreAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreAddress"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreAddress.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroup {
    /**
    * Generic data object.
    */
    'Data': StoreGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroup"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroupBase {
    /**
    * Generic data object.
    */
    'Data': StoreGroupBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroupBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroupBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStuartSettings {
    /**
    * Generic data object.
    */
    'Data': StuartSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StuartSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStuartSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultSubscription {
    /**
    * Generic data object.
    */
    'Data': Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultSubscription.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultSubscriptionPlansResponse {
    /**
    * Generic data object.
    */
    'Data': SubscriptionPlansResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "SubscriptionPlansResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultSubscriptionPlansResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Teammate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Teammate"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultVoucherWithStats {
    /**
    * Generic data object.
    */
    'Data': VoucherWithStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "VoucherWithStats"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultVoucherWithStats.attributeTypeMap;
    }
}

/**
* Rest api string array result
*/
export class RestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringArrayResult.attributeTypeMap;
    }
}

/**
* Rest api string result
*/
export class RestApiStringResult {
    /**
    * Data string
    */
    'Data': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringResult.attributeTypeMap;
    }
}

/**
* Rest api unauthorized result
*/
export class RestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiUnauthorizedResult.attributeTypeMap;
    }
}

/**
* RetentionCampaign
*/
export class RetentionCampaign {
    /**
    * Date and time of campaign beginning
    */
    'From'?: Date;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaign.attributeTypeMap;
    }
}

/**
* Retention campaign created event
*/
export class RetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign deleted event
*/
export class RetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign updated event
*/
export class RetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Search Criteria for Audit Logs
*/
export class SearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit'?: number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page'?: number;
    /**
    * Start date
    */
    'Start'?: Date;
    /**
    * End date
    */
    'End'?: Date;
    /**
    * Events that have Order Id
    */
    'OrderId'?: number;
    /**
    * Events that have Store Id
    */
    'StoreId'?: number;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Events that have User Id
    */
    'UserId'?: number;
    /**
    * Events that have User Email
    */
    'UserEmail'?: string;
    /**
    * Events that have User Name
    */
    'UserName'?: string;
    /**
    * Events that have voucher code
    */
    'VoucherCode'?: string;
    /**
    * Events that have event type\\s
    */
    'EventType'?: Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "Array<string>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCriteria.attributeTypeMap;
    }
}

/**
* Set password with PIN model
*/
export class SetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SetPasswordWithPinModel.attributeTypeMap;
    }
}

/**
* 
*/
export class SignupStep {
    /**
    * Action needs to take
    */
    'Action'?: SignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question'?: string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers'?: Array<PredefinedAnswer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Action",
            "baseName": "Action",
            "type": "SignupStep.ActionEnum"
        },
        {
            "name": "Question",
            "baseName": "Question",
            "type": "string"
        },
        {
            "name": "PredefinedAnswers",
            "baseName": "PredefinedAnswers",
            "type": "Array<PredefinedAnswer>"
        }    ];

    static getAttributeTypeMap() {
        return SignupStep.attributeTypeMap;
    }
}

export namespace SignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription'
    }
}
/**
* Sms Info
*/
export class SmsInfo {
    /**
    * Origin phone number
    */
    'From'?: string;
    /**
    * Destination phone number
    */
    'To'?: string;
    /**
    * Text message
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "string"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "string"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsInfo.attributeTypeMap;
    }
}

/**
* Sms received event
*/
export class SmsReceivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The sms info
    */
    'SmsInfo'?: SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SmsInfo",
            "baseName": "SmsInfo",
            "type": "SmsInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsReceivedEvent.attributeTypeMap;
    }
}

/**
* A single currency data point, with no date
*/
export class StatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency'?: StatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount'?: number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount'?: number;
    /**
    * Value of orders for this currency
    */
    'OrderValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StatisticsCurrencyDataPoint.CurrencyEnum"
        },
        {
            "name": "UserCount",
            "baseName": "UserCount",
            "type": "number"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StatisticsCurrencyDataPoint.attributeTypeMap;
    }
}

export namespace StatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store
*/
export class Store {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId'?: number;
    /**
    * Store address
    */
    'Address'?: StoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones'?: Array<DeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber'?: string;
    /**
    * Pickup hours
    */
    'PickupHours'?: Array<BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours'?: Array<BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery'?: string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup'?: string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType'?: Store.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes'?: Array<StoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone'?: string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone'?: string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency'?: Store.CurrencyEnum;
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communcation with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "StoreAddress"
        },
        {
            "name": "DeliveryZones",
            "baseName": "DeliveryZones",
            "type": "Array<DeliveryZone>"
        },
        {
            "name": "ApmPhoneNumber",
            "baseName": "ApmPhoneNumber",
            "type": "string"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "DeliveryHours",
            "baseName": "DeliveryHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "OrderConfirmationMessageOverrideDelivery",
            "baseName": "OrderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "OrderConfirmationMessageOverridePickup",
            "baseName": "OrderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "PrintoutLayoutType",
            "baseName": "PrintoutLayoutType",
            "type": "Store.PrintoutLayoutTypeEnum"
        },
        {
            "name": "StoreNotes",
            "baseName": "StoreNotes",
            "type": "Array<StoreNote>"
        },
        {
            "name": "MicrosoftTimeZone",
            "baseName": "MicrosoftTimeZone",
            "type": "string"
        },
        {
            "name": "IanaTimeZone",
            "baseName": "IanaTimeZone",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Store.CurrencyEnum"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Store.attributeTypeMap;
    }
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store address
*/
export class StoreAddress {
    /**
    * Address identifier
    */
    'AddressId'?: number;
    /**
    * Coordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressId",
            "baseName": "AddressId",
            "type": "number"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddress.attributeTypeMap;
    }
}

/**
* Store address base
*/
export class StoreAddressBase {
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressBase.attributeTypeMap;
    }
}

/**
* Store Address Updated Event
*/
export class StoreAddressUpdatedEvent {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store address
    */
    'StoreAddress'?: StoreAddress;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreAddress",
            "baseName": "StoreAddress",
            "type": "StoreAddress"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Base
*/
export class StoreBase {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communcation with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBase.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Created
*/
export class StoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Deleted
*/
export class StoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideDeletedEvent.attributeTypeMap;
    }
}

/**
* Settings for cloning a store
*/
export class StoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TargetStoreGroupId",
            "baseName": "TargetStoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreCloneSettings.attributeTypeMap;
    }
}

/**
* Store Create Base
*/
export class StoreCreateBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communcation with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreateBase.attributeTypeMap;
    }
}

/**
* Store Created Event
*/
export class StoreCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which created this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Data Point
*/
export class StoreDataPoint {
    /**
    * Day
    */
    'Day'?: Date;
    /**
    * Value for the day
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "Date"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDataPoint.attributeTypeMap;
    }
}

/**
* Store Deleted Event
*/
export class StoreDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group
*/
export class StoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroup.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroup.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroup.attributeTypeMap;
    }
}

export namespace StoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Update Store Group
*/
export class StoreGroupBase {
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupBase.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupBase.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupBase.attributeTypeMap;
    }
}

export namespace StoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store Group Created Event
*/
export class StoreGroupCreatedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Group Deleted Event
*/
export class StoreGroupDeletedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Extended
*/
export class StoreGroupExtended {
    /**
    * Total Amount of Stores
    */
    'TotalStores'?: number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates'?: Array<GroupedCoordinates>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupExtended.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalStores",
            "baseName": "TotalStores",
            "type": "number"
        },
        {
            "name": "GroupedCoordinates",
            "baseName": "GroupedCoordinates",
            "type": "Array<GroupedCoordinates>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupExtended.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupExtended.attributeTypeMap;
    }
}

export namespace StoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store Group Updated Event
*/
export class StoreGroupUpdatedEvent {
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store note
*/
export class StoreNote {
    /**
    * User identifier
    */
    'UserId'?: number;
    /**
    * Create time
    */
    'CreateTime'?: Date;
    /**
    * Note
    */
    'Note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Note",
            "baseName": "Note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreNote.attributeTypeMap;
    }
}

/**
* Store Opening Hours Updated Event
*/
export class StoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated opening hours for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store statistics
*/
export class StoreStatistics {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Data Points
    */
    'Data'?: Array<StoreDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return StoreStatistics.attributeTypeMap;
    }
}

/**
* Store summary
*/
export class StoreSummary {
    /**
    * Store identifier
    */
    'Id'?: number;
    /**
    * Store name
    */
    'Name'?: string;
    /**
    * Stores menu identifier
    */
    'MenuId'?: number;
    /**
    * Store metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency'?: StoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates'?: Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreSummary.CurrencyEnum"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return StoreSummary.attributeTypeMap;
    }
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Store Updated Event
*/
export class StoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUpdatedEvent.attributeTypeMap;
    }
}

/**
* Stuart settings
*/
export class StuartSettings {
    /**
    * Client Id
    */
    'ClientId'?: string;
    /**
    * Client Secret
    */
    'ClientSecret'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication'?: string;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime'?: number;
    /**
    * PackageType
    */
    'PackageType'?: StuartSettings.PackageTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "ClientSecret",
            "baseName": "ClientSecret",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "WebhookUrlBasicAuthentication",
            "baseName": "WebhookUrlBasicAuthentication",
            "type": "string"
        },
        {
            "name": "MinutesToPickupBeforeThanDeliveryTime",
            "baseName": "MinutesToPickupBeforeThanDeliveryTime",
            "type": "number"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "StuartSettings.PackageTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettings.attributeTypeMap;
    }
}

export namespace StuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
}
/**
* Subscription
*/
export class Subscription {
    /**
    * The subscription identifier
    */
    'SubscriptionId'?: number;
    /**
    * Starting date of the subscription
    */
    'StartDate'?: Date;
    /**
    * Status of the subscription (TrialPeriod, Ongoing, Unpaid, Canceled)
    */
    'Status'?: Subscription.StatusEnum;
    /**
    * Flipdish user identifier
    */
    'UserId'?: number;
    /**
    * Subscription Plan
    */
    'SubscriptionPlan'?: SubscriptionPlan;
    /**
    * Card
    */
    'Card'?: Card;
    /**
    * App name Id of the subscription
    */
    'AppId': string;
    /**
    * Last 4 digits of the card
    */
    'VatNumber'?: string;
    /**
    * Expiry date of the card
    */
    'VatCountryCode': string;
    /**
    * Number of physical restaurants
    */
    'Quantity'?: number;
    /**
    * Subscription plan identifier
    */
    'SubscriptionPlanId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SubscriptionId",
            "baseName": "SubscriptionId",
            "type": "number"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Subscription.StatusEnum"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "SubscriptionPlan",
            "baseName": "SubscriptionPlan",
            "type": "SubscriptionPlan"
        },
        {
            "name": "Card",
            "baseName": "Card",
            "type": "Card"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "VatCountryCode",
            "baseName": "VatCountryCode",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "SubscriptionPlanId",
            "baseName": "SubscriptionPlanId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

export namespace Subscription {
    export enum StatusEnum {
        TrialPeriod = <any> 'TrialPeriod',
        Ongoing = <any> 'Ongoing',
        Unpaid = <any> 'Unpaid',
        Canceled = <any> 'Canceled'
    }
}
/**
* Subscription Base
*/
export class SubscriptionBase {
    /**
    * Number of physical restaurants
    */
    'Quantity'?: number;
    /**
    * Subscription plan identifier
    */
    'SubscriptionPlanId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "SubscriptionPlanId",
            "baseName": "SubscriptionPlanId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionBase.attributeTypeMap;
    }
}

/**
* Subscription plan
*/
export class SubscriptionPlan {
    /**
    * Subscription plan identifier
    */
    'SubscriptionPlanId'?: number;
    /**
    * Name of the plan
    */
    'Name'?: string;
    /**
    * ISO Currency
    */
    'Currency'?: string;
    /**
    * Price for single unit
    */
    'Price'?: number;
    /**
    * Interval billing for the subscription
    */
    'Interval'?: SubscriptionPlan.IntervalEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SubscriptionPlanId",
            "baseName": "SubscriptionPlanId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "Interval",
            "baseName": "Interval",
            "type": "SubscriptionPlan.IntervalEnum"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPlan.attributeTypeMap;
    }
}

export namespace SubscriptionPlan {
    export enum IntervalEnum {
        Monthly = <any> 'Monthly',
        Yearly = <any> 'Yearly'
    }
}
/**
* Available plans and mandatory fields to subscribe
*/
export class SubscriptionPlansResponse {
    /**
    * Stripe publishable api key
    */
    'PublishableApiKey'?: string;
    /**
    * User email
    */
    'Email'?: string;
    /**
    * Available plans
    */
    'SubscriptionPlans'?: Array<SubscriptionPlan>;
    /**
    * App ids (string name) to which the user belongs
    */
    'AppIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PublishableApiKey",
            "baseName": "PublishableApiKey",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SubscriptionPlans",
            "baseName": "SubscriptionPlans",
            "type": "Array<SubscriptionPlan>"
        },
        {
            "name": "AppIds",
            "baseName": "AppIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPlansResponse.attributeTypeMap;
    }
}

/**
* Subscription Base + token
*/
export class SubscriptionWithToken {
    /**
    * Token
    */
    'Token': string;
    /**
    * Number of physical restaurants
    */
    'Quantity': number;
    /**
    * Subscription plan identifier
    */
    'SubscriptionPlanId': number;
    /**
    * App name Id of the subscription
    */
    'AppId': string;
    /**
    * Last 4 digits of the card
    */
    'VatNumber'?: string;
    /**
    * Expiry date of the card
    */
    'VatCountryCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "SubscriptionPlanId",
            "baseName": "SubscriptionPlanId",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "VatCountryCode",
            "baseName": "VatCountryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionWithToken.attributeTypeMap;
    }
}

/**
* 
*/
export class Teammate {
    /**
    * Unique indentifier
    */
    'TeammateId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Last activity
    */
    'LastAcitivity'?: Date;
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: Teammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: Teammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TeammateId",
            "baseName": "TeammateId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "LastAcitivity",
            "baseName": "LastAcitivity",
            "type": "Date"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "Teammate.InvitationStatusEnum"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "Teammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return Teammate.attributeTypeMap;
    }
}

export namespace Teammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel'?: TeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "TeammateBase.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TeammateBase.attributeTypeMap;
    }
}

export namespace TeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
}
/**
* 
*/
export class TeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who deleted the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who accepted the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteAcceptedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who sent the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who updated the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateUpdatedEvent.attributeTypeMap;
    }
}

/**
* User created event
*/
export class UserCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserCreatedEvent.attributeTypeMap;
    }
}

/**
* User deleted event
*/
export class UserDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDeletedEvent.attributeTypeMap;
    }
}

/**
* User Event Info
*/
export class UserEventInfo {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * User Email
    */
    'UserEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserEventInfo.attributeTypeMap;
    }
}

/**
* User login event
*/
export class UserLoginEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserLoginEvent.attributeTypeMap;
    }
}

/**
* User updated event
*/
export class UserUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdatedEvent.attributeTypeMap;
    }
}

/**
* Validation error result
*/
export class ValidationErrorResult {
    /**
    * Field name
    */
    'FieldName'?: string;
    /**
    * List of errors relates to field
    */
    'Errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FieldName",
            "baseName": "FieldName",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ValidationErrorResult.attributeTypeMap;
    }
}

/**
* Voucher
*/
export class Voucher {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: Voucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: Voucher.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: Voucher.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: Voucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Voucher.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "Voucher.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "Voucher.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Voucher.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Voucher.attributeTypeMap;
    }
}

export namespace Voucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Voucher Base
*/
export class VoucherBase {
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherBase.attributeTypeMap;
    }
}

/**
* Voucher Created Event
*/
export class VoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which created this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherCreatedEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class VoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDataPoint.attributeTypeMap;
    }
}

/**
* Voucher Deleted Event
*/
export class VoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which deleted this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDeletedEvent.attributeTypeMap;
    }
}

/**
* Voucher Summary
*/
export class VoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Status
    */
    'Status'?: VoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherSummary.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherSummary.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherSummary.VoucherSubTypeEnum"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VoucherSummary.attributeTypeMap;
    }
}

export namespace VoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Updated Event
*/
export class VoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which updated this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher With Statistics
*/
export class VoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed'?: number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers'?: number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders'?: number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted'?: number;
    /**
    * Average Order Size
    */
    'AverageOrderSize'?: number;
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: VoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherWithStats.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherWithStats.VoucherSubTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: VoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Add item details
    */
    'AddItemDetails'?: AddItemDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalUsed",
            "baseName": "TotalUsed",
            "type": "number"
        },
        {
            "name": "TotalCustomers",
            "baseName": "TotalCustomers",
            "type": "number"
        },
        {
            "name": "TotalAmountFromOrders",
            "baseName": "TotalAmountFromOrders",
            "type": "number"
        },
        {
            "name": "TotalDiscounted",
            "baseName": "TotalDiscounted",
            "type": "number"
        },
        {
            "name": "AverageOrderSize",
            "baseName": "AverageOrderSize",
            "type": "number"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherWithStats.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherWithStats.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherWithStats.VoucherSubTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "VoucherWithStats.CurrencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AddItemDetails",
            "baseName": "AddItemDetails",
            "type": "AddItemDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return VoucherWithStats.attributeTypeMap;
    }
}

export namespace VoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
/**
* Webhook log
*/
export class WebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId'?: number;
    /**
    * Event created
    */
    'EventCreated'?: string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered'?: string;
    /**
    * Webhook event name
    */
    'WebhookEventName'?: string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl'?: string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode'?: string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus'?: string;
    /**
    * Request headers
    */
    'RequestHeaders'?: string;
    /**
    * Request body
    */
    'RequestBody'?: string;
    /**
    * Received response headers
    */
    'ResponseHeaders'?: string;
    /**
    * Received response body
    */
    'ResponseBody'?: string;
    /**
    * Duration of HTTP request
    */
    'Duration'?: string;
    /**
    * Retry count
    */
    'RetryCount'?: number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId'?: string;
    /**
    * Flipdish webhook version
    */
    'Version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebhookSubscriptionOwnerUserId",
            "baseName": "WebhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "EventCreated",
            "baseName": "EventCreated",
            "type": "string"
        },
        {
            "name": "WebhookTriggered",
            "baseName": "WebhookTriggered",
            "type": "string"
        },
        {
            "name": "WebhookEventName",
            "baseName": "WebhookEventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionCallbackUrl",
            "baseName": "WebhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "HttpResponseStatusCode",
            "baseName": "HttpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "HttpResponseStatus",
            "baseName": "HttpResponseStatus",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "string"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "string"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "string"
        },
        {
            "name": "RetryCount",
            "baseName": "RetryCount",
            "type": "number"
        },
        {
            "name": "FlipdishWebhookId",
            "baseName": "FlipdishWebhookId",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

/**
* Webhook subscription
*/
export class WebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version'?: string;
    /**
    * Webhook subscription event names
    */
    'EventNames'?: Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl'?: string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled'?: boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "EventNames",
            "baseName": "EventNames",
            "type": "Array<string>"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "VerifyToken",
            "baseName": "VerifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscription.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId'?: number;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Webhook callback url
    */
    'CallbackUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "WebhookSubscriptionId",
            "baseName": "WebhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "ApmHourlyDataPoint.DayEnum": ApmHourlyDataPoint.DayEnum,
        "App.AppAccessLevelEnum": App.AppAccessLevelEnum,
        "App.AppResourceSetEnum": App.AppResourceSetEnum,
        "BankAccount.AccountStateEnum": BankAccount.AccountStateEnum,
        "BankAccountCreate.CurrencyCodeEnum": BankAccountCreate.CurrencyCodeEnum,
        "BankAccountDetail.AccountStateEnum": BankAccountDetail.AccountStateEnum,
        "BankAccountDetail.CurrencyCodeEnum": BankAccountDetail.CurrencyCodeEnum,
        "BankAccountSummary.AccountStateEnum": BankAccountSummary.AccountStateEnum,
        "BusinessHoursOverride.DeliveryTypeEnum": BusinessHoursOverride.DeliveryTypeEnum,
        "BusinessHoursOverride.TypeEnum": BusinessHoursOverride.TypeEnum,
        "BusinessHoursOverrideBase.DeliveryTypeEnum": BusinessHoursOverrideBase.DeliveryTypeEnum,
        "BusinessHoursOverrideBase.TypeEnum": BusinessHoursOverrideBase.TypeEnum,
        "BusinessHoursPeriod.DayOfWeekEnum": BusinessHoursPeriod.DayOfWeekEnum,
        "BusinessHoursPeriodBase.DayOfWeekEnum": BusinessHoursPeriodBase.DayOfWeekEnum,
        "CreateTeammate.AppAccessLevelEnum": CreateTeammate.AppAccessLevelEnum,
        "CreateVoucher.VoucherTypeEnum": CreateVoucher.VoucherTypeEnum,
        "CurrencyData.CurrencyEnum": CurrencyData.CurrencyEnum,
        "HomeAction.HomeActionTypeEnum": HomeAction.HomeActionTypeEnum,
        "HydraConfig.PaymentOptionsEnum": HydraConfig.PaymentOptionsEnum,
        "LightspeedSettings.PriceTypeEnum": LightspeedSettings.PriceTypeEnum,
        "Menu.MenuSectionBehaviourEnum": Menu.MenuSectionBehaviourEnum,
        "MenuBase.MenuSectionBehaviourEnum": MenuBase.MenuSectionBehaviourEnum,
        "MenuItemOptionSet.CellLayoutTypeEnum": MenuItemOptionSet.CellLayoutTypeEnum,
        "MenuItemOptionSetBase.CellLayoutTypeEnum": MenuItemOptionSetBase.CellLayoutTypeEnum,
        "MenuItemOptionSetItem.CellLayoutTypeEnum": MenuItemOptionSetItem.CellLayoutTypeEnum,
        "MenuItemOptionSetItemBase.CellLayoutTypeEnum": MenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "MenuSectionAvailability.AvailabilityModeEnum": MenuSectionAvailability.AvailabilityModeEnum,
        "MenuSectionAvailabilityBase.AvailabilityModeEnum": MenuSectionAvailabilityBase.AvailabilityModeEnum,
        "MenuSectionItem.SpicinessRatingEnum": MenuSectionItem.SpicinessRatingEnum,
        "MenuSectionItem.CellLayoutTypeEnum": MenuSectionItem.CellLayoutTypeEnum,
        "MenuSectionItemBase.SpicinessRatingEnum": MenuSectionItemBase.SpicinessRatingEnum,
        "MenuSectionItemBase.CellLayoutTypeEnum": MenuSectionItemBase.CellLayoutTypeEnum,
        "Order.DeliveryTypeEnum": Order.DeliveryTypeEnum,
        "Order.PickupLocationTypeEnum": Order.PickupLocationTypeEnum,
        "Order.PaymentAccountTypeEnum": Order.PaymentAccountTypeEnum,
        "Order.OrderStateEnum": Order.OrderStateEnum,
        "Order.AppTypeEnum": Order.AppTypeEnum,
        "Order.PaymentStatusEnum": Order.PaymentStatusEnum,
        "Order.RejectionReasonEnum": Order.RejectionReasonEnum,
        "OrderSummary.DeliveryTypeEnum": OrderSummary.DeliveryTypeEnum,
        "OrderSummary.OrderStateEnum": OrderSummary.OrderStateEnum,
        "OrderSummary.PaymentAccountTypeEnum": OrderSummary.PaymentAccountTypeEnum,
        "OrderSummary.PaymentStatusEnum": OrderSummary.PaymentStatusEnum,
        "OrderSummary.CurrencyEnum": OrderSummary.CurrencyEnum,
        "OrderVoucherSummary.TypeEnum": OrderVoucherSummary.TypeEnum,
        "OrderVoucherSummary.SubTypeEnum": OrderVoucherSummary.SubTypeEnum,
        "PayOrder.PaymentOptionEnum": PayOrder.PaymentOptionEnum,
        "PhoneCall.CallStatusEnum": PhoneCall.CallStatusEnum,
        "ProcessingFeeConfig.PaymentAccountTypeEnum": ProcessingFeeConfig.PaymentAccountTypeEnum,
        "Range.DayOfWeekEnum": Range.DayOfWeekEnum,
        "RedeemInvitationResult.InvitationStatusEnum": RedeemInvitationResult.InvitationStatusEnum,
        "Reject.RejectReasonEnum": Reject.RejectReasonEnum,
        "SignupStep.ActionEnum": SignupStep.ActionEnum,
        "StatisticsCurrencyDataPoint.CurrencyEnum": StatisticsCurrencyDataPoint.CurrencyEnum,
        "Store.PrintoutLayoutTypeEnum": Store.PrintoutLayoutTypeEnum,
        "Store.CurrencyEnum": Store.CurrencyEnum,
        "StoreGroup.CurrencyEnum": StoreGroup.CurrencyEnum,
        "StoreGroupBase.CurrencyEnum": StoreGroupBase.CurrencyEnum,
        "StoreGroupExtended.CurrencyEnum": StoreGroupExtended.CurrencyEnum,
        "StoreSummary.CurrencyEnum": StoreSummary.CurrencyEnum,
        "StuartSettings.PackageTypeEnum": StuartSettings.PackageTypeEnum,
        "Subscription.StatusEnum": Subscription.StatusEnum,
        "SubscriptionPlan.IntervalEnum": SubscriptionPlan.IntervalEnum,
        "Teammate.InvitationStatusEnum": Teammate.InvitationStatusEnum,
        "Teammate.AppAccessLevelEnum": Teammate.AppAccessLevelEnum,
        "TeammateBase.AppAccessLevelEnum": TeammateBase.AppAccessLevelEnum,
        "Voucher.StatusEnum": Voucher.StatusEnum,
        "Voucher.VoucherTypeEnum": Voucher.VoucherTypeEnum,
        "Voucher.VoucherSubTypeEnum": Voucher.VoucherSubTypeEnum,
        "Voucher.CurrencyEnum": Voucher.CurrencyEnum,
        "VoucherSummary.StatusEnum": VoucherSummary.StatusEnum,
        "VoucherSummary.VoucherTypeEnum": VoucherSummary.VoucherTypeEnum,
        "VoucherSummary.VoucherSubTypeEnum": VoucherSummary.VoucherSubTypeEnum,
        "VoucherWithStats.StatusEnum": VoucherWithStats.StatusEnum,
        "VoucherWithStats.VoucherTypeEnum": VoucherWithStats.VoucherTypeEnum,
        "VoucherWithStats.VoucherSubTypeEnum": VoucherWithStats.VoucherSubTypeEnum,
        "VoucherWithStats.CurrencyEnum": VoucherWithStats.CurrencyEnum,
}

let typeMap: {[index: string]: any} = {
    "Accept": Accept,
    "AccountDetail": AccountDetail,
    "AccountDetailBase": AccountDetailBase,
    "AddItemDetails": AddItemDetails,
    "AnalyticsClientEvent": AnalyticsClientEvent,
    "ApmCurrencyDataPoint": ApmCurrencyDataPoint,
    "ApmDataPoint": ApmDataPoint,
    "ApmHourlyDataPoint": ApmHourlyDataPoint,
    "ApmStatistics": ApmStatistics,
    "App": App,
    "AppCreatedEvent": AppCreatedEvent,
    "AppUpdatedEvent": AppUpdatedEvent,
    "AssignedBankAccount": AssignedBankAccount,
    "BankAccount": BankAccount,
    "BankAccountCreate": BankAccountCreate,
    "BankAccountCreatedEvent": BankAccountCreatedEvent,
    "BankAccountDeletedEvent": BankAccountDeletedEvent,
    "BankAccountDetail": BankAccountDetail,
    "BankAccountSummary": BankAccountSummary,
    "BankAccountUpdatedEvent": BankAccountUpdatedEvent,
    "BusinessHoursOverride": BusinessHoursOverride,
    "BusinessHoursOverrideBase": BusinessHoursOverrideBase,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "BusinessHoursPeriodBase": BusinessHoursPeriodBase,
    "Card": Card,
    "CardBase": CardBase,
    "CardWithToken": CardWithToken,
    "ChangePasswordModel": ChangePasswordModel,
    "Coordinates": Coordinates,
    "CreateAccountModel": CreateAccountModel,
    "CreateTeammate": CreateTeammate,
    "CreateVoucher": CreateVoucher,
    "CreditNoteDetails": CreditNoteDetails,
    "CurrencyData": CurrencyData,
    "CustomerConsentUpdatedEvent": CustomerConsentUpdatedEvent,
    "CustomerCreatedEvent": CustomerCreatedEvent,
    "CustomerSummary": CustomerSummary,
    "CustomerUpdatedEvent": CustomerUpdatedEvent,
    "DeliveryLocation": DeliveryLocation,
    "DeliveryZone": DeliveryZone,
    "DeliveryZoneBase": DeliveryZoneBase,
    "DeliveryZoneCreatedEvent": DeliveryZoneCreatedEvent,
    "DeliveryZoneDeletedEvent": DeliveryZoneDeletedEvent,
    "DeliveryZoneUpdatedEvent": DeliveryZoneUpdatedEvent,
    "DeviceSettings": DeviceSettings,
    "EventSearchResult": EventSearchResult,
    "FeeSummary": FeeSummary,
    "GroupedCoordinates": GroupedCoordinates,
    "HomeAction": HomeAction,
    "HomeStatistics": HomeStatistics,
    "HttpRequestAndResponseLog": HttpRequestAndResponseLog,
    "HydraConfig": HydraConfig,
    "HydraRegistration": HydraRegistration,
    "HydraStatus": HydraStatus,
    "JobAddress": JobAddress,
    "JobCancellation": JobCancellation,
    "JobContact": JobContact,
    "JobDelivery": JobDelivery,
    "JobDeliveryDetail": JobDeliveryDetail,
    "JobDriver": JobDriver,
    "JobEta": JobEta,
    "JobPricing": JobPricing,
    "JobProof": JobProof,
    "JobResponse": JobResponse,
    "Language": Language,
    "LightspeedSettings": LightspeedSettings,
    "LocalisedTimeZone": LocalisedTimeZone,
    "LoginModel": LoginModel,
    "LoginWithPinModel": LoginWithPinModel,
    "LoyaltyCampaign": LoyaltyCampaign,
    "LoyaltyCampaignCreatedEvent": LoyaltyCampaignCreatedEvent,
    "LoyaltyCampaignDeletedEvent": LoyaltyCampaignDeletedEvent,
    "LoyaltyCampaignUpdatedEvent": LoyaltyCampaignUpdatedEvent,
    "LumpDiscountDetails": LumpDiscountDetails,
    "Menu": Menu,
    "MenuBase": MenuBase,
    "MenuCheckpoint": MenuCheckpoint,
    "MenuCreatedEvent": MenuCreatedEvent,
    "MenuItemOptionSet": MenuItemOptionSet,
    "MenuItemOptionSetBase": MenuItemOptionSetBase,
    "MenuItemOptionSetCreatedEvent": MenuItemOptionSetCreatedEvent,
    "MenuItemOptionSetDeletedEvent": MenuItemOptionSetDeletedEvent,
    "MenuItemOptionSetItem": MenuItemOptionSetItem,
    "MenuItemOptionSetItemBase": MenuItemOptionSetItemBase,
    "MenuItemOptionSetItemCreatedEvent": MenuItemOptionSetItemCreatedEvent,
    "MenuItemOptionSetItemDeletedEvent": MenuItemOptionSetItemDeletedEvent,
    "MenuItemOptionSetItemUpdatedEvent": MenuItemOptionSetItemUpdatedEvent,
    "MenuItemOptionSetUpdatedEvent": MenuItemOptionSetUpdatedEvent,
    "MenuSection": MenuSection,
    "MenuSectionAvailability": MenuSectionAvailability,
    "MenuSectionAvailabilityBase": MenuSectionAvailabilityBase,
    "MenuSectionBase": MenuSectionBase,
    "MenuSectionCreatedEvent": MenuSectionCreatedEvent,
    "MenuSectionDeletedEvent": MenuSectionDeletedEvent,
    "MenuSectionItem": MenuSectionItem,
    "MenuSectionItemBase": MenuSectionItemBase,
    "MenuSectionItemCreatedEvent": MenuSectionItemCreatedEvent,
    "MenuSectionItemDeletedEvent": MenuSectionItemDeletedEvent,
    "MenuSectionItemUpdatedEvent": MenuSectionItemUpdatedEvent,
    "MenuSectionUpdatedEvent": MenuSectionUpdatedEvent,
    "MenuStoreNames": MenuStoreNames,
    "MenuSummary": MenuSummary,
    "MenuUpdatedEvent": MenuUpdatedEvent,
    "Metadata": Metadata,
    "OAuthApp": OAuthApp,
    "OAuthTokenModel": OAuthTokenModel,
    "OauthClientRedirectUri": OauthClientRedirectUri,
    "Order": Order,
    "OrderAcceptedEvent": OrderAcceptedEvent,
    "OrderCreatedEvent": OrderCreatedEvent,
    "OrderDispatchedEvent": OrderDispatchedEvent,
    "OrderItem": OrderItem,
    "OrderItemOption": OrderItemOption,
    "OrderRatingUpdatedEvent": OrderRatingUpdatedEvent,
    "OrderRefundedEvent": OrderRefundedEvent,
    "OrderRejectedEvent": OrderRejectedEvent,
    "OrderSummary": OrderSummary,
    "OrderTipUpdatedEvent": OrderTipUpdatedEvent,
    "OrderVoucherSummary": OrderVoucherSummary,
    "PasswordResetModel": PasswordResetModel,
    "PayOrder": PayOrder,
    "PercentDiscountDetails": PercentDiscountDetails,
    "PhoneCall": PhoneCall,
    "PhoneCallEndedEvent": PhoneCallEndedEvent,
    "PhoneCallStartedEvent": PhoneCallStartedEvent,
    "PredefinedAnswer": PredefinedAnswer,
    "Printer": Printer,
    "PrinterAssignedToStoreEvent": PrinterAssignedToStoreEvent,
    "PrinterTurnedOffEvent": PrinterTurnedOffEvent,
    "PrinterTurnedOnEvent": PrinterTurnedOnEvent,
    "PrinterUnassignedFromStoreEvent": PrinterUnassignedFromStoreEvent,
    "ProcessingFeeConfig": ProcessingFeeConfig,
    "Range": Range,
    "RedeemInvitationResult": RedeemInvitationResult,
    "Refund": Refund,
    "Reject": Reject,
    "RequestLoginPinModel": RequestLoginPinModel,
    "RequestLoginPinResposne": RequestLoginPinResposne,
    "RequestPasswordResetModel": RequestPasswordResetModel,
    "RestApiArrayResultApmCurrencyDataPoint": RestApiArrayResultApmCurrencyDataPoint,
    "RestApiArrayResultApmDataPoint": RestApiArrayResultApmDataPoint,
    "RestApiArrayResultApmHourlyDataPoint": RestApiArrayResultApmHourlyDataPoint,
    "RestApiArrayResultBankAccountSummary": RestApiArrayResultBankAccountSummary,
    "RestApiArrayResultBusinessHoursPeriod": RestApiArrayResultBusinessHoursPeriod,
    "RestApiArrayResultDeliveryZone": RestApiArrayResultDeliveryZone,
    "RestApiArrayResultHomeAction": RestApiArrayResultHomeAction,
    "RestApiArrayResultLocalisedTimeZone": RestApiArrayResultLocalisedTimeZone,
    "RestApiArrayResultMenuCheckpoint": RestApiArrayResultMenuCheckpoint,
    "RestApiArrayResultMenuItemOptionSet": RestApiArrayResultMenuItemOptionSet,
    "RestApiArrayResultMenuItemOptionSetItem": RestApiArrayResultMenuItemOptionSetItem,
    "RestApiArrayResultMenuSection": RestApiArrayResultMenuSection,
    "RestApiArrayResultMenuSectionItem": RestApiArrayResultMenuSectionItem,
    "RestApiArrayResultMenuStoreNames": RestApiArrayResultMenuStoreNames,
    "RestApiArrayResultMenuSummary": RestApiArrayResultMenuSummary,
    "RestApiArrayResultMetadata": RestApiArrayResultMetadata,
    "RestApiArrayResultOAuthApp": RestApiArrayResultOAuthApp,
    "RestApiArrayResultOauthClientRedirectUri": RestApiArrayResultOauthClientRedirectUri,
    "RestApiArrayResultProcessingFeeConfig": RestApiArrayResultProcessingFeeConfig,
    "RestApiArrayResultRestApiDefaultResponse": RestApiArrayResultRestApiDefaultResponse,
    "RestApiArrayResultStoreStatistics": RestApiArrayResultStoreStatistics,
    "RestApiArrayResultTeammate": RestApiArrayResultTeammate,
    "RestApiArrayResultVoucherDataPoint": RestApiArrayResultVoucherDataPoint,
    "RestApiArrayResultWebhookSubscription": RestApiArrayResultWebhookSubscription,
    "RestApiDefaultResponse": RestApiDefaultResponse,
    "RestApiErrorResult": RestApiErrorResult,
    "RestApiEventSearchPaginationResult": RestApiEventSearchPaginationResult,
    "RestApiForbiddenResult": RestApiForbiddenResult,
    "RestApiIntegerResult": RestApiIntegerResult,
    "RestApiPaginationResultApp": RestApiPaginationResultApp,
    "RestApiPaginationResultBusinessHoursOverride": RestApiPaginationResultBusinessHoursOverride,
    "RestApiPaginationResultHttpRequestAndResponseLog": RestApiPaginationResultHttpRequestAndResponseLog,
    "RestApiPaginationResultOAuthTokenModel": RestApiPaginationResultOAuthTokenModel,
    "RestApiPaginationResultOrder": RestApiPaginationResultOrder,
    "RestApiPaginationResultOrderSummary": RestApiPaginationResultOrderSummary,
    "RestApiPaginationResultPhoneCall": RestApiPaginationResultPhoneCall,
    "RestApiPaginationResultStore": RestApiPaginationResultStore,
    "RestApiPaginationResultStoreGroup": RestApiPaginationResultStoreGroup,
    "RestApiPaginationResultStoreGroupExtended": RestApiPaginationResultStoreGroupExtended,
    "RestApiPaginationResultVoucherSummary": RestApiPaginationResultVoucherSummary,
    "RestApiPaginationResultWebhookLog": RestApiPaginationResultWebhookLog,
    "RestApiResultAccountDetail": RestApiResultAccountDetail,
    "RestApiResultApmStatistics": RestApiResultApmStatistics,
    "RestApiResultAssignedBankAccount": RestApiResultAssignedBankAccount,
    "RestApiResultBankAccountDetail": RestApiResultBankAccountDetail,
    "RestApiResultBusinessHoursOverride": RestApiResultBusinessHoursOverride,
    "RestApiResultBusinessHoursPeriod": RestApiResultBusinessHoursPeriod,
    "RestApiResultCard": RestApiResultCard,
    "RestApiResultCoordinates": RestApiResultCoordinates,
    "RestApiResultDeliveryZone": RestApiResultDeliveryZone,
    "RestApiResultHomeStatistics": RestApiResultHomeStatistics,
    "RestApiResultHydraConfig": RestApiResultHydraConfig,
    "RestApiResultHydraStatus": RestApiResultHydraStatus,
    "RestApiResultJobResponse": RestApiResultJobResponse,
    "RestApiResultLightspeedSettings": RestApiResultLightspeedSettings,
    "RestApiResultMenu": RestApiResultMenu,
    "RestApiResultMenuItemOptionSet": RestApiResultMenuItemOptionSet,
    "RestApiResultMenuItemOptionSetItem": RestApiResultMenuItemOptionSetItem,
    "RestApiResultMenuSection": RestApiResultMenuSection,
    "RestApiResultMenuSectionAvailability": RestApiResultMenuSectionAvailability,
    "RestApiResultMenuSectionItem": RestApiResultMenuSectionItem,
    "RestApiResultMetadata": RestApiResultMetadata,
    "RestApiResultOAuthApp": RestApiResultOAuthApp,
    "RestApiResultOauthClientRedirectUri": RestApiResultOauthClientRedirectUri,
    "RestApiResultOrder": RestApiResultOrder,
    "RestApiResultProcessingFeeConfig": RestApiResultProcessingFeeConfig,
    "RestApiResultRedeemInvitationResult": RestApiResultRedeemInvitationResult,
    "RestApiResultStore": RestApiResultStore,
    "RestApiResultStoreAddress": RestApiResultStoreAddress,
    "RestApiResultStoreGroup": RestApiResultStoreGroup,
    "RestApiResultStoreGroupBase": RestApiResultStoreGroupBase,
    "RestApiResultStuartSettings": RestApiResultStuartSettings,
    "RestApiResultSubscription": RestApiResultSubscription,
    "RestApiResultSubscriptionPlansResponse": RestApiResultSubscriptionPlansResponse,
    "RestApiResultTeammate": RestApiResultTeammate,
    "RestApiResultVoucherWithStats": RestApiResultVoucherWithStats,
    "RestApiStringArrayResult": RestApiStringArrayResult,
    "RestApiStringResult": RestApiStringResult,
    "RestApiUnauthorizedResult": RestApiUnauthorizedResult,
    "RetentionCampaign": RetentionCampaign,
    "RetentionCampaignCreatedEvent": RetentionCampaignCreatedEvent,
    "RetentionCampaignDeletedEvent": RetentionCampaignDeletedEvent,
    "RetentionCampaignUpdatedEvent": RetentionCampaignUpdatedEvent,
    "SearchCriteria": SearchCriteria,
    "SetPasswordWithPinModel": SetPasswordWithPinModel,
    "SignupStep": SignupStep,
    "SmsInfo": SmsInfo,
    "SmsReceivedEvent": SmsReceivedEvent,
    "StatisticsCurrencyDataPoint": StatisticsCurrencyDataPoint,
    "Store": Store,
    "StoreAddress": StoreAddress,
    "StoreAddressBase": StoreAddressBase,
    "StoreAddressUpdatedEvent": StoreAddressUpdatedEvent,
    "StoreBase": StoreBase,
    "StoreBusinessHoursOverrideCreatedEvent": StoreBusinessHoursOverrideCreatedEvent,
    "StoreBusinessHoursOverrideDeletedEvent": StoreBusinessHoursOverrideDeletedEvent,
    "StoreCloneSettings": StoreCloneSettings,
    "StoreCreateBase": StoreCreateBase,
    "StoreCreatedEvent": StoreCreatedEvent,
    "StoreDataPoint": StoreDataPoint,
    "StoreDeletedEvent": StoreDeletedEvent,
    "StoreGroup": StoreGroup,
    "StoreGroupBase": StoreGroupBase,
    "StoreGroupCreatedEvent": StoreGroupCreatedEvent,
    "StoreGroupDeletedEvent": StoreGroupDeletedEvent,
    "StoreGroupExtended": StoreGroupExtended,
    "StoreGroupUpdatedEvent": StoreGroupUpdatedEvent,
    "StoreNote": StoreNote,
    "StoreOpeningHoursUpdatedEvent": StoreOpeningHoursUpdatedEvent,
    "StoreStatistics": StoreStatistics,
    "StoreSummary": StoreSummary,
    "StoreUpdatedEvent": StoreUpdatedEvent,
    "StuartSettings": StuartSettings,
    "Subscription": Subscription,
    "SubscriptionBase": SubscriptionBase,
    "SubscriptionPlan": SubscriptionPlan,
    "SubscriptionPlansResponse": SubscriptionPlansResponse,
    "SubscriptionWithToken": SubscriptionWithToken,
    "Teammate": Teammate,
    "TeammateBase": TeammateBase,
    "TeammateDeletedEvent": TeammateDeletedEvent,
    "TeammateInviteAcceptedEvent": TeammateInviteAcceptedEvent,
    "TeammateInviteSentEvent": TeammateInviteSentEvent,
    "TeammateUpdatedEvent": TeammateUpdatedEvent,
    "UserCreatedEvent": UserCreatedEvent,
    "UserDeletedEvent": UserDeletedEvent,
    "UserEventInfo": UserEventInfo,
    "UserLoginEvent": UserLoginEvent,
    "UserUpdatedEvent": UserUpdatedEvent,
    "ValidationErrorResult": ValidationErrorResult,
    "Voucher": Voucher,
    "VoucherBase": VoucherBase,
    "VoucherCreatedEvent": VoucherCreatedEvent,
    "VoucherDataPoint": VoucherDataPoint,
    "VoucherDeletedEvent": VoucherDeletedEvent,
    "VoucherSummary": VoucherSummary,
    "VoucherUpdatedEvent": VoucherUpdatedEvent,
    "VoucherWithStats": VoucherWithStats,
    "WebhookLog": WebhookLog,
    "WebhookSubscription": WebhookSubscription,
    "WebhookSubscriptionCreatedEvent": WebhookSubscriptionCreatedEvent,
    "WebhookSubscriptionDeletedEvent": WebhookSubscriptionDeletedEvent,
    "WebhookSubscriptionEventInfo": WebhookSubscriptionEventInfo,
    "WebhookSubscriptionUpdatedEvent": WebhookSubscriptionUpdatedEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Answer a signup question
     * @param signupStepAction Signup step action
     * @param answerId Identifier of the answer
     * @param {*} [options] Override http request options.
     */
    public answerSignUpQuestion (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', answerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerId, "number")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePassword (changePasswordModel: ChangePasswordModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "ChangePasswordModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change password
     * @param changePasswordModel Change password model
     * @param {*} [options] Override http request options.
     */
    public changePasswordWithPin (changePasswordModel: SetPasswordWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "SetPasswordWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create account with email address and store name
     * @param createAccountModel Create account model
     * @param {*} [options] Override http request options.
     */
    public createAccount (createAccountModel: CreateAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAccountModel, "CreateAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current account detail
     * @param {*} [options] Override http request options.
     */
    public getAccountDetails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get timezones localised to users language
     * @param {*} [options] Override http request options.
     */
    public getLocalisedTimeZones (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocalisedTimeZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public login (loginModel: LoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login with username and password
     * @param loginModel Login model
     * @param {*} [options] Override http request options.
     */
    public loginWithPin (loginModel: LoginWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log out. It removes Flipdish authorization Cookie.
     * @param {*} [options] Override http request options.
     */
    public logout (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset password with token.
     * @param passwordResetModel Password reset model
     * @param {*} [options] Override http request options.
     */
    public passwordResetWithToken (passwordResetModel: PasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordResetModel, "PasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request login PIN. The server sends the PIN to the email address.
     * @param requestLoginPinRequest Request login PIN request
     * @param {*} [options] Override http request options.
     */
    public requestLoginPin (requestLoginPinRequest: RequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestLoginPinRequest, "RequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestLoginPinResposne;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestLoginPinResposne");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request password reset. Flipdish system will send a token via email.
     * @param requestPasswordResetModel Request password reset model
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (requestPasswordResetModel: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetModel, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Skip a signup question
     * @param signupStepAction Signup step action
     * @param {*} [options] Override http request options.
     */
    public skipSignupStep (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update account with name and language
     * @param updateAccountModel Update account model
     * @param {*} [options] Override http request options.
     */
    public updateAccount (updateAccountModel: AccountDetailBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAccountModel, "AccountDetailBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        (this.authentications as any)[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Get Basic Statistics
     * @param appId App Name
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calendar statistics
     * @param appId App Name
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmHourlyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Calls Statistics
     * @param appId App Name
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getCallsStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Order Statistics (Value of Orders)
     * @param appId App Name
     * @param aggregateDataBy Aggregate data by day \\ week
     * @param dataPointLimit Amount of data points per request
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getOrderStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmCurrencyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get paginated APM call list
     * @param appId App Name
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeId List of stores to search by
     * @param {*} [options] Override http request options.
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPhoneCall");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        (this.authentications as any)[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get Apps
     * @param nameFilter 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getApps (nameFilter?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (nameFilter !== undefined) {
            localVarQueryParameters['nameFilter'] = ObjectSerializer.serialize(nameFilter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get authorization tokens
     * @param oauthAppId Client identifier
     * @param appId 
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOAuthTokenModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke token
     * @param key Token identifier key
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public revokeToken (key: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Attach Bank Account to Store
     * @param appId App Name
     * @param accountId Id of account to be updated
     * @param storeId Store to be attached to Bank account
     * @param {*} [options] Override http request options.
     */
    public attachBankAccountToStore (appId: string, accountId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{accountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Create a new Bank Account and attach to this App
     * @param appId App Name
     * @param account Account to be created
     * @param {*} [options] Override http request options.
     */
    public createBankAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Delete BankAccount
     * @param appId App Name
     * @param id Id of account to be marked as deleted
     * @param {*} [options] Override http request options.
     */
    public deleteBankAccount (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get BankAccount Detail by Id
     * @param id Id of account
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccount (id: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBankAccount.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get List of BankAccounts for WL
     * @param appId App Name
     * @param {*} [options] Override http request options.
     */
    public getBankAccounts (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBankAccountSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update BankAccount
     * @param appId App Name
     * @param id Id of account to be updated
     * @param account Details to update account with
     * @param {*} [options] Override http request options.
     */
    public updateBankAccount (appId: string, id: number, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Update State of Bank Account
     * @param appId App Name
     * @param accountId Id of account to be updated
     * @param state 
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountState (appId: string, accountId: number, state: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{accountId}/state/{state}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a delivery zone to the store id
     * @param storeId Store Id to which the delivery zone will be added
     * @param deliveryZoneBase Optional delivery zone, if not supplied will create a default zone
     * @param {*} [options] Override http request options.
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZoneBase, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the delivery zones associated with a store
     * @param storeId Store Id to which the delivery zones are associated
     * @param {*} [options] Override http request options.
     */
    public getDeliveryZones (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be removed
     * @param {*} [options] Override http request options.
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the existing delivery zone
     * @param storeId Store Id to which the delivery zone belongs
     * @param deliveryZoneId Delivery zone id to be updated
     * @param deliveryZone Delta of delivery zone parameters that need to be changed
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZone, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get customer events  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events  For technical reasons, the number of records returned is limited to 100.
     * @param storeId Store Id
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getEvents (storeId?: number, whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event by Id  For technical reasons, the number of records returned is limited to 100.
     * @param eventId Event identifier (Guid)
     * @param {*} [options] Override http request options.
     */
    public getEventsById (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu events  For technical reasons, the number of records returned is limited to 100.
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events  For technical reasons, the number of records returned is limited to 100.
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId2 !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId2, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events by customer  For technical reasons, the number of records returned is limited to 100.
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store events  For technical reasons, the number of records returned is limited to 100.
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user events  For technical reasons, the number of records returned is limited to 100.
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId2?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId2 !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId2, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get WhiteLabel events  For technical reasons, the number of records returned is limited to 100.
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeGroupId?: number, userId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        (this.authentications as any)[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        (this.authentications as any)[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Complete Home Action
     * @param appId App Name Id
     * @param homeActionId Id of the action
     * @param isDismissed 
     * @param {*} [options] Override http request options.
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'homeActionId' + '}', encodeURIComponent(String(homeActionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            localVarQueryParameters['isDismissed'] = ObjectSerializer.serialize(isDismissed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Actions
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeActions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultHomeAction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get Home Statistics
     * @param appId App Name Id
     * @param {*} [options] Override http request options.
     */
    public getHomeStatistics (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHomeStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get API interaction logs
     * @param start Start date time
     * @param end End date time
     * @param appId 
     * @param filterByUserId User id (optional)
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHttpRequestAndResponseLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        (this.authentications as any)[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRegistration (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param {*} [options] Override http request options.
     */
    public getSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public login (deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param orderId 
     * @param payOrder 
     * @param {*} [options] Override http request options.
     */
    public payOrder (orderId: number, payOrder: PayOrder, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/payorder/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling payOrder.');
        }

        // verify required parameter 'payOrder' is not null or undefined
        if (payOrder === null || payOrder === undefined) {
            throw new Error('Required parameter payOrder was null or undefined when calling payOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payOrder, "PayOrder")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [Private]
     * @param hydraRegistration 
     * @param {*} [options] Override http request options.
     */
    public register (hydraRegistration: HydraRegistration, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hydraRegistration, "HydraRegistration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        (this.authentications as any)[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGenerateMenu (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGetStoreSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param lightspeedSettings 
     * @param {*} [options] Override http request options.
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: LightspeedSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lightspeedSettings, "LightspeedSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     * @param {*} [options] Override http request options.
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     * @param {*} [options] Override http request options.
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItems (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek 
     * @param businessHoursPeriod 
     * @param {*} [options] Override http request options.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'dayOfWeek' + '}', encodeURIComponent(String(dayOfWeek)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     * @param {*} [options] Override http request options.
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability 
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: MenuSectionAvailabilityBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionAvailability, "MenuSectionAvailabilityBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSectionById (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSections (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API]Clone a menu, (without attaching stores)
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public createDraftMenuFromExistingMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Create a new menu
     * @param appId App identifier
     * @param {*} [options] Override http request options.
     */
    public createNewMenuForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Mark a Menu as Deleted
     * @param menuId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public deleteMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuImage (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuById (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus store names
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuStoreNames (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuStoreNames");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get menus by appId
     * @param appId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public getMenusByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Get a Menus Checkpoints
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenusCheckpoints (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuCheckpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Restore a Menu to a checkpoint
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     * @param {*} [options] Override http request options.
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'checkpointId' + '}', encodeURIComponent(String(checkpointId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Lock/Unlock a Menu for Editing
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     * @param {*} [options] Override http request options.
     */
    public setMenuLock (menuId: number, locked: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locked, "boolean")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API]Set Menus Name
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     * @param {*} [options] Override http request options.
     */
    public setMenuName (menuId: number, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenu (menuId: number, menu: MenuBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "MenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuImage (menuId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uri Redirect uri
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OAuth App
     * @param oAuthApp OAuth App
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createOAuthApp (oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteOAuthApp (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all OAuth Apps
     * @param appId 
     * @param oauthAppName 
     * @param {*} [options] Override http request options.
     */
    public getOAuthApps (appId: string, oauthAppName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            localVarQueryParameters['oauthAppName'] = ObjectSerializer.serialize(oauthAppName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App by identifier
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App secret key
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth access token for App
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOauthAccessToken (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth App redirect uris
     * @param oauthAppId OAuth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRedirectUris (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public oAuthClientsGetApplications (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth App redirect uri
     * @param oauthAppId OAuth App identifier
     * @param uriId Redirect uri identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * To accept an order, you create an `accept` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Accept order
     * @param id Order identifier
     * @param acceptObject 
     * @param {*} [options] Override http request options.
     */
    public acceptOrder (id: number, acceptObject: Accept, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "Accept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To dispatch an order send a POST request with `Id` path parameter which identifies the order.
     * @summary Dispatch order
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public dispatchOrder (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order by ID
     * @param id Order identifier
     * @param {*} [options] Override http request options.
     */
    public getOrderById (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orders by filter
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get summary of orders by filter
     * @param appId App Name Id
     * @param searchQuery Query string
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrderSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To refund an order, you create a `refund` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Refund order
     * @param id Order identifier
     * @param refundObject 
     * @param {*} [options] Override http request options.
     */
    public refundOrder (id: number, refundObject: Refund, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "Refund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To reject an order, you create a `reject` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Reject order
     * @param id Order identifier
     * @param rejectObject 
     * @param {*} [options] Override http request options.
     */
    public rejectOrder (id: number, rejectObject: Reject, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "Reject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        (this.authentications as any)[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get processing fee configs by store identifiers
     * @param storeIds Store identifiers
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        (this.authentications as any)[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a Store Group  It will be attached to an existing App
     * @param appNameId App Name Id
     * @param storeGroup Store group definition
     * @param {*} [options] Override http request options.
     */
    public createStoreGroup (appNameId: string, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a Store Groups
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a paginated list of Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Returns a paginated list of Extended Store Groups
     * @param appNameId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param groupingRadius 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (groupingRadius !== undefined) {
            localVarQueryParameters['groupingRadius'] = ObjectSerializer.serialize(groupingRadius, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroupExtended");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a Store Group  Can only remove a store group if there is no stores attached to the group
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public removeStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Store Group
     * @param storeGroupId Store Group Id
     * @param storeGroup Store Group Delta
     * @param {*} [options] Override http request options.
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroupBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone store with store clone settings
     * @param storeId Store identifier
     * @param settings Settings for cloning the store
     * @param {*} [options] Override http request options.
     */
    public cloneStore (storeId: number, settings: StoreCloneSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "StoreCloneSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create Business Hours Override for a store
     * @param storeId Store identifier
     * @param businessHoursOverride Business Hours Override
     * @param {*} [options] Override http request options.
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: BusinessHoursOverrideBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursOverride, "BusinessHoursOverrideBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create store with Store Group identifier
     * @param storeGroupId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public createStore (storeGroupId: number, store: StoreCreateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreCreateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Business Hours Override for a store
     * @param storeId 
     * @param businessHoursOverrideId 
     * @param {*} [options] Override http request options.
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'businessHoursOverrideId' + '}', encodeURIComponent(String(businessHoursOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Stores Bank Account Id
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getBankAccount (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAssignedBankAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Bussiness hours
     * @param storeId Store identifier
     * @param deliveryType Deliery type
     * @param {*} [options] Override http request options.
     */
    public getBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get business hours overrides by store identifier
     * @param storeId Store identifier
     * @param after Return results that ended after this datetime. Default value is the current datetime.
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get processing fee configs by store identifier
     * @param storeId Store identifier
     * @param paymentAccountType 
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: 'Card' | 'Cash' | 'Ideal' | 'Bancontact' | 'Giropay' | 'Eps', appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'paymentAccountType' + '}', encodeURIComponent(String(paymentAccountType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store by identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getStoreById (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreNetSales (appId: string, storeId: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param storeGroupId Store Group Id
     * @param {*} [options] Override http request options.
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores by app name id
     * @param appId App Name Id
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     * @param {*} [options] Override http request options.
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Bussiness hours
     * @param storeId Store identifier
     * @param deliveryType Deliery type
     * @param businessHoursPeriod Business Hours Period
     * @param {*} [options] Override http request options.
     */
    public setBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store by identifier
     * @param storeId Store Group identifier
     * @param store Store
     * @param {*} [options] Override http request options.
     */
    public updateStore (storeId: number, store: StoreBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address
     * @param storeId Store identifier
     * @param storeAddress Store address
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddress (storeId: number, storeAddress: StoreAddressBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeAddress, "StoreAddressBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreAddress");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update store address coordinates
     * @param storeId Store identifier
     * @param coordinates Store address coordinates
     * @param appNameId App Name Id(Not used, still here for compatability reasons)
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: Coordinates, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coordinates, "Coordinates")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCoordinates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        (this.authentications as any)[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param jobId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartCancelJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param jobId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartGetJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultJobResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get stuart credentials
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartGetStuartSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStuartSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param stuartSettings 
     * @param {*} [options] Override http request options.
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: StuartSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stuartSettings, "StuartSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsApiApiKeys {
}

export class SubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Cancel the subscription
     * @param subscriptionId Subscription identifier
     * @param {*} [options] Override http request options.
     */
    public subscriptionsCancelSubscription (subscriptionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsCancelSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the card linked to the subscription
     * @param subscriptionId Subscription identifier
     * @param {*} [options] Override http request options.
     */
    public subscriptionsGetCard (subscriptionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCard;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}/card'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsGetCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get avaialble plans for currency's user
     * @param {*} [options] Override http request options.
     */
    public subscriptionsGetPlansByCurrency (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubscriptionPlansResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubscriptionPlansResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubscriptionPlansResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the subscription including the payment history
     * @param subscriptionId Subscription Identifier
     * @param {*} [options] Override http request options.
     */
    public subscriptionsGetSubscription (subscriptionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsGetSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get subscription by appId
     * @param appId The string app identifier
     * @param {*} [options] Override http request options.
     */
    public subscriptionsGetUserSubscriptionByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling subscriptionsGetUserSubscriptionByAppId.');
        }

        if (appId !== undefined) {
            localVarQueryParameters['appId'] = ObjectSerializer.serialize(appId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new card and replace the old one
     * @param subscriptionId Subscription identifier
     * @param card Token Id
     * @param {*} [options] Override http request options.
     */
    public subscriptionsReplaceOldCardWithNewCard (subscriptionId: number, card: CardWithToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}/card/new'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsReplaceOldCardWithNewCard.');
        }

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling subscriptionsReplaceOldCardWithNewCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(card, "CardWithToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new subscription
     * @param subscription Data necessary to create a new subscription
     * @param {*} [options] Override http request options.
     */
    public subscriptionsSubscribe (subscription: SubscriptionWithToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscription' is not null or undefined
        if (subscription === null || subscription === undefined) {
            throw new Error('Required parameter subscription was null or undefined when calling subscriptionsSubscribe.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscription, "SubscriptionWithToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update card expiring date
     * @param subscriptionId Subscription identifier
     * @param card Data to update card expiring date
     * @param {*} [options] Override http request options.
     */
    public subscriptionsUpdateCardExpiringDate (subscriptionId: number, card: CardBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCard;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}/card'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsUpdateCardExpiringDate.');
        }

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling subscriptionsUpdateCardExpiringDate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(card, "CardBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the subscription
     * @param subscriptionId Subscription identifier
     * @param subscription Data to update the subscription
     * @param {*} [options] Override http request options.
     */
    public subscriptionsUpdateSubscription (subscriptionId: number, subscription: SubscriptionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/subscriptions/{subscriptionId}'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling subscriptionsUpdateSubscription.');
        }

        // verify required parameter 'subscription' is not null or undefined
        if (subscription === null || subscription === undefined) {
            throw new Error('Required parameter subscription was null or undefined when calling subscriptionsUpdateSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscription, "SubscriptionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        (this.authentications as any)[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create teammate and send an invite.
     * @param appId 
     * @param teammate 
     * @param {*} [options] Override http request options.
     */
    public createTeammate (appId: string, teammate: CreateTeammate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "CreateTeammate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete teammate
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteTeammate (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a teammates by email address
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all teammates
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getTeammatesByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param otc 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public redeemInvitation (otc: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', encodeURIComponent(String(otc)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRedeemInvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update teammates (this method does not support Deltas!)
     * @param appId 
     * @param id 
     * @param teammate 
     * @param {*} [options] Override http request options.
     */
    public updateTeammate (appId: string, id: string, teammate: TeammateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "TeammateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get role names
     * @param {*} [options] Override http request options.
     */
    public getRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary [PRIVATE API] Create voucher
     * @param appId App Name Id
     * @param voucher Voucher Details
     * @param {*} [options] Override http request options.
     */
    public createVoucher (appId: string, voucher: CreateVoucher, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "CreateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher by identifier
     * @param voucherId Id of the voucher
     * @param {*} [options] Override http request options.
     */
    public getVoucherById (voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get voucher stats by identifier
     * @param voucherId Id of the voucher
     * @param aggregateDataBy Aggregate data by day \\ week \\ month
     * @param dataPointLimit Amount of data points per request
     * @param {*} [options] Override http request options.
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            localVarQueryParameters['aggregateDataBy'] = ObjectSerializer.serialize(aggregateDataBy, "'Daily' | 'Weekly' | 'Monthly'");
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultVoucherDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Get vouchers summaries for App Id
     * @param appId Application Id
     * @param pageIndex Page Number
     * @param pageSize Page Size
     * @param searchCodes Search by Voucher Code\\s
     * @param statusSearch Search by Status
     * @param typeSearch Search by Type
     * @param subTypeSearch Search by Sub Type
     * @param storeIds Search by Store Ids
     * @param {*} [options] Override http request options.
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>, typeSearch?: Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>, subTypeSearch?: Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchCodes !== undefined) {
            localVarQueryParameters['searchCodes'] = ObjectSerializer.serialize(searchCodes, "Array<string>");
        }

        if (statusSearch !== undefined) {
            localVarQueryParameters['statusSearch'] = ObjectSerializer.serialize(statusSearch, "Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>");
        }

        if (typeSearch !== undefined) {
            localVarQueryParameters['typeSearch'] = ObjectSerializer.serialize(typeSearch, "Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote'>");
        }

        if (subTypeSearch !== undefined) {
            localVarQueryParameters['subTypeSearch'] = ObjectSerializer.serialize(subTypeSearch, "Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultVoucherSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary [PRIVATE API] Updates voucher
     * @param voucherId Id of the voucher
     * @param voucher Updated details for the voucher
     * @param storeId 
     * @param percentValue Percent voucher value (can have 1 of 3)
     * @param lumpValue Lump voucher value (can have 1 of 3)
     * @param freeItemId Free Item Id (can have 1 of 3)
     * @param {*} [options] Override http request options.
     */
    public updateVoucher (voucherId: number, voucher: VoucherBase, storeId?: Array<number>, percentValue?: number, lumpValue?: number, freeItemId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (percentValue !== undefined) {
            localVarQueryParameters['percentValue'] = ObjectSerializer.serialize(percentValue, "number");
        }

        if (lumpValue !== undefined) {
            localVarQueryParameters['lumpValue'] = ObjectSerializer.serialize(lumpValue, "number");
        }

        if (freeItemId !== undefined) {
            localVarQueryParameters['freeItemId'] = ObjectSerializer.serialize(freeItemId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "VoucherBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a webhook subscription for you Oauth App
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public craeteWebhookSubscription (oauthAppId: string, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling craeteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete you webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove event name to your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscription event names
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNames (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your webhook subscriptions selected event names
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs for your webhook subscription
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param appId 
     * @param page Page number
     * @param limit Page size
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscriptions by your Oauth App id
     * @param oauthAppId Oauth App identifier
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultWebhookSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultWebhookSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook subscription object
     * @param oauthAppId Oauth App identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
