/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Accept {
    'estimatedMinutesForDelivery': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimatedMinutesForDelivery",
            "baseName": "estimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Accept.attributeTypeMap;
    }
}

export class BusinessHoursPeriod {
    'dayOfWeek': BusinessHoursPeriod.DayOfWeekEnum;
    'startTime': string;
    'period': string;
    'startTimeEarly': string;
    'periodEarly': string;
    'early': Range;
    'late': Range;
    'ranges': Array<Range>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dayOfWeek",
            "baseName": "dayOfWeek",
            "type": "BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "string"
        },
        {
            "name": "startTimeEarly",
            "baseName": "startTimeEarly",
            "type": "string"
        },
        {
            "name": "periodEarly",
            "baseName": "periodEarly",
            "type": "string"
        },
        {
            "name": "early",
            "baseName": "early",
            "type": "Range"
        },
        {
            "name": "late",
            "baseName": "late",
            "type": "Range"
        },
        {
            "name": "ranges",
            "baseName": "ranges",
            "type": "Array<Range>"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
export class CampaignCreatedEvent {
    'campaignId': number;
    'virtualRestaurantName': string;
    'virtualRestaurantId': number;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "virtualRestaurantName",
            "baseName": "virtualRestaurantName",
            "type": "string"
        },
        {
            "name": "virtualRestaurantId",
            "baseName": "virtualRestaurantId",
            "type": "number"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignCreatedEvent.attributeTypeMap;
    }
}

export class Coordinates {
    'latitude': number;
    'longitude': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

export class CustomerConsentUpdatedEvent {
    'enabled': boolean;
    'description': string;
    'user': UserEventInfo;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

export class CustomerCreatedEvent {
    'whiteLabelId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "whiteLabelId",
            "baseName": "whiteLabelId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreatedEvent.attributeTypeMap;
    }
}

export class CustomerSummary {
    'id': number;
    'name': string;
    'emailAddress': string;
    'phoneNumberLocalFormat': string;
    'phoneNumber': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "phoneNumberLocalFormat",
            "baseName": "phoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSummary.attributeTypeMap;
    }
}

export class CustomerUpdatedEvent {
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdatedEvent.attributeTypeMap;
    }
}

export class DeliveryFeeArea {
    'deliveryFee': number;
    'minimumDeliveryOrder': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deliveryFee",
            "baseName": "deliveryFee",
            "type": "number"
        },
        {
            "name": "minimumDeliveryOrder",
            "baseName": "minimumDeliveryOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryFeeArea.attributeTypeMap;
    }
}

export class DeliveryLocation {
    'coordinates': Coordinates;
    'building': string;
    'street': string;
    'town': string;
    'postCode': string;
    'deliveryInstructions': string;
    'prettyAddressString': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "coordinates",
            "baseName": "coordinates",
            "type": "Coordinates"
        },
        {
            "name": "building",
            "baseName": "building",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "town",
            "baseName": "town",
            "type": "string"
        },
        {
            "name": "postCode",
            "baseName": "postCode",
            "type": "string"
        },
        {
            "name": "deliveryInstructions",
            "baseName": "deliveryInstructions",
            "type": "string"
        },
        {
            "name": "prettyAddressString",
            "baseName": "prettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryLocation.attributeTypeMap;
    }
}

export class EventSearchResult {
    'orderAcceptedEvent': Array<OrderAcceptedEvent>;
    'orderCreatedEvent': Array<OrderCreatedEvent>;
    'orderRatingUpdatedEvent': Array<OrderRatingUpdatedEvent>;
    'orderRefundedEvent': Array<OrderRefundedEvent>;
    'orderRejectedEvent': Array<OrderRejectedEvent>;
    'orderTipUpdatedEvent': Array<OrderTipUpdatedEvent>;
    'storeCreatedEvent': Array<StoreCreatedEvent>;
    'storeDeletedEvent': Array<StoreDeletedEvent>;
    'storeDeliveryZoneUpdatedEvent': Array<StoreDeliveryZoneUpdatedEvent>;
    'storeOpeningHoursUpdatedEvent': Array<StoreOpeningHoursUpdatedEvent>;
    'storeUpdatedEvent': Array<StoreUpdatedEvent>;
    'menuCreatedEvent': Array<MenuCreatedEvent>;
    'menuUpdatedEvent': Array<MenuUpdatedEvent>;
    'customerCreatedEvent': Array<CustomerCreatedEvent>;
    'customerUpdatedEvent': Array<CustomerUpdatedEvent>;
    'customerConsentUpdatedEvent': Array<CustomerConsentUpdatedEvent>;
    'campaignCreatedEvent': Array<CampaignCreatedEvent>;
    'webhookSubscriptionCreatedEvent': Array<WebhookSubscriptionCreatedEvent>;
    'webhookSubscriptionUpdatedEvent': Array<WebhookSubscriptionUpdatedEvent>;
    'webhookSubscriptionDeletedEvent': Array<WebhookSubscriptionDeletedEvent>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderAcceptedEvent",
            "baseName": "orderAcceptedEvent",
            "type": "Array<OrderAcceptedEvent>"
        },
        {
            "name": "orderCreatedEvent",
            "baseName": "orderCreatedEvent",
            "type": "Array<OrderCreatedEvent>"
        },
        {
            "name": "orderRatingUpdatedEvent",
            "baseName": "orderRatingUpdatedEvent",
            "type": "Array<OrderRatingUpdatedEvent>"
        },
        {
            "name": "orderRefundedEvent",
            "baseName": "orderRefundedEvent",
            "type": "Array<OrderRefundedEvent>"
        },
        {
            "name": "orderRejectedEvent",
            "baseName": "orderRejectedEvent",
            "type": "Array<OrderRejectedEvent>"
        },
        {
            "name": "orderTipUpdatedEvent",
            "baseName": "orderTipUpdatedEvent",
            "type": "Array<OrderTipUpdatedEvent>"
        },
        {
            "name": "storeCreatedEvent",
            "baseName": "storeCreatedEvent",
            "type": "Array<StoreCreatedEvent>"
        },
        {
            "name": "storeDeletedEvent",
            "baseName": "storeDeletedEvent",
            "type": "Array<StoreDeletedEvent>"
        },
        {
            "name": "storeDeliveryZoneUpdatedEvent",
            "baseName": "storeDeliveryZoneUpdatedEvent",
            "type": "Array<StoreDeliveryZoneUpdatedEvent>"
        },
        {
            "name": "storeOpeningHoursUpdatedEvent",
            "baseName": "storeOpeningHoursUpdatedEvent",
            "type": "Array<StoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "storeUpdatedEvent",
            "baseName": "storeUpdatedEvent",
            "type": "Array<StoreUpdatedEvent>"
        },
        {
            "name": "menuCreatedEvent",
            "baseName": "menuCreatedEvent",
            "type": "Array<MenuCreatedEvent>"
        },
        {
            "name": "menuUpdatedEvent",
            "baseName": "menuUpdatedEvent",
            "type": "Array<MenuUpdatedEvent>"
        },
        {
            "name": "customerCreatedEvent",
            "baseName": "customerCreatedEvent",
            "type": "Array<CustomerCreatedEvent>"
        },
        {
            "name": "customerUpdatedEvent",
            "baseName": "customerUpdatedEvent",
            "type": "Array<CustomerUpdatedEvent>"
        },
        {
            "name": "customerConsentUpdatedEvent",
            "baseName": "customerConsentUpdatedEvent",
            "type": "Array<CustomerConsentUpdatedEvent>"
        },
        {
            "name": "campaignCreatedEvent",
            "baseName": "campaignCreatedEvent",
            "type": "Array<CampaignCreatedEvent>"
        },
        {
            "name": "webhookSubscriptionCreatedEvent",
            "baseName": "webhookSubscriptionCreatedEvent",
            "type": "Array<WebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "webhookSubscriptionUpdatedEvent",
            "baseName": "webhookSubscriptionUpdatedEvent",
            "type": "Array<WebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "webhookSubscriptionDeletedEvent",
            "baseName": "webhookSubscriptionDeletedEvent",
            "type": "Array<WebhookSubscriptionDeletedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return EventSearchResult.attributeTypeMap;
    }
}

export class FeeSummary {
    'feeAmount': number;
    'percentageRate': number;
    'perTransactionFee': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "feeAmount",
            "baseName": "feeAmount",
            "type": "number"
        },
        {
            "name": "percentageRate",
            "baseName": "percentageRate",
            "type": "number"
        },
        {
            "name": "perTransactionFee",
            "baseName": "perTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeeSummary.attributeTypeMap;
    }
}

export class HttpRequestAndResponseLog {
    'verb': string;
    'requestUri': string;
    'statusCode': number;
    'reasonPhrase': string;
    'callDurationInMilliseconds': number;
    'userId': string;
    'ipAddress': string;
    'createdDateTime': string;
    'requestHeaders': { [key: string]: string; };
    'requestBody': string;
    'requestLength': number;
    'responseHeaders': { [key: string]: string; };
    'responseBody': string;
    'responseLength': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "verb",
            "baseName": "verb",
            "type": "string"
        },
        {
            "name": "requestUri",
            "baseName": "requestUri",
            "type": "string"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "number"
        },
        {
            "name": "reasonPhrase",
            "baseName": "reasonPhrase",
            "type": "string"
        },
        {
            "name": "callDurationInMilliseconds",
            "baseName": "callDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "createdDateTime",
            "baseName": "createdDateTime",
            "type": "string"
        },
        {
            "name": "requestHeaders",
            "baseName": "requestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "requestBody",
            "baseName": "requestBody",
            "type": "string"
        },
        {
            "name": "requestLength",
            "baseName": "requestLength",
            "type": "number"
        },
        {
            "name": "responseHeaders",
            "baseName": "responseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "responseBody",
            "baseName": "responseBody",
            "type": "string"
        },
        {
            "name": "responseLength",
            "baseName": "responseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HttpRequestAndResponseLog.attributeTypeMap;
    }
}

export class Menu {
    'menuId': number;
    'modifiedTime': Date;
    'versionNumber': number;
    'imageUrl': string;
    'menuSections': Array<MenuSection>;
    'displaySectionLinks': boolean;
    'menuSectionBehaviour': Menu.MenuSectionBehaviourEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menuId",
            "baseName": "menuId",
            "type": "number"
        },
        {
            "name": "modifiedTime",
            "baseName": "modifiedTime",
            "type": "Date"
        },
        {
            "name": "versionNumber",
            "baseName": "versionNumber",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "menuSections",
            "baseName": "menuSections",
            "type": "Array<MenuSection>"
        },
        {
            "name": "displaySectionLinks",
            "baseName": "displaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "menuSectionBehaviour",
            "baseName": "menuSectionBehaviour",
            "type": "Menu.MenuSectionBehaviourEnum"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
}
export class MenuBase {
    'displaySectionLinks': boolean;
    'menuSectionBehaviour': MenuBase.MenuSectionBehaviourEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displaySectionLinks",
            "baseName": "displaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "menuSectionBehaviour",
            "baseName": "menuSectionBehaviour",
            "type": "MenuBase.MenuSectionBehaviourEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuBase.attributeTypeMap;
    }
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
}
export class MenuCreatedEvent {
    'description': string;
    'user': UserEventInfo;
    'menu': Menu;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "menu",
            "baseName": "menu",
            "type": "Menu"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuCreatedEvent.attributeTypeMap;
    }
}

export class MenuItemOptionSet {
    'menuItemOptionSetId': number;
    'imageUrl': string;
    'menuItemOptionSetItems': Array<MenuItemOptionSetItem>;
    'name': string;
    'isMasterOptionSet': boolean;
    'displayOrder': number;
    'minSelectCount': number;
    'maxSelectCount': number;
    'cellLayoutType': MenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menuItemOptionSetId",
            "baseName": "menuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "menuItemOptionSetItems",
            "baseName": "menuItemOptionSetItems",
            "type": "Array<MenuItemOptionSetItem>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isMasterOptionSet",
            "baseName": "isMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "minSelectCount",
            "baseName": "minSelectCount",
            "type": "number"
        },
        {
            "name": "maxSelectCount",
            "baseName": "maxSelectCount",
            "type": "number"
        },
        {
            "name": "cellLayoutType",
            "baseName": "cellLayoutType",
            "type": "MenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSet.attributeTypeMap;
    }
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large'
    }
}
export class MenuItemOptionSetBase {
    'name': string;
    'isMasterOptionSet': boolean;
    'displayOrder': number;
    'minSelectCount': number;
    'maxSelectCount': number;
    'cellLayoutType': MenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isMasterOptionSet",
            "baseName": "isMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "minSelectCount",
            "baseName": "minSelectCount",
            "type": "number"
        },
        {
            "name": "maxSelectCount",
            "baseName": "maxSelectCount",
            "type": "number"
        },
        {
            "name": "cellLayoutType",
            "baseName": "cellLayoutType",
            "type": "MenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large'
    }
}
export class MenuItemOptionSetItem {
    'menuItemOptionSetItemId': number;
    'imageUrl': string;
    'name': string;
    'price': number;
    'isAvailable': boolean;
    'displayOrder': number;
    'cellLayoutType': MenuItemOptionSetItem.CellLayoutTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menuItemOptionSetItemId",
            "baseName": "menuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "cellLayoutType",
            "baseName": "cellLayoutType",
            "type": "MenuItemOptionSetItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large'
    }
}
export class MenuItemOptionSetItemBase {
    'name': string;
    'price': number;
    'isAvailable': boolean;
    'displayOrder': number;
    'cellLayoutType': MenuItemOptionSetItemBase.CellLayoutTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "cellLayoutType",
            "baseName": "cellLayoutType",
            "type": "MenuItemOptionSetItemBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large'
    }
}
export class MenuSection {
    'menuSectionId': number;
    'imageUrl': string;
    'menuItems': Array<MenuSectionItem>;
    'menuSectionAvailability': MenuSectionAvailability;
    'name': string;
    'description': string;
    'displayOrder': number;
    'isAvailable': boolean;
    'isHiddenFromCustomers': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menuSectionId",
            "baseName": "menuSectionId",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "menuItems",
            "baseName": "menuItems",
            "type": "Array<MenuSectionItem>"
        },
        {
            "name": "menuSectionAvailability",
            "baseName": "menuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        },
        {
            "name": "isHiddenFromCustomers",
            "baseName": "isHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSection.attributeTypeMap;
    }
}

export class MenuSectionAvailability {
    'availableTimes': Array<BusinessHoursPeriod>;
    'availabilityMode': MenuSectionAvailability.AvailabilityModeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "availableTimes",
            "baseName": "availableTimes",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "availabilityMode",
            "baseName": "availabilityMode",
            "type": "MenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailability.attributeTypeMap;
    }
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
export class MenuSectionBase {
    'name': string;
    'description': string;
    'displayOrder': number;
    'isAvailable': boolean;
    'isHiddenFromCustomers': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        },
        {
            "name": "isHiddenFromCustomers",
            "baseName": "isHiddenFromCustomers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionBase.attributeTypeMap;
    }
}

export class MenuSectionItem {
    'menuItemId': number;
    'actualPrice': number;
    'imageUrl': string;
    'menuItemOptionSets': Array<MenuItemOptionSet>;
    'name': string;
    'description': string;
    'spicinessRating': MenuSectionItem.SpicinessRatingEnum;
    'price': number;
    'displayOrder': number;
    'alcohol': boolean;
    'isAvailable': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menuItemId",
            "baseName": "menuItemId",
            "type": "number"
        },
        {
            "name": "actualPrice",
            "baseName": "actualPrice",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "menuItemOptionSets",
            "baseName": "menuItemOptionSets",
            "type": "Array<MenuItemOptionSet>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "spicinessRating",
            "baseName": "spicinessRating",
            "type": "MenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "alcohol",
            "baseName": "alcohol",
            "type": "boolean"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItem.attributeTypeMap;
    }
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
}
export class MenuSectionItemBase {
    'name': string;
    'description': string;
    'spicinessRating': MenuSectionItemBase.SpicinessRatingEnum;
    'price': number;
    'displayOrder': number;
    'alcohol': boolean;
    'isAvailable': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "spicinessRating",
            "baseName": "spicinessRating",
            "type": "MenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "alcohol",
            "baseName": "alcohol",
            "type": "boolean"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemBase.attributeTypeMap;
    }
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
}
export class MenuUpdatedEvent {
    'description': string;
    'user': UserEventInfo;
    'menu': Menu;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "menu",
            "baseName": "menu",
            "type": "Menu"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuUpdatedEvent.attributeTypeMap;
    }
}

export class Metadata {
    'key': string;
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metadata.attributeTypeMap;
    }
}

export class OAuthClient {
    'clientId': string;
    'clientName': string;
    'ownerUserId': number;
    'logoUri': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "clientName",
            "baseName": "clientName",
            "type": "string"
        },
        {
            "name": "ownerUserId",
            "baseName": "ownerUserId",
            "type": "number"
        },
        {
            "name": "logoUri",
            "baseName": "logoUri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OAuthClient.attributeTypeMap;
    }
}

export class OAuthTokenModel {
    'key': string;
    'tokenType': string;
    'subjectId': string;
    'clientId': string;
    'expiry': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "tokenType",
            "type": "string"
        },
        {
            "name": "subjectId",
            "baseName": "subjectId",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "expiry",
            "baseName": "expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OAuthTokenModel.attributeTypeMap;
    }
}

export class OauthClientRedirectUri {
    'id': number;
    'uri': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthClientRedirectUri.attributeTypeMap;
    }
}

export class Order {
    'store': StoreSummary;
    'customer': CustomerSummary;
    'voucher': VoucherSummary;
    'fees': FeeSummary;
    'orderItems': Array<OrderItem>;
    'deliveryLocation': DeliveryLocation;
    'customerLocation': Coordinates;
    'orderId': number;
    'deliveryType': Order.DeliveryTypeEnum;
    'pickupLocationType': Order.PickupLocationTypeEnum;
    'tipAmount': number;
    'deliveryAmount': number;
    'orderItemsAmount': number;
    'amount': number;
    'processingFee': number;
    'paymentAccountType': Order.PaymentAccountTypeEnum;
    'paymentAccountDescription': string;
    'orderState': Order.OrderStateEnum;
    'isPreOrder': boolean;
    'placedTime': Date;
    'requestedForTime': Date;
    'chefNote': string;
    'appType': Order.AppTypeEnum;
    'userRating': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "store",
            "baseName": "store",
            "type": "StoreSummary"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "CustomerSummary"
        },
        {
            "name": "voucher",
            "baseName": "voucher",
            "type": "VoucherSummary"
        },
        {
            "name": "fees",
            "baseName": "fees",
            "type": "FeeSummary"
        },
        {
            "name": "orderItems",
            "baseName": "orderItems",
            "type": "Array<OrderItem>"
        },
        {
            "name": "deliveryLocation",
            "baseName": "deliveryLocation",
            "type": "DeliveryLocation"
        },
        {
            "name": "customerLocation",
            "baseName": "customerLocation",
            "type": "Coordinates"
        },
        {
            "name": "orderId",
            "baseName": "orderId",
            "type": "number"
        },
        {
            "name": "deliveryType",
            "baseName": "deliveryType",
            "type": "Order.DeliveryTypeEnum"
        },
        {
            "name": "pickupLocationType",
            "baseName": "pickupLocationType",
            "type": "Order.PickupLocationTypeEnum"
        },
        {
            "name": "tipAmount",
            "baseName": "tipAmount",
            "type": "number"
        },
        {
            "name": "deliveryAmount",
            "baseName": "deliveryAmount",
            "type": "number"
        },
        {
            "name": "orderItemsAmount",
            "baseName": "orderItemsAmount",
            "type": "number"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "processingFee",
            "baseName": "processingFee",
            "type": "number"
        },
        {
            "name": "paymentAccountType",
            "baseName": "paymentAccountType",
            "type": "Order.PaymentAccountTypeEnum"
        },
        {
            "name": "paymentAccountDescription",
            "baseName": "paymentAccountDescription",
            "type": "string"
        },
        {
            "name": "orderState",
            "baseName": "orderState",
            "type": "Order.OrderStateEnum"
        },
        {
            "name": "isPreOrder",
            "baseName": "isPreOrder",
            "type": "boolean"
        },
        {
            "name": "placedTime",
            "baseName": "placedTime",
            "type": "Date"
        },
        {
            "name": "requestedForTime",
            "baseName": "requestedForTime",
            "type": "Date"
        },
        {
            "name": "chefNote",
            "baseName": "chefNote",
            "type": "string"
        },
        {
            "name": "appType",
            "baseName": "appType",
            "type": "Order.AppTypeEnum"
        },
        {
            "name": "userRating",
            "baseName": "userRating",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos'
    }
}
export class OrderAcceptedEvent {
    'description': string;
    'orderAcceptedTime': Date;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "orderAcceptedTime",
            "baseName": "orderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderAcceptedEvent.attributeTypeMap;
    }
}

export class OrderCreatedEvent {
    'description': string;
    'orderCreatedTime': Date;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "orderCreatedTime",
            "baseName": "orderCreatedTime",
            "type": "Date"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedEvent.attributeTypeMap;
    }
}

export class OrderItem {
    'orderItemOptions': Array<OrderItemOption>;
    'metadata': { [key: string]: string; };
    'menuSectionName': string;
    'menuSectionDisplayOrder': number;
    'name': string;
    'description': string;
    'price': number;
    'priceIncludingOptionSetItems': number;
    'menuItemId': number;
    'menuItemDisplayOrder': number;
    'isAvailable': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderItemOptions",
            "baseName": "orderItemOptions",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "menuSectionName",
            "baseName": "menuSectionName",
            "type": "string"
        },
        {
            "name": "menuSectionDisplayOrder",
            "baseName": "menuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "priceIncludingOptionSetItems",
            "baseName": "priceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "menuItemId",
            "baseName": "menuItemId",
            "type": "number"
        },
        {
            "name": "menuItemDisplayOrder",
            "baseName": "menuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "isAvailable",
            "baseName": "isAvailable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

export class OrderItemOption {
    'metadata': { [key: string]: string; };
    'menuItemOptionId': number;
    'isMasterOptionSetItem': boolean;
    'name': string;
    'price': number;
    'menuItemOptionDisplayOrder': number;
    'menuItemOptionSetDisplayOrder': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "menuItemOptionId",
            "baseName": "menuItemOptionId",
            "type": "number"
        },
        {
            "name": "isMasterOptionSetItem",
            "baseName": "isMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "menuItemOptionDisplayOrder",
            "baseName": "menuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "menuItemOptionSetDisplayOrder",
            "baseName": "menuItemOptionSetDisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

export class OrderRatingUpdatedEvent {
    'newUserRating': number;
    'description': string;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "newUserRating",
            "baseName": "newUserRating",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderRatingUpdatedEvent.attributeTypeMap;
    }
}

export class OrderRefundedEvent {
    'refundedAmount': number;
    'description': string;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refundedAmount",
            "baseName": "refundedAmount",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderRefundedEvent.attributeTypeMap;
    }
}

export class OrderRejectedEvent {
    'description': string;
    'orderRejectedTime': Date;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "orderRejectedTime",
            "baseName": "orderRejectedTime",
            "type": "Date"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderRejectedEvent.attributeTypeMap;
    }
}

export class OrderTipUpdatedEvent {
    'newTipAmount': number;
    'description': string;
    'order': Order;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "newTipAmount",
            "baseName": "newTipAmount",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderTipUpdatedEvent.attributeTypeMap;
    }
}

export class Range {
    'startTime': string;
    'period': string;
    'dayOfWeek': Range.DayOfWeekEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "string"
        },
        {
            "name": "dayOfWeek",
            "baseName": "dayOfWeek",
            "type": "Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
export class Refund {
    'refundReason': string;
    'refundAmount': number;
    'notifyCustomer': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refundReason",
            "baseName": "refundReason",
            "type": "string"
        },
        {
            "name": "refundAmount",
            "baseName": "refundAmount",
            "type": "number"
        },
        {
            "name": "notifyCustomer",
            "baseName": "notifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

export class Reject {
    'rejectReason': Reject.RejectReasonEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rejectReason",
            "baseName": "rejectReason",
            "type": "Reject.RejectReasonEnum"
        }    ];

    static getAttributeTypeMap() {
        return Reject.attributeTypeMap;
    }
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
export class RestApiArrayResultMenuItemOptionSet {
    'data': Array<MenuItemOptionSet>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<MenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSet.attributeTypeMap;
    }
}

export class RestApiArrayResultMenuItemOptionSetItem {
    'data': Array<MenuItemOptionSetItem>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<MenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

export class RestApiArrayResultMenuSection {
    'data': Array<MenuSection>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<MenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSection.attributeTypeMap;
    }
}

export class RestApiArrayResultMenuSectionItem {
    'data': Array<MenuSectionItem>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSectionItem.attributeTypeMap;
    }
}

export class RestApiArrayResultMetadata {
    'data': Array<Metadata>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMetadata.attributeTypeMap;
    }
}

export class RestApiArrayResultOAuthClient {
    'data': Array<OAuthClient>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<OAuthClient>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOAuthClient.attributeTypeMap;
    }
}

export class RestApiArrayResultOauthClientRedirectUri {
    'data': Array<OauthClientRedirectUri>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<OauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOauthClientRedirectUri.attributeTypeMap;
    }
}

export class RestApiArrayResultRestApiDefaultResponse {
    'data': Array<RestApiDefaultResponse>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<RestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestApiDefaultResponse.attributeTypeMap;
    }
}

export class RestApiArrayResultWebhookSubscription {
    'data': Array<WebhookSubscription>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<WebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultWebhookSubscription.attributeTypeMap;
    }
}

export class RestApiDefaultResponse {
    'data': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiDefaultResponse.attributeTypeMap;
    }
}

export class RestApiErrorResult {
    'message': string;
    'errors': Array<ValidationErrorResult>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<ValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiErrorResult.attributeTypeMap;
    }
}

export class RestApiEventSearchPaginationResult {
    'data': EventSearchResult;
    'page': number;
    'limit': number;
    'totalRecordCount': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "EventSearchResult"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

export class RestApiForbiddenResult {
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiForbiddenResult.attributeTypeMap;
    }
}

export class RestApiIntegerResult {
    'data': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiIntegerResult.attributeTypeMap;
    }
}

export class RestApiPaginationResultHttpRequestAndResponseLog {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<HttpRequestAndResponseLog>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<HttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHttpRequestAndResponseLog.attributeTypeMap;
    }
}

export class RestApiPaginationResultOAuthTokenModel {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<OAuthTokenModel>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<OAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOAuthTokenModel.attributeTypeMap;
    }
}

export class RestApiPaginationResultOrder {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<Order>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Order>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrder.attributeTypeMap;
    }
}

export class RestApiPaginationResultStore {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<Store>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Store>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStore.attributeTypeMap;
    }
}

export class RestApiPaginationResultVoucher {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<Voucher>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Voucher>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultVoucher.attributeTypeMap;
    }
}

export class RestApiPaginationResultWebhookLog {
    'page': number;
    'limit': number;
    'totalRecordCount': number;
    'data': Array<WebhookLog>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "totalRecordCount",
            "baseName": "totalRecordCount",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<WebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookLog.attributeTypeMap;
    }
}

export class RestApiResultMenu {
    'data': Menu;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Menu"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenu.attributeTypeMap;
    }
}

export class RestApiResultMenuItemOptionSet {
    'data': MenuItemOptionSet;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "MenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSet.attributeTypeMap;
    }
}

export class RestApiResultMenuItemOptionSetItem {
    'data': MenuItemOptionSetItem;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "MenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

export class RestApiResultMenuSection {
    'data': MenuSection;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "MenuSection"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSection.attributeTypeMap;
    }
}

export class RestApiResultMenuSectionItem {
    'data': MenuSectionItem;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "MenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionItem.attributeTypeMap;
    }
}

export class RestApiResultMetadata {
    'data': Metadata;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Metadata"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetadata.attributeTypeMap;
    }
}

export class RestApiResultOAuthClient {
    'data': OAuthClient;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "OAuthClient"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOAuthClient.attributeTypeMap;
    }
}

export class RestApiResultOauthClientRedirectUri {
    'data': OauthClientRedirectUri;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "OauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOauthClientRedirectUri.attributeTypeMap;
    }
}

export class RestApiResultOrder {
    'data': Order;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrder.attributeTypeMap;
    }
}

export class RestApiResultStore {
    'data': Store;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Store"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStore.attributeTypeMap;
    }
}

export class RestApiResultVoucher {
    'data': Voucher;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Voucher"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultVoucher.attributeTypeMap;
    }
}

export class RestApiStringArrayResult {
    'data': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringArrayResult.attributeTypeMap;
    }
}

export class RestApiStringResult {
    'data': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringResult.attributeTypeMap;
    }
}

export class RestApiUnauthorizedResult {
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiUnauthorizedResult.attributeTypeMap;
    }
}

export class SearchCriteria {
    'limit': number;
    'page': number;
    'start': Date;
    'end': Date;
    'name': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "Date"
        },
        {
            "name": "end",
            "baseName": "end",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SearchCriteria.attributeTypeMap;
    }
}

export class Store {
    'storeId': number;
    'name': string;
    'apmPhoneNumber': string;
    'phoneNumber': string;
    'emailAddress': string;
    'address': StoreAddress;
    'preOrderEnabled': boolean;
    'takeOutEnabled': boolean;
    'tableServiceEnabled': boolean;
    'dineInEnabled': boolean;
    'allowPreOrdersAndTableService': boolean;
    'pickupEnabled': boolean;
    'deliveryEnabled': boolean;
    'cardOrderDeliveryEnabled': boolean;
    'cashOrdersDeliveryEnabled': boolean;
    'cardOrdersPickupEnabled': boolean;
    'cashOrdersPickupEnabled': boolean;
    'tipsEnabled': boolean;
    'automaticallyAcceptOrders': boolean;
    'openForDelivery': boolean;
    'openForPickup': boolean;
    'minimumPickupOrderAmount': number;
    'deliveryFeeAreas': Array<DeliveryFeeArea>;
    'requireCustomerNameForPickup': boolean;
    'requireCustomerNameForDelivery': boolean;
    'pickupHours': Array<BusinessHoursPeriod>;
    'deliveryHours': Array<BusinessHoursPeriod>;
    'microsoftTimeZone': string;
    'ianaTimeZone': string;
    'menuId': number;
    'orderConfirmationMessageOverrideDelivery': string;
    'orderConfirmationMessageOverridePickup': string;
    'printoutLayoutType': Store.PrintoutLayoutTypeEnum;
    'storeNotes': Array<StoreNote>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "apmPhoneNumber",
            "baseName": "apmPhoneNumber",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "StoreAddress"
        },
        {
            "name": "preOrderEnabled",
            "baseName": "preOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "takeOutEnabled",
            "baseName": "takeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "tableServiceEnabled",
            "baseName": "tableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "dineInEnabled",
            "baseName": "dineInEnabled",
            "type": "boolean"
        },
        {
            "name": "allowPreOrdersAndTableService",
            "baseName": "allowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "pickupEnabled",
            "baseName": "pickupEnabled",
            "type": "boolean"
        },
        {
            "name": "deliveryEnabled",
            "baseName": "deliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "cardOrderDeliveryEnabled",
            "baseName": "cardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "cashOrdersDeliveryEnabled",
            "baseName": "cashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "cardOrdersPickupEnabled",
            "baseName": "cardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "cashOrdersPickupEnabled",
            "baseName": "cashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "tipsEnabled",
            "baseName": "tipsEnabled",
            "type": "boolean"
        },
        {
            "name": "automaticallyAcceptOrders",
            "baseName": "automaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "openForDelivery",
            "baseName": "openForDelivery",
            "type": "boolean"
        },
        {
            "name": "openForPickup",
            "baseName": "openForPickup",
            "type": "boolean"
        },
        {
            "name": "minimumPickupOrderAmount",
            "baseName": "minimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "deliveryFeeAreas",
            "baseName": "deliveryFeeAreas",
            "type": "Array<DeliveryFeeArea>"
        },
        {
            "name": "requireCustomerNameForPickup",
            "baseName": "requireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "requireCustomerNameForDelivery",
            "baseName": "requireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "pickupHours",
            "baseName": "pickupHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "deliveryHours",
            "baseName": "deliveryHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "microsoftTimeZone",
            "baseName": "microsoftTimeZone",
            "type": "string"
        },
        {
            "name": "ianaTimeZone",
            "baseName": "ianaTimeZone",
            "type": "string"
        },
        {
            "name": "menuId",
            "baseName": "menuId",
            "type": "number"
        },
        {
            "name": "orderConfirmationMessageOverrideDelivery",
            "baseName": "orderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "orderConfirmationMessageOverridePickup",
            "baseName": "orderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "printoutLayoutType",
            "baseName": "printoutLayoutType",
            "type": "Store.PrintoutLayoutTypeEnum"
        },
        {
            "name": "storeNotes",
            "baseName": "storeNotes",
            "type": "Array<StoreNote>"
        }    ];

    static getAttributeTypeMap() {
        return Store.attributeTypeMap;
    }
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra'
    }
}
export class StoreAddress {
    'addressId': number;
    'line1': string;
    'postcode': string;
    'city': string;
    'countryCode': string;
    'displayForCustomer': string;
    'coordinates': Coordinates;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addressId",
            "baseName": "addressId",
            "type": "number"
        },
        {
            "name": "line1",
            "baseName": "line1",
            "type": "string"
        },
        {
            "name": "postcode",
            "baseName": "postcode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "displayForCustomer",
            "baseName": "displayForCustomer",
            "type": "string"
        },
        {
            "name": "coordinates",
            "baseName": "coordinates",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddress.attributeTypeMap;
    }
}

export class StoreCreatedEvent {
    'storeId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreatedEvent.attributeTypeMap;
    }
}

export class StoreDeletedEvent {
    'storeId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeletedEvent.attributeTypeMap;
    }
}

export class StoreDeliveryZoneUpdatedEvent {
    'storeId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

export class StoreNote {
    'userId': number;
    'createTime': Date;
    'note': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreNote.attributeTypeMap;
    }
}

export class StoreOpeningHoursUpdatedEvent {
    'storeId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

export class StoreSummary {
    'id': number;
    'name': string;
    'menuId': number;
    'metadata': { [key: string]: string; };
    'currency': StoreSummary.CurrencyEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "menuId",
            "baseName": "menuId",
            "type": "number"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "StoreSummary.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreSummary.attributeTypeMap;
    }
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD'
    }
}
export class StoreUpdatedEvent {
    'storeId': number;
    'user': UserEventInfo;
    'description': string;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "UserEventInfo"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreUpdatedEvent.attributeTypeMap;
    }
}

export class UserEventInfo {
    'userId': number;
    'userName': string;
    'userPhoneNumber': string;
    'userEmail': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "userPhoneNumber",
            "baseName": "userPhoneNumber",
            "type": "string"
        },
        {
            "name": "userEmail",
            "baseName": "userEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserEventInfo.attributeTypeMap;
    }
}

export class ValidationErrorResult {
    'fieldName': string;
    'errors': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldName",
            "baseName": "fieldName",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ValidationErrorResult.attributeTypeMap;
    }
}

export class Voucher {
    'voucherId': number;
    'voucherType': Voucher.VoucherTypeEnum;
    'isEnabled': boolean;
    'isUsedUp': boolean;
    'voucherSubType': Voucher.VoucherSubTypeEnum;
    'publicDescription': string;
    'privateDescription': string;
    'validFrom': Date;
    'expiry': Date;
    'voucherPayer': Voucher.VoucherPayerEnum;
    'isVisibleToStore': boolean;
    'isReusable': boolean;
    'isValidForDeliveryOrders': boolean;
    'isValidForPickupOrders': boolean;
    'isValidForCardOrders': boolean;
    'isValidForCashOrders': boolean;
    'isValidForFirstOrderOnly': boolean;
    'minimumOrderAmount': number;
    'isValidOncePerCustomer': boolean;
    'autoApply': boolean;
    'autoApplyOrder': number;
    'includeDeliveryFee': boolean;
    'code': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "voucherId",
            "baseName": "voucherId",
            "type": "number"
        },
        {
            "name": "voucherType",
            "baseName": "voucherType",
            "type": "Voucher.VoucherTypeEnum"
        },
        {
            "name": "isEnabled",
            "baseName": "isEnabled",
            "type": "boolean"
        },
        {
            "name": "isUsedUp",
            "baseName": "isUsedUp",
            "type": "boolean"
        },
        {
            "name": "voucherSubType",
            "baseName": "voucherSubType",
            "type": "Voucher.VoucherSubTypeEnum"
        },
        {
            "name": "publicDescription",
            "baseName": "publicDescription",
            "type": "string"
        },
        {
            "name": "privateDescription",
            "baseName": "privateDescription",
            "type": "string"
        },
        {
            "name": "validFrom",
            "baseName": "validFrom",
            "type": "Date"
        },
        {
            "name": "expiry",
            "baseName": "expiry",
            "type": "Date"
        },
        {
            "name": "voucherPayer",
            "baseName": "voucherPayer",
            "type": "Voucher.VoucherPayerEnum"
        },
        {
            "name": "isVisibleToStore",
            "baseName": "isVisibleToStore",
            "type": "boolean"
        },
        {
            "name": "isReusable",
            "baseName": "isReusable",
            "type": "boolean"
        },
        {
            "name": "isValidForDeliveryOrders",
            "baseName": "isValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "isValidForPickupOrders",
            "baseName": "isValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "isValidForCardOrders",
            "baseName": "isValidForCardOrders",
            "type": "boolean"
        },
        {
            "name": "isValidForCashOrders",
            "baseName": "isValidForCashOrders",
            "type": "boolean"
        },
        {
            "name": "isValidForFirstOrderOnly",
            "baseName": "isValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "minimumOrderAmount",
            "baseName": "minimumOrderAmount",
            "type": "number"
        },
        {
            "name": "isValidOncePerCustomer",
            "baseName": "isValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "autoApply",
            "baseName": "autoApply",
            "type": "boolean"
        },
        {
            "name": "autoApplyOrder",
            "baseName": "autoApplyOrder",
            "type": "number"
        },
        {
            "name": "includeDeliveryFee",
            "baseName": "includeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Voucher.attributeTypeMap;
    }
}

export namespace Voucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
    export enum VoucherPayerEnum {
        Flipdish = <any> 'Flipdish',
        Store = <any> 'Store'
    }
}
export class VoucherSummary {
    'name': string;
    'description': string;
    'code': string;
    'amount': number;
    'type': VoucherSummary.TypeEnum;
    'subType': VoucherSummary.SubTypeEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "VoucherSummary.TypeEnum"
        },
        {
            "name": "subType",
            "baseName": "subType",
            "type": "VoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return VoucherSummary.attributeTypeMap;
    }
}

export namespace VoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
export class WebhookLog {
    'webhookSubscriptionOwnerUserId': number;
    'eventCreated': string;
    'webhookTriggered': string;
    'webhookEventName': string;
    'webhookSubscriptionCallbackUrl': string;
    'httpResponseStatusCode': string;
    'httpResponseStatus': string;
    'requestHeaders': string;
    'requestBody': string;
    'responseHeaders': string;
    'responseBody': string;
    'duration': string;
    'retryCount': number;
    'flipdishWebhookId': string;
    'version': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookSubscriptionOwnerUserId",
            "baseName": "webhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "eventCreated",
            "baseName": "eventCreated",
            "type": "string"
        },
        {
            "name": "webhookTriggered",
            "baseName": "webhookTriggered",
            "type": "string"
        },
        {
            "name": "webhookEventName",
            "baseName": "webhookEventName",
            "type": "string"
        },
        {
            "name": "webhookSubscriptionCallbackUrl",
            "baseName": "webhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "httpResponseStatusCode",
            "baseName": "httpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "httpResponseStatus",
            "baseName": "httpResponseStatus",
            "type": "string"
        },
        {
            "name": "requestHeaders",
            "baseName": "requestHeaders",
            "type": "string"
        },
        {
            "name": "requestBody",
            "baseName": "requestBody",
            "type": "string"
        },
        {
            "name": "responseHeaders",
            "baseName": "responseHeaders",
            "type": "string"
        },
        {
            "name": "responseBody",
            "baseName": "responseBody",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "retryCount",
            "baseName": "retryCount",
            "type": "number"
        },
        {
            "name": "flipdishWebhookId",
            "baseName": "flipdishWebhookId",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

export class WebhookSubscription {
    'id': number;
    'ownerUserId': number;
    'version': string;
    'eventNames': Array<string>;
    'callbackUrl': string;
    'enabled': boolean;
    'verifyToken': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ownerUserId",
            "baseName": "ownerUserId",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "eventNames",
            "baseName": "eventNames",
            "type": "Array<string>"
        },
        {
            "name": "callbackUrl",
            "baseName": "callbackUrl",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "verifyToken",
            "baseName": "verifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscription.attributeTypeMap;
    }
}

export class WebhookSubscriptionCreatedEvent {
    'webhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookSubscriptionEventInfo",
            "baseName": "webhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

export class WebhookSubscriptionDeletedEvent {
    'webhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookSubscriptionEventInfo",
            "baseName": "webhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

export class WebhookSubscriptionEventInfo {
    'ownerUserId': number;
    'webhookSubscriptionId': number;
    'clientId': string;
    'callbackUrl': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ownerUserId",
            "baseName": "ownerUserId",
            "type": "number"
        },
        {
            "name": "webhookSubscriptionId",
            "baseName": "webhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "callbackUrl",
            "baseName": "callbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

export class WebhookSubscriptionUpdatedEvent {
    'webhookSubscriptionEventInfo': WebhookSubscriptionEventInfo;
    'eventName': string;
    'flipdishEventId': string;
    'createTime': Date;
    'position': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookSubscriptionEventInfo",
            "baseName": "webhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "flipdishEventId",
            "baseName": "flipdishEventId",
            "type": "string"
        },
        {
            "name": "createTime",
            "baseName": "createTime",
            "type": "Date"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "BusinessHoursPeriod.DayOfWeekEnum": BusinessHoursPeriod.DayOfWeekEnum,
        "Menu.MenuSectionBehaviourEnum": Menu.MenuSectionBehaviourEnum,
        "MenuBase.MenuSectionBehaviourEnum": MenuBase.MenuSectionBehaviourEnum,
        "MenuItemOptionSet.CellLayoutTypeEnum": MenuItemOptionSet.CellLayoutTypeEnum,
        "MenuItemOptionSetBase.CellLayoutTypeEnum": MenuItemOptionSetBase.CellLayoutTypeEnum,
        "MenuItemOptionSetItem.CellLayoutTypeEnum": MenuItemOptionSetItem.CellLayoutTypeEnum,
        "MenuItemOptionSetItemBase.CellLayoutTypeEnum": MenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "MenuSectionAvailability.AvailabilityModeEnum": MenuSectionAvailability.AvailabilityModeEnum,
        "MenuSectionItem.SpicinessRatingEnum": MenuSectionItem.SpicinessRatingEnum,
        "MenuSectionItemBase.SpicinessRatingEnum": MenuSectionItemBase.SpicinessRatingEnum,
        "Order.DeliveryTypeEnum": Order.DeliveryTypeEnum,
        "Order.PickupLocationTypeEnum": Order.PickupLocationTypeEnum,
        "Order.PaymentAccountTypeEnum": Order.PaymentAccountTypeEnum,
        "Order.OrderStateEnum": Order.OrderStateEnum,
        "Order.AppTypeEnum": Order.AppTypeEnum,
        "Range.DayOfWeekEnum": Range.DayOfWeekEnum,
        "Reject.RejectReasonEnum": Reject.RejectReasonEnum,
        "Store.PrintoutLayoutTypeEnum": Store.PrintoutLayoutTypeEnum,
        "StoreSummary.CurrencyEnum": StoreSummary.CurrencyEnum,
        "Voucher.VoucherTypeEnum": Voucher.VoucherTypeEnum,
        "Voucher.VoucherSubTypeEnum": Voucher.VoucherSubTypeEnum,
        "Voucher.VoucherPayerEnum": Voucher.VoucherPayerEnum,
        "VoucherSummary.TypeEnum": VoucherSummary.TypeEnum,
        "VoucherSummary.SubTypeEnum": VoucherSummary.SubTypeEnum,
}

let typeMap: {[index: string]: any} = {
    "Accept": Accept,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "CampaignCreatedEvent": CampaignCreatedEvent,
    "Coordinates": Coordinates,
    "CustomerConsentUpdatedEvent": CustomerConsentUpdatedEvent,
    "CustomerCreatedEvent": CustomerCreatedEvent,
    "CustomerSummary": CustomerSummary,
    "CustomerUpdatedEvent": CustomerUpdatedEvent,
    "DeliveryFeeArea": DeliveryFeeArea,
    "DeliveryLocation": DeliveryLocation,
    "EventSearchResult": EventSearchResult,
    "FeeSummary": FeeSummary,
    "HttpRequestAndResponseLog": HttpRequestAndResponseLog,
    "Menu": Menu,
    "MenuBase": MenuBase,
    "MenuCreatedEvent": MenuCreatedEvent,
    "MenuItemOptionSet": MenuItemOptionSet,
    "MenuItemOptionSetBase": MenuItemOptionSetBase,
    "MenuItemOptionSetItem": MenuItemOptionSetItem,
    "MenuItemOptionSetItemBase": MenuItemOptionSetItemBase,
    "MenuSection": MenuSection,
    "MenuSectionAvailability": MenuSectionAvailability,
    "MenuSectionBase": MenuSectionBase,
    "MenuSectionItem": MenuSectionItem,
    "MenuSectionItemBase": MenuSectionItemBase,
    "MenuUpdatedEvent": MenuUpdatedEvent,
    "Metadata": Metadata,
    "OAuthClient": OAuthClient,
    "OAuthTokenModel": OAuthTokenModel,
    "OauthClientRedirectUri": OauthClientRedirectUri,
    "Order": Order,
    "OrderAcceptedEvent": OrderAcceptedEvent,
    "OrderCreatedEvent": OrderCreatedEvent,
    "OrderItem": OrderItem,
    "OrderItemOption": OrderItemOption,
    "OrderRatingUpdatedEvent": OrderRatingUpdatedEvent,
    "OrderRefundedEvent": OrderRefundedEvent,
    "OrderRejectedEvent": OrderRejectedEvent,
    "OrderTipUpdatedEvent": OrderTipUpdatedEvent,
    "Range": Range,
    "Refund": Refund,
    "Reject": Reject,
    "RestApiArrayResultMenuItemOptionSet": RestApiArrayResultMenuItemOptionSet,
    "RestApiArrayResultMenuItemOptionSetItem": RestApiArrayResultMenuItemOptionSetItem,
    "RestApiArrayResultMenuSection": RestApiArrayResultMenuSection,
    "RestApiArrayResultMenuSectionItem": RestApiArrayResultMenuSectionItem,
    "RestApiArrayResultMetadata": RestApiArrayResultMetadata,
    "RestApiArrayResultOAuthClient": RestApiArrayResultOAuthClient,
    "RestApiArrayResultOauthClientRedirectUri": RestApiArrayResultOauthClientRedirectUri,
    "RestApiArrayResultRestApiDefaultResponse": RestApiArrayResultRestApiDefaultResponse,
    "RestApiArrayResultWebhookSubscription": RestApiArrayResultWebhookSubscription,
    "RestApiDefaultResponse": RestApiDefaultResponse,
    "RestApiErrorResult": RestApiErrorResult,
    "RestApiEventSearchPaginationResult": RestApiEventSearchPaginationResult,
    "RestApiForbiddenResult": RestApiForbiddenResult,
    "RestApiIntegerResult": RestApiIntegerResult,
    "RestApiPaginationResultHttpRequestAndResponseLog": RestApiPaginationResultHttpRequestAndResponseLog,
    "RestApiPaginationResultOAuthTokenModel": RestApiPaginationResultOAuthTokenModel,
    "RestApiPaginationResultOrder": RestApiPaginationResultOrder,
    "RestApiPaginationResultStore": RestApiPaginationResultStore,
    "RestApiPaginationResultVoucher": RestApiPaginationResultVoucher,
    "RestApiPaginationResultWebhookLog": RestApiPaginationResultWebhookLog,
    "RestApiResultMenu": RestApiResultMenu,
    "RestApiResultMenuItemOptionSet": RestApiResultMenuItemOptionSet,
    "RestApiResultMenuItemOptionSetItem": RestApiResultMenuItemOptionSetItem,
    "RestApiResultMenuSection": RestApiResultMenuSection,
    "RestApiResultMenuSectionItem": RestApiResultMenuSectionItem,
    "RestApiResultMetadata": RestApiResultMetadata,
    "RestApiResultOAuthClient": RestApiResultOAuthClient,
    "RestApiResultOauthClientRedirectUri": RestApiResultOauthClientRedirectUri,
    "RestApiResultOrder": RestApiResultOrder,
    "RestApiResultStore": RestApiResultStore,
    "RestApiResultVoucher": RestApiResultVoucher,
    "RestApiStringArrayResult": RestApiStringArrayResult,
    "RestApiStringResult": RestApiStringResult,
    "RestApiUnauthorizedResult": RestApiUnauthorizedResult,
    "SearchCriteria": SearchCriteria,
    "Store": Store,
    "StoreAddress": StoreAddress,
    "StoreCreatedEvent": StoreCreatedEvent,
    "StoreDeletedEvent": StoreDeletedEvent,
    "StoreDeliveryZoneUpdatedEvent": StoreDeliveryZoneUpdatedEvent,
    "StoreNote": StoreNote,
    "StoreOpeningHoursUpdatedEvent": StoreOpeningHoursUpdatedEvent,
    "StoreSummary": StoreSummary,
    "StoreUpdatedEvent": StoreUpdatedEvent,
    "UserEventInfo": UserEventInfo,
    "ValidationErrorResult": ValidationErrorResult,
    "Voucher": Voucher,
    "VoucherSummary": VoucherSummary,
    "WebhookLog": WebhookLog,
    "WebhookSubscription": WebhookSubscription,
    "WebhookSubscriptionCreatedEvent": WebhookSubscriptionCreatedEvent,
    "WebhookSubscriptionDeletedEvent": WebhookSubscriptionDeletedEvent,
    "WebhookSubscriptionEventInfo": WebhookSubscriptionEventInfo,
    "WebhookSubscriptionUpdatedEvent": WebhookSubscriptionUpdatedEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get authorization tokens
     * @param clientId Client identifier
     * @param page Requested page number
     * @param limit Requested page limit
     */
    public getAuthorizationTokens (clientId: string, page?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/authorizationtokens/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOAuthTokenModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revoke token
     * @param key Token identifier key
     */
    public revokeToken (key: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get order events
     * @param customerId Customer identifier identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getCustomerEvents (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/customer/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events
     * @param storeId Store Id
     * @param whiteLabelId White Label Id
     * @param customerId Customer Id
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getEvents (storeId?: number, whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event by Id
     * @param eventId Event identifier (Guid)
     */
    public getEventsById (eventId: string) : Promise<{ response: http.ClientResponse; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Menu Events
     * @param menuId Menu Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getMenuEvents (menuId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/menu/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events
     * @param orderId Order identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getOrderEvents (orderId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events by customer
     * @param customerId Customer identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getOrderEventsByCustomer (customerId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/order';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get store events
     * @param storeId Id of the store
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getStoreEvents (storeId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/store/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order events
     * @param userId User identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getUserEvents (userId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/user/{userId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get White Label Events
     * @param whitelabelId White Label Identifier
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param name Event names to filter in
     */
    public getWhiteLabelEvents (whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, name?: Array<string>) : Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/events/whitelabel/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get API interaction logs
     * @param start Start date time
     * @param end End date time
     * @param filterByUserId User id (optional)
     * @param page Page number
     * @param limit Page size
     */
    public getHttpLogsByUserIdAsync (start: Date, end: Date, filterByUserId?: number, page?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/interactions/logs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getHttpLogsByUserIdAsync.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getHttpLogsByUserIdAsync.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHttpRequestAndResponseLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }


        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }


        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public getMenuItems (menuId: number, menuSectionId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operaton will be undone.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }


        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public deleteMenuSection (menuId: number, menuSectionId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     */
    public getMenuSectionById (menuId: number, menuSectionId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     */
    public getMenuSections (menuId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }


        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get a menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a menu items metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     */
    public deleteMenuItemMetadata_1 (menuId: number, storeId: number, menuItemId: number, key: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata_1.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata_1.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata_1.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata_1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     */
    public deleteMenuSectionImage (menuId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     */
    public getMenuById (menuId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a menu items metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a menu items metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a menu item option set items metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Menu (delta)
     */
    public updateMenu (menuId: number, menu: MenuBase) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "MenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     */
    public uploadMenuSectionImage (menuId: number, Image: Buffer) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }


        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create OAuth client redirect uri
     * @param oAuthClientId OAuth client identifier
     * @param uri Redirect uri
     */
    public addRedirectUri (oAuthClientId: string, uri: string) : Promise<{ response: http.ClientResponse; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oAuthClientId}/redirecturis'
            .replace('{' + 'oAuthClientId' + '}', encodeURIComponent(String(oAuthClientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClientId' is not null or undefined
        if (oAuthClientId === null || oAuthClientId === undefined) {
            throw new Error('Required parameter oAuthClientId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OAuth client
     * @param oAuthClient OAuth client
     */
    public createOAuthClient (oAuthClient: OAuthClient) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClient' is not null or undefined
        if (oAuthClient === null || oAuthClient === undefined) {
            throw new Error('Required parameter oAuthClient was null or undefined when calling createOAuthClient.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthClient, "OAuthClient")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth client
     * @param oAuthClientId OAuth client identifier
     */
    public deleteOAuthClient (oAuthClientId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oAuthClientId}'
            .replace('{' + 'oAuthClientId' + '}', encodeURIComponent(String(oAuthClientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClientId' is not null or undefined
        if (oAuthClientId === null || oAuthClientId === undefined) {
            throw new Error('Required parameter oAuthClientId was null or undefined when calling deleteOAuthClient.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth client by identifier
     * @param clientId OAuth client identifier
     */
    public getOAuthClientByClientId (clientId: string) : Promise<{ response: http.ClientResponse; body: RestApiResultOAuthClient;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getOAuthClientByClientId.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultOAuthClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOAuthClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth client secret key
     * @param clientId OAuth client identifier
     */
    public getOAuthClientSecret (clientId: string) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{clientId}/secret'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getOAuthClientSecret.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all OAuth client
     */
    public getOAuthClients () : Promise<{ response: http.ClientResponse; body: RestApiArrayResultOAuthClient;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultOAuthClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOAuthClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth access token for client
     * @param oAuthClientId OAuth client identifier
     */
    public getOauthAccessToken (oAuthClientId: string) : Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oAuthClientId}/accesstoken'
            .replace('{' + 'oAuthClientId' + '}', encodeURIComponent(String(oAuthClientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClientId' is not null or undefined
        if (oAuthClientId === null || oAuthClientId === undefined) {
            throw new Error('Required parameter oAuthClientId was null or undefined when calling getOauthAccessToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OAuth client redirect uris
     * @param oAuthClientId OAuth client identifier
     */
    public getRedirectUris (oAuthClientId: string) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oAuthClientId}/redirecturis'
            .replace('{' + 'oAuthClientId' + '}', encodeURIComponent(String(oAuthClientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClientId' is not null or undefined
        if (oAuthClientId === null || oAuthClientId === undefined) {
            throw new Error('Required parameter oAuthClientId was null or undefined when calling getRedirectUris.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OAuth client redirect uri
     * @param oAuthClientId OAuth client identifier
     * @param uriId Redirect uri identifier
     */
    public removeRedirectUri (oAuthClientId: string, uriId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oAuthClientId}/redirecturis/{uriId}'
            .replace('{' + 'oAuthClientId' + '}', encodeURIComponent(String(oAuthClientId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthClientId' is not null or undefined
        if (oAuthClientId === null || oAuthClientId === undefined) {
            throw new Error('Required parameter oAuthClientId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * To accept an order, you create an `accept` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Accept order
     * @param id Order identifier
     * @param acceptObject 
     */
    public acceptOrder (id: number, acceptObject: Accept) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "Accept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get order by ID
     * @param id Order identifier
     */
    public getOrderById (id: number) : Promise<{ response: http.ClientResponse; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orders by filter
     * @param physicalRestaurantId Physical restaurant identifiers
     * @param state Order states
     * @param page Requested page number
     * @param limit Requested page limit
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<string>, page?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<string>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To refund an order, you create a `refund` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Refund order
     * @param id Order identifier
     * @param refundObject 
     */
    public refundOrder (id: number, refundObject: Refund) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "Refund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * To reject an order, you create a `reject` object and send it to Flipdish API using HTTP POST method. `Id` path parameter identifies the order.
     * @summary Reject order
     * @param id Order identifier
     * @param rejectObject 
     */
    public rejectOrder (id: number, rejectObject: Reject) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "Reject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get store by identifier
     * @param storeId Store identifier
     */
    public getStoreById (storeId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all stores
     * @param searchQuery Search query
     * @param page Requested page index
     * @param limit Requested page limit
     */
    public getStores (searchQuery?: string, page?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Get role names
     */
    public getRoles () : Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Delete voucher metadata
     * @param voucherId 
     * @param menuId 
     * @param storeId 
     * @param key 
     */
    public deleteVoucherMetadata (voucherId: number, menuId: number, storeId: number, key: string) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}/menu/{menuId}/store/{storeId}/metadata/{key}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling deleteVoucherMetadata.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteVoucherMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteVoucherMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteVoucherMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get voucher by identifier
     * @param voucherId 
     */
    public getVoucherById (voucherId: number) : Promise<{ response: http.ClientResponse; body: RestApiResultVoucher;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultVoucher;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucher");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get voucher metadata
     * @param voucherId 
     * @param menuId 
     * @param storeId 
     */
    public getVoucherMetadata (voucherId: number, menuId: number, storeId: number) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}/menu/{menuId}/store/{storeId}/metadata'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherMetadata.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getVoucherMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getVoucherMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get voucher metadata
     * @param voucherId 
     * @param menuId 
     * @param storeId 
     * @param key 
     */
    public getVoucherMetadata_1 (voucherId: number, menuId: number, storeId: number, key: string) : Promise<{ response: http.ClientResponse; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}/menu/{menuId}/store/{storeId}/metadata/{key}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherMetadata_1.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getVoucherMetadata_1.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getVoucherMetadata_1.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getVoucherMetadata_1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get vouchers
     * @param filter 
     * @param pageNumber 
     * @param pageSize 
     * @param sortOrder 
     * @param orderBy 
     * @param subType 
     * @param status 
     * @param code 
     * @param validFromBegin 
     * @param validFromEnd 
     * @param expiryBegin 
     * @param expiryEnd 
     * @param amount 
     * @param voucherType 
     * @param description 
     */
    public getVouchers (filter?: string, pageNumber?: number, pageSize?: number, sortOrder?: string, orderBy?: string, subType?: string, status?: string, code?: string, validFromBegin?: Date, validFromEnd?: Date, expiryBegin?: Date, expiryEnd?: Date, amount?: number, voucherType?: string, description?: string) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultVoucher;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (pageNumber !== undefined) {
            localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sortOrder'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (subType !== undefined) {
            localVarQueryParameters['subType'] = ObjectSerializer.serialize(subType, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (validFromBegin !== undefined) {
            localVarQueryParameters['validFromBegin'] = ObjectSerializer.serialize(validFromBegin, "Date");
        }

        if (validFromEnd !== undefined) {
            localVarQueryParameters['validFromEnd'] = ObjectSerializer.serialize(validFromEnd, "Date");
        }

        if (expiryBegin !== undefined) {
            localVarQueryParameters['expiryBegin'] = ObjectSerializer.serialize(expiryBegin, "Date");
        }

        if (expiryEnd !== undefined) {
            localVarQueryParameters['expiryEnd'] = ObjectSerializer.serialize(expiryEnd, "Date");
        }

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (voucherType !== undefined) {
            localVarQueryParameters['voucherType'] = ObjectSerializer.serialize(voucherType, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultVoucher;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultVoucher");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add voucher metadata
     * @param voucherId 
     * @param menuId 
     * @param storeId 
     * @param key 
     * @param value 
     */
    public setVoucherMetadata (voucherId: number, menuId: number, storeId: number, key: string, value: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}/menu/{menuId}/store/{storeId}/metadata/{key}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling setVoucherMetadata.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setVoucherMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setVoucherMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling setVoucherMetadata.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling setVoucherMetadata.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(value, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create a webhook subscription for you Oauth client
     * @param clientId Oauth client identifier
     * @param webhookSubscription Webhook subscription object
     */
    public craeteWebhookSubscription (clientId: string, webhookSubscription: WebhookSubscription) : Promise<{ response: http.ClientResponse; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling craeteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling craeteWebhookSubscription.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add event name to your webhook subscription
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     */
    public createWebhookSubscriptionEventNames (clientId: string, webhookSubscriptionId: number, eventName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete you webhook subscription
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     */
    public deleteWebhookSubscription (clientId: string, webhookSubscriptionId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove event name to your webhook subscription
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param eventName Webhook subscription event name
     */
    public deleteWebhookSubscriptionEventName (clientId: string, webhookSubscriptionId: number, eventName: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscription event names
     */
    public getWebhookEventNames () : Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your webhook subscriptions selected event names
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     */
    public getWebhookEventNamesBySubscriptionId (clientId: string, webhookSubscriptionId: number) : Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get logs for your webhook subscription
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param start Start time
     * @param end End time
     * @param page Page number
     * @param limit Page size
     */
    public getWebhookLogs (clientId: string, webhookSubscriptionId: number, start: Date, end: Date, page?: number, limit?: number) : Promise<{ response: http.ClientResponse; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhook subscriptions by your Oauth client id
     * @param clientId Oauth client identifier
     */
    public getWebhookSubscriptions (clientId: string) : Promise<{ response: http.ClientResponse; body: RestApiArrayResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getWebhookSubscriptions.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RestApiArrayResultWebhookSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultWebhookSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook subscription object
     * @param clientId Oauth client identifier
     * @param webhookSubscriptionId Webhook subscription identifier
     * @param webhookSubscription Webhook subscription object
     */
    public updateWebhookSubscription (clientId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/webhooks/{clientId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
